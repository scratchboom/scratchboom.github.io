{"version":3,"file":"Warper.js","mappings":"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AAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,IAAY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AA80C,EAAYllD,KAAM0D,Q,6DAExE,c5FgMA,MAS6D,oBAT7D,iB4F3KA,kCArBA,mBAMsD,OAqBA0hD,EAAeplD,K5F8KhC,MAAW,e4FnMe0D,E5FmMpB0M,MAAA,c,6D4FlM3C,c1F0LA,MAS6D,sBAT7D,iB0F5KA,kCAdA,mBAMuD,OAcDg1C,EAAeplD,K1F+KhC,MAAW,e0F7LgB0D,E1F6LrB0M,MAAA,c,6D0F5L3C,c3FsMA,MAS6D,iBAT7D,iB2F/LA,kCAPA,mBAMqD,OAOCg1C,EAAeplD,K3FkMhC,MAAW,e2FzMc0D,E3FyMnB0M,MAAA,c,6D2FxM3C,uEAMsD,OAAAg1C,EAAeplD,KAAM0D,Q,uEAE3E,c5FmKA,MAS6D,oBAT7D,iB4FpMA,+BAiCA,mBAMkD,OArCIwhD,EAAYllD,K5F2M7B,MAAW,e4FtKgB0D,E5FsKrB0M,MAAA,c,uE4FrK3C,c1F6JA,MAS6D,sBAT7D,iB0FrMA,+BAwCA,mBAMmD,OA5CG80C,EAAYllD,K1F4M7B,MAAW,e0FhKiB0D,E1FgKtB0M,MAAA,c,uE0F/J3C,c3FyKA,MAS6D,iBAT7D,iB2FxNA,+BA+CA,mBAMiD,OAnDK80C,EAAYllD,K3F+N7B,MAAW,e2F5Ke0D,E3F4KpB0M,MAAA,c,uE2F3K3C,cAtDA,mCAsDA,mBAMkD,OA1DI80C,EAAYllD,KA0DZ0D,Q,6DAEtD,c5FsIA,MAS6D,oBAT7D,iB4F3KA,kC5F4OJ,4B4FvMI,mBAQ6C,O5F0MP,MAAWw2B,E4FjPKkrB,EAAeplD,K5F8KhC,MAAW,e4FvIM0D,E5FuIX0M,MAAA,S4FFNA,K5FqEY,e,6D4FzMjD,c1F8HA,MAS6D,sBAT7D,iB0F5KA,kC1F6OJ,8B0F/LI,mBAQ+C,O1FkMP,MAAY6pB,E0FlPEmrB,EAAeplD,K1F+KhC,MAAW,e0F/HQ0D,E1F+Hb0M,MAAA,S0FOJA,K1F4Da,e,6D0FjMpD,c3FwIA,MAS6D,iBAT7D,iB2F/LA,kC3FkQJ,gB2F3MI,mBAQ2C,O3F8MP,M2FvQkBg1C,EAAeplD,K3FkMhC,MAAW,e2FzII0D,E3FyIT0M,MAAA,S2FFRA,K3FuEWgW,c,6D2F7M9C,cAhEA,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C,MAAF,sBAAgB,KAAAsjC,KAAhB,SAA6B,KAAAC,KAAD,aAA5B,Y,qCAG5E,gBAQ+F,WAAA4b,GAAiBnY,EAAYC,EAAU1D,I,wEAT1I,0CAmBkC,mBAClC,oBAA2BD,EAC3B,eAAmCC,EAAA,WAAO,ELxDyBib,GKwDtBx+C,ELxDwC4J,KKwD/B05B,ELxD2C15B,OKwDpD,ELxDsB40C,GKwDHx+C,ELxDqB4J,KKwDZ05B,ELxDwB15B,OKwDjC,EAChE,YLkSsC,IAAAs1C,GKlSnB3b,GACnB,YAAuB,eAASvjC,EAAW,oBCzH/C,mBAEI,MjGuIoD2+C,GiGvI3CnhD,EAAIoC,GACb,EjGsIoD++C,GiGtI3CjhD,EAAIkC,GACb,OjGmDkE2+C,GiGnDvDgB,EjGmDwE31C,KiGnDlE41C,EjGmD8E51C,OiGnDpF,EjGkF2C,IAAA00C,GiGlFjCiB,EjGkF2C31C,KiGlFtC41C,EjGkFuD51C,KAAZ,GAbhB,IAAA00C,GAAU,IAaTA,GiGlFpBiB,EjGkF8B31C,KiGlFzB41C,EjGkF0C51C,KAAZ,GAbNA,KiGrEnBhK,EjGqEmCgK,KAAX,GiGlExE,mBACI,MNwIsDg1C,GMxI7CphD,EAAIoC,GACb,ENuIsDg/C,GMvI7ClhD,EAAIkC,GACb,ONqDmE4+C,GMrDxDe,ENqD0E31C,KMrDpE41C,ENqDgF51C,OMrDtF,EN+E6C,IAAAs1C,GM/EnCK,EN+E8C31C,KAAK,SM/E9C41C,EN+E0D51C,OAb7B,IAAAs1C,GAAW,IAaVA,GM/EtBK,EN+EiC31C,KAAK,SM/EjC41C,EN+E6C51C,OAblBA,KAAK,IMlE3BhK,ENkEsCgK,OM/DtF,mBAmBI,GAAA25B,EAAO,EADuE,OjGwBZgb,GiGvBlDjiD,EjGuBmEsN,KiGvB1D+1B,EjGuBsE/1B,OiGvB/E,EAAc+1B,EjGsDwB,IAAA2e,GiGtDf3e,EjGsDyB/1B,KiGtDnB,GAAiB+1B,EAAKrjC,EjG2WhC,IAAAgiD,GiG3WuC/a,IjGsDO35B,KAAZ,GiGrDrE,GAAA25B,EAAO,EAFuE,OjGwBZgb,GiGtBlDjiD,EjGsBmEsN,KiGtB1D+1B,EjGsBsE/1B,OiGt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AuC,0CAAvC,QAMG,oD,2EAAA,kD,0DAOzC,EAAN,EAAM,kB,GAAA,Q,MCAa,2M,8BACf,iC,MAAY,0BDDgC,cCElC,MAAO,EAAP,WAAO,aAAP,WACR,M,OAAqB,K,cDH3B,OCIA,W,ODJA,G,cAQM,OAAc,gB,0ECnCG,aACvB,sB,IGgDR,GAaA,GCrBI,G,yBLIiE,OAN7D,W,OAM6D,G,mLMkMA,gB,aAAA,O,WAAA,kB,mBADjD,uF,oDAAA,iB,mBAAA,e,wBAAA,uB,eCnMpB,uB,IAI8C,gB,SAJ9C,oB,gCA/D2E,mEH8EvE,cAHa,kD,2CANjB,c,8CCRI,iB,kMG6HoF,gBAA7D,iBAAI,aAAU,yBAAd,W5M5FsB,EAAM,iB,e4M4F5B,EAA6D,6C,4FAJxF,oC,qCAAA,M,sDAAA,+C,4ECpBI,QnMpKJ,WCgDQ,GkMkIa,IADkC,wCAClB,8B,aAkB7B,SAAU,K,QACV,uC,QAII,wCApBA,wBAlER,e,0CtBNW,IAAP,E,esBiBuB,cAEf,kB,qBnMhIhB,aCgDQ,Q,IkMiI+C,6C,IAAA,eAClC,kE,gBAPb,EAAmB,KAAnB,kB,GACA,EAAI,uBACA,oC,CAEA,6BAAoB,G,4BAgF5B,8B,aAEiD,c,QAC1C,+BAAc,Q,QAQM,6BClHjB,KD4CI,S,KAGN,K,+EArBQ,qD,GAGR,2D,+CAqFmB,EALvB,cACU,oB,uFApFG,wB,wGAAD,mB,OAwFW,mBC7GJ,uB,2GA1JiB,eAExC,wB,yBA0GI,gBAAe,EACX,sBAAW,E,gCAEX,kB,sDAKJ,aAAO,Y,oCAWU,oCAHrB,QADY,gBACI,Y7BhJ0B,eAG1C,a,sGAIsB,kB,uDAGb,kBAAL,GMmHJ,oBACI,kBAAO,GNnHH,oBAAiB,gCACjB,mBAAK,wB,uD8BuFT,0F,8BAAA,qD,kDAAgB,aAAhB,gD,sFADJ,E,gICLY,WADE,K,OACW,gB,MACb,qB,QAEI,E,MACI,ahNgByB,cAAM,YgNdzB,sB,8DvO9Gb,mB,OAAb,OwOgNQ,uDCrCkB,sC,wBAAA,oECtEO,uF,MAAA,mD,6GAAA,wC,0EAFxB,yB,kBAAA,uE,OAKT,gE,qPAHoB,E,sBAiBhB,iB,WAAA,c,iJACF,mC,E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","sources":["webpack://Warper/webpack/universalModuleDefinition","webpack://Warper/./kotlin-dce/js/src/kotlin/math.kt","webpack://Warper/./kotlin-dce/runtime/arrayUtils.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Collections.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Collections.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections.kt","webpack://Warper/../../../../Delaunator/src/commonMain/kotlin/sw/delaunator/Delaunator.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/Standard.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Arrays.kt","webpack://Warper/./kotlin/src/kotlin/util/Standard.kt","webpack://Warper/../../../../Warper/src/commonMain/kotlin/sw/warper/WarperEditor.kt","webpack://Warper/./kotlin/common/src/generated/_Collections.kt","webpack://Warper/./kotlin/src/kotlin/util/Preconditions.kt","webpack://Warper/./kotlin/js/src/generated/_ArraysJs.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/Serializers.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","webpack://Warper/../../../../Warper/src/commonMain/kotlin/sw/warper/ControlPoint.kt","webpack://Warper/../../../../Warper/src/commonMain/kotlin/sw/warper/History.kt","webpack://Warper/./kotlin/src/kotlin/collections/Collections.kt","webpack://Warper/../../../../Warper/src/commonMain/kotlin/sw/warper/WrpFormat.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/math/Vec3.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/math/Func.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/SerialFormat.kt","webpack://Warper/../../../../Warper/src/jsMain/kotlin/sw/warper/WarperJsMain.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/Performance.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/Preconditions.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/asteroids/GridSampleRender.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/asteroids/entities/RaceTimerEntity.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/Strings.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Maps.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Strings.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/immediate/ImmediateMode.kt","webpack://Warper/./kotlin-dce/js/src/generated/_ArraysJs.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/tetris/CupEntity.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/tetris/DropEntity.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/Continuation.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/Result.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/analytics/Analytics.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/color/Color.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/entities/Entity.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/Camera.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/FloatBuffer.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/Framebuffer.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/GL.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/GLOO.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/PlainCamera.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/Viewport.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/fonts/SdfFont.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/gloo/primitives/Intersection.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/input/Keyboard.kt","webpack://Warper/./kotlin-dce/src/kotlin/CharCode.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/loading/Loader.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/math/Mat.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/math/Ray.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/math/Vec4.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/pool/VecPool.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/sound/SoundBuffer.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/storage/Storage.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/tetris/Ads.kt","webpack://Warper/../../../../src/commonMain/kotlin/kmptemplate/ui/Widgets.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/analytics/JsYaMetricaAnalytics.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/asteroids/Platform.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/browser/Download.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/data/FloatArr.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/entities/DroppedImage.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/entities/YaGamesJsPlayer.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/gloo/FramebufferHandle.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/gloo/GL.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/input/Keyboard.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/sound/HowlerAudioImpl.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/storage/JsLocalStorage.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/storage/YaGamesSafeStorage.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/tetris/YaGamesAds.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/time/Timer.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/yagames/YaGamesLeaderBoard.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/AsteroidsJsMain.kt","webpack://Warper/../../../../src/jsMain/kotlin/kmptemplate/io/IO.kt","webpack://Warper/./kotlin-dce/wrapper.js","webpack://Warper/./kotlin-dce/js/arrayUtils.js","webpack://Warper/./kotlin-dce/js/callableReferenceUtils.js","webpack://Warper/./kotlin-dce/js/conversions.js","webpack://Warper/./kotlin-dce/js/core.js","webpack://Warper/./kotlin-dce/js/misc.js","webpack://Warper/./kotlin-dce/js/polyfills.js","webpack://Warper/./kotlin-dce/js/markerFunctions.js","webpack://Warper/./kotlin-dce/js/rtti.js","webpack://Warper/./kotlin-dce/js/long.js","webpack://Warper/./kotlin-dce/runtime/Enum.kt","webpack://Warper/./kotlin-dce/primitiveCompanionObjects.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Ranges.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UByte.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UInt.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UShort.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Sets.kt","webpack://Warper/./kotlin-dce/src/kotlin/ranges/PrimitiveRanges.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/StringNumberConversions.kt","webpack://Warper/./kotlin-dce/src/kotlin/time/Duration.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UnsignedUtils.kt","webpack://Warper/./kotlin-dce/common/src/generated/_OneToManyTitlecaseMappings.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/text/char.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/text/string.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/Char.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Iterables.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Sequences.kt","webpack://Warper/./kotlin-dce/builtin-sources/Unit.kt","webpack://Warper/./kotlin-dce/builtin-sources/Collections.kt","webpack://Warper/./kotlin-dce/src/kotlin/builtins.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/CoroutineImpl.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://Warper/./kotlin-dce/src/kotlin/exceptions.kt","webpack://Warper/./kotlin-dce/src/kotlin/kotlin.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/numberConversions_js-v1.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/js.arrays/fill.kt","webpack://Warper/./kotlin-dce/js/src/generated/_CharCategories.kt","webpack://Warper/./kotlin-dce/js/src/generated/_ComparisonsJs.kt","webpack://Warper/./kotlin-dce/js/src/generated/_DigitChars.kt","webpack://Warper/./kotlin-dce/js/src/generated/_LetterChars.kt","webpack://Warper/./kotlin-dce/js/src/generated/_OtherLowercaseChars.kt","webpack://Warper/./kotlin-dce/js/src/generated/_TitlecaseMappings.kt","webpack://Warper/./kotlin-dce/js/src/generated/_WhitespaceChars.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/AbstractMutableCollection.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/AbstractMutableList.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/AbstractMutableMap.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/AbstractMutableSet.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/ArrayList.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/EqualityComparator.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/Comparator.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/HashMap.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/HashSet.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/InternalHashCodeMap.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/InternalStringMap.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/LinkedHashMap.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/LinkedHashSet.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/console.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/coroutines/SafeContinuationJs.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/exceptionUtils.kt","webpack://Warper/./kotlin-dce/src/kotlin/numbers_js-v1.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/numbers.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/random/PlatformRandom.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/KClassImpl.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/collections/InternalMap.kt","webpack://Warper/./kotlin-dce/src/kotlin/jsOperators.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/KTypeImpl.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/primitives.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/reflection.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/text/StringBuilderJs.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/text/numberConversions.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/text/stringsCode.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/throwableExtensions.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/time/DurationJs.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/time/DurationUnit.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/AbstractCollection.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/AbstractList.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/AbstractMap.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/AbstractSet.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/ArrayDeque.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/IndexedValue.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Iterators.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/MapWithDefault.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/MutableCollections.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/PrimitiveIterators.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Sequences.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/SequenceBuilder.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/ContinuationInterceptor.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/CoroutineContext.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/CoroutineContextImpl.kt","webpack://Warper/./kotlin-dce/src/kotlin/coroutines/intrinsics/Intrinsics.kt","webpack://Warper/./kotlin-dce/src/kotlin/internal/progressionUtil.kt","webpack://Warper/./kotlin-dce/src/kotlin/random/Random.kt","webpack://Warper/./kotlin-dce/src/kotlin/random/XorWowRandom.kt","webpack://Warper/./kotlin-dce/src/kotlin/ranges/ProgressionIterators.kt","webpack://Warper/./kotlin-dce/src/kotlin/ranges/Progressions.kt","webpack://Warper/./kotlin-dce/src/kotlin/ranges/Ranges.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/Appendable.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/Indent.kt","webpack://Warper/./kotlin-dce/src/kotlin/ranges/Range.kt","webpack://Warper/./kotlin-dce/src/kotlin/time/DurationUnit.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/DeepRecursive.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/Lazy.kt","webpack://Warper/./kotlin-dce/src/kotlin/text/StringBuilder.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/Tuples.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UByteArray.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/ULong.kt","webpack://Warper/./kotlin-dce/src/kotlin/experimental/bitwiseOperations.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UIntArray.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UIntRange.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/ULongArray.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/ULongRange.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UProgressionUtil.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UShortArray.kt","webpack://Warper/./kotlin-dce/unsigned/src/kotlin/UStrings.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Sets.kt","webpack://Warper/./kotlin-dce/src/kotlin/reflection_js-v1.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/coroutines/cancellation/CancellationException.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/json.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/JsClass.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/KTypeHelpers.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/text/utf8Encoding.kt","webpack://Warper/../../../../../common/src/Delay.kt","webpack://Warper/../../../../../common/src/EventLoop.common.kt","webpack://Warper/../../../../../common/src/flow/SharedFlow.kt","webpack://Warper/../../../../../common/src/internal/LockFreeTaskQueue.kt","webpack://Warper/../../../../../js/src/JSDispatcher.kt","webpack://Warper/../../../../../common/src/AbstractCoroutine.kt","webpack://Warper/../../../../../common/src/Builders.common.kt","webpack://Warper/../../../../../common/src/CancellableContinuation.kt","webpack://Warper/../../../../../common/src/CancellableContinuationImpl.kt","webpack://Warper/../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://Warper/../../../../../common/src/CompletionState.kt","webpack://Warper/../../../../../common/src/CoroutineDispatcher.kt","webpack://Warper/../../../../../common/src/CoroutineExceptionHandler.kt","webpack://Warper/../../../../../common/src/CompletableDeferred.kt","webpack://Warper/../../../../../common/src/CoroutineName.kt","webpack://Warper/../../../../../common/src/CoroutineScope.kt","webpack://Warper/../../../../../common/src/CoroutineStart.kt","webpack://Warper/../../../../../common/src/Job.kt","webpack://Warper/../../../../../common/src/JobSupport.kt","webpack://Warper/../../../../../common/src/MainCoroutineDispatcher.kt","webpack://Warper/../../../../../common/src/NonCancellable.kt","webpack://Warper/../../../../../common/src/Supervisor.kt","webpack://Warper/../../../../../common/src/channels/AbstractChannel.kt","webpack://Warper/../../../../../js/src/internal/LinkedList.kt","webpack://Warper/../../../../../js/src/internal/StackTraceRecovery.kt","webpack://Warper/../../../../../common/src/Timeout.kt","webpack://Warper/../../../../../common/src/flow/terminal/Reduce.kt","webpack://Warper/../../../../../common/src/internal/Atomic.kt","webpack://Warper/../../../../../common/src/flow/operators/Zip.kt","webpack://Warper/../../../../../common/src/flow/terminal/Collect.kt","webpack://Warper/../../../../../common/src/internal/ConcurrentLinkedList.kt","webpack://Warper/../../../../../common/src/internal/DispatchedContinuation.kt","webpack://Warper/../../../../../common/src/internal/DispatchedTask.kt","webpack://Warper/../../../../../common/src/channels/Channels.common.kt","webpack://Warper/../../../../../common/src/channels/ConflatedBroadcastChannel.kt","webpack://Warper/../../../../../common/src/flow/Flow.kt","webpack://Warper/../../../../../common/src/flow/operators/Merge.kt","webpack://Warper/../../../../../common/src/flow/operators/Limit.kt","webpack://Warper/../../../../../common/src/flow/internal/SafeCollector.common.kt","webpack://Warper/../../../../../common/src/flow/internal/FlowExceptions.common.kt","webpack://Warper/../../../../../common/src/flow/terminal/Count.kt","webpack://Warper/../../../../../common/src/internal/InlineList.kt","webpack://Warper/../../../../../common/src/internal/LimitedDispatcher.kt","webpack://Warper/../../../../../common/src/internal/LocalAtomics.common.kt","webpack://Warper/../../../../../common/src/intrinsics/Undispatched.kt","webpack://Warper/../../../../../common/src/selects/WhileSelect.kt","webpack://Warper/../../../../../common/src/sync/Semaphore.kt","webpack://Warper/../../../../../js/src/CompletionHandler.kt","webpack://Warper/../../../../../common/src/internal/Scopes.kt","webpack://Warper/../../../../../common/src/internal/Symbol.kt","webpack://Warper/../../../../../common/src/internal/SystemProps.common.kt","webpack://Warper/../../../../../common/src/internal/ThreadSafeHeap.kt","webpack://Warper/../../../../../js/src/Runnable.kt","webpack://Warper/../../../../../common/src/selects/Select.kt","webpack://Warper/../../../../../js/src/CoroutineContext.kt","webpack://Warper/../../../../../common/src/intrinsics/Cancellable.kt","webpack://Warper/../../../../../common/src/selects/SelectUnbiased.kt","webpack://Warper/../../../../../common/src/sync/Mutex.kt","webpack://Warper/../../../../../js/src/Debug.kt","webpack://Warper/../../../../../js/src/Dispatchers.kt","webpack://Warper/../../../../../js/src/EventLoop.kt","webpack://Warper/../../../../../js/src/CoroutineExceptionHandlerImpl.kt","webpack://Warper/../../../../../js/src/Exceptions.kt","webpack://Warper/../../../../../js/src/Promise.kt","webpack://Warper/../../../../../js/src/SchedulerTask.kt","webpack://Warper/../../../../../js/src/internal/CopyOnWriteList.kt","webpack://Warper/../../../../../js/src/internal/LocalAtomics.kt","webpack://Warper/../../../../../js/src/internal/ThreadContext.kt","webpack://Warper/../../../../../js/src/internal/ThreadLocal.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/ElementMarker.kt","webpack://Warper/./kotlin-dce/common/src/generated/_UArrays.kt","webpack://Warper/./kotlin-dce/js/src/kotlin/reflect/AssociatedObjects.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/PolymorphicSerializer.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/SealedSerializer.kt","webpack://Warper/./kotlin-dce/src/kotlin/collections/Grouping.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/SerializationExceptions.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/SerializersCache.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/builtins/BuiltinSerializers.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/ContextAware.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptor.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialKinds.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/PluginGeneratedSerialDescriptor.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/encoding/AbstractDecoder.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/encoding/AbstractEncoder.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/AbstractPolymorphicSerializer.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/BuiltInSerializers.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/CollectionDescriptors.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/CollectionSerializers.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/InlineClassDescriptor.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/NoOpEncoder.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/NullableSerializer.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/ObjectSerializer.kt","webpack://Warper/./kotlin-dce/src/kotlin/util/HashCode.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/PrimitiveArraysSerializers.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/PluginHelperInterfaces.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/Primitives.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/Tagged.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/Tuples.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/ValueClasses.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/modules/SerializersModule.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/modules/SerializersModuleBuilders.kt","webpack://Warper/../../../../../core/jsMain/src/kotlinx/serialization/Serializers.kt","webpack://Warper/../../../../../core/jsMain/src/kotlinx/serialization/internal/Platform.kt","webpack://Warper/./kotlin-dce/common/src/generated/_Maps.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/modules/SerializersModuleCollector.kt","webpack://Warper/../../../../../core/commonMain/src/kotlinx/serialization/internal/JsonInternalDependencies.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/lexer/AbstractJsonLexer.kt","webpack://Warper/../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/DynamicDecoders.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/Json.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonAnnotations.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonConfiguration.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElement.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/JsonElementSerializers.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/Composers.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonElementMarker.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonExceptions.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonNamesMap.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonPath.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonStreams.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/JsonTreeReader.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/Polymorphic.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonEncoder.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/PolymorphismValidator.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/SchemaCache.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonDecoder.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StreamingJsonEncoder.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/StringOps.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/TreeJsonDecoder.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/WriteMode.kt","webpack://Warper/../../../../../formats/json/commonMain/src/kotlinx/serialization/json/internal/lexer/StringJsonLexer.kt","webpack://Warper/../../../../../formats/json/jsMain/src/kotlinx/serialization/json/JsonSchemaCache.kt","webpack://Warper/../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/JsonToStringWriter.kt","webpack://Warper/../../../../../formats/json/jsMain/src/kotlinx/serialization/json/internal/createMapForCache.kt","webpack://Warper/webpack/bootstrap","webpack://Warper/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Warper\"] = factory();\n\telse\n\t\troot[\"Warper\"] = factory();\n})(this, () => {\nreturn ","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeSinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeCosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeTanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeAsinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeAcosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeAtanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeHypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeExpm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeLog10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeLog2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeLog1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeTrunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeSign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeSign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeSinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeCosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeTanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeAsinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeAcosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeAtanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeHypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeExpm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeLog10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeLog2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeLog1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeSign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeSign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.max(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.max(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.min(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.min(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.convertToSetForSetOperation()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.convertToSetForSetOperation()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\nimport kotlin.js.arrayBufferIsView\n\n/**\n * Returns the array if it's not `null`, or an empty array otherwise.\n * @sample samples.collections.Arrays.Usage.arrayOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n/**\n * Returns a *typed* array containing all of the elements of this collection.\n *\n * Allocates an array of runtime type `T` having its size equal to the size of this collection\n * and populates the array with the elements of this collection.\n * @sample samples.collections.Collections.Collections.collectionToTypedArray\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableList\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableListWith\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (arrayBufferIsView(destination) && arrayBufferIsView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}\n\ninternal actual fun brittleContainsOptimizationEnabled(): Boolean = false","package sw.delaunator\n\nimport kotlin.math.*\n\nclass Edge(val index: Int, val p: Point, val q: Point)\n\nclass Point(var x: Double, var y: Double) {\n\n    override fun toString() = \"{$x},{$y}\"\n\n    operator fun minus(other: Point): Point {\n        return Point(x - other.x, y - other.y)\n    }\n\n    operator fun plus(other: Point): Point {\n        return Point(x + other.x, y + other.y)\n    }\n\n    operator fun div(other: Int): Point {\n        return Point(x / other, y / other)\n    }\n}\n\nclass Triangle(val points: List<Point>, val Index: Int)\n\nclass VoronoiCell(val index: Int, val points: List<Point>)\n\nclass Delaunator(val points: List<Point>) {\n\n    private val EPSILON = 2.0.pow(-52.0)\n    private val edgeStack = Array(512) { 0 }\n\n    var triangles: Array<Int>\n    var halfedges: Array<Int>\n\n    private val hashSize: Int\n    private val hullPrev: MutableList<Int>\n    private val hullNext: MutableList<Int>\n    private val hullTri: MutableList<Int>\n    private val hullHash: Array<Int>\n\n    private var cx: Double\n    private var cy: Double\n\n    private var trianglesLen: Int\n    private val coords: Array<Double>\n    private var hullStart: Int\n    private var hullSize: Int\n    private val hull: Array<Int>\n\n\n    init {\n        if (points.size < 3) {\n            throw IndexOutOfBoundsException(\"Need at least 3 points\")\n        }\n\n        coords = Array(points.size * 2) { .0 }\n\n        points.forEachIndexed { index, point ->\n            coords[2 * index] = point.x\n            coords[2 * index + 1] = point.y\n        }\n\n        val n = coords.size shr 1\n        val maxTriangles = 2 * n - 5\n\n        triangles = Array(maxTriangles * 3) { 0 }\n\n        halfedges = Array(maxTriangles * 3) { 0 }\n        hashSize = ceil(sqrt(n.toDouble())).toInt()\n\n        hullPrev = MutableList(n) { 0 }\n        hullNext = MutableList(n) { 0 }\n        hullTri = MutableList(n) { 0 }\n        hullHash = Array(hashSize) { 0 }\n\n        val ids = Array(n) { 0 }\n\n        var minX = Double.POSITIVE_INFINITY\n        var minY = Double.POSITIVE_INFINITY\n        var maxX = Double.POSITIVE_INFINITY\n        var maxY = Double.POSITIVE_INFINITY\n\n        for (i in 0 until n) {\n            val x = coords[2 * i]\n            val y = coords[2 * i + 1]\n            if (x < minX) minX = x\n            if (y < minY) minY = y\n            if (x > maxX) maxX = x\n            if (y > maxY) maxY = y\n            ids[i] = i\n        }\n\n        val cx = (minX + maxX) / 2\n        val cy = (minY + maxY) / 2\n\n        var minDist = Double.POSITIVE_INFINITY\n        var i0 = 0\n        var i1 = 0\n        var i2 = 0\n\n        // pick a seed point close to the center\n        for (i in 0 until n) {\n            val d = dist(cx, cy, coords[2 * i], coords[2 * i + 1])\n            if (d < minDist) {\n                i0 = i\n                minDist = d\n            }\n        }\n        val i0x = coords[2 * i0]\n        val i0y = coords[2 * i0 + 1]\n\n        minDist = Double.POSITIVE_INFINITY\n\n        // find the point closest to the seed\n        for (i in 0 until n) {\n            if (i == i0) continue\n            val d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1])\n            if (d < minDist && d > 0) {\n                i1 = i\n                minDist = d\n            }\n        }\n\n        var i1x = coords[2 * i1]\n        var i1y = coords[2 * i1 + 1]\n\n        var minRadius = Double.POSITIVE_INFINITY\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (i in 0 until n) {\n            if (i == i0 || i == i1) continue\n            val r = circumRadius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1])\n            if (r < minRadius) {\n                i2 = i\n                minRadius = r\n            }\n        }\n        var i2x = coords[2 * i2]\n        var i2y = coords[2 * i2 + 1]\n\n        if (minRadius == Double.POSITIVE_INFINITY) {\n            throw Exception(\"No Delaunay triangulation exists for this input.\")\n        }\n\n        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {\n            val i = i1\n            val x = i1x\n            val y = i1y\n            i1 = i2\n            i1x = i2x\n            i1y = i2y\n            i2 = i\n            i2x = x\n            i2y = y\n        }\n\n        val center = circumCenter(i0x, i0y, i1x, i1y, i2x, i2y)\n        this.cx = center.x\n        this.cy = center.y\n\n        val dists = Array(n) { i ->\n            dist(coords[2 * i], coords[2 * i + 1], center.x, center.y)\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(ids, dists, 0, n - 1)\n\n        // set up the seed triangle as the starting hull\n        hullStart = i0\n        hullSize = 3\n\n        hullPrev[i2] = i1\n        hullNext[i0] = i1\n        hullPrev[i0] = i2\n        hullNext[i1] = i2\n        hullPrev[i1] = i0\n        hullNext[i2] = i0\n\n        hullTri[i0] = 0\n        hullTri[i1] = 1\n        hullTri[i2] = 2\n\n        hullHash[hashKey(i0x, i0y)] = i0\n        hullHash[hashKey(i1x, i1y)] = i1\n        hullHash[hashKey(i2x, i2y)] = i2\n\n        trianglesLen = 0\n        addTriangle(i0, i1, i2, -1, -1, -1)\n\n        var xp = .0\n        var yp = .0\n\n        for (k in ids.indices) {\n            val i = ids[k]\n            val x = coords[2 * i]\n            val y = coords[2 * i + 1]\n\n            // skip near-duplicate points\n            if (k > 0 && abs(x - xp) <= EPSILON && abs(y - yp) <= EPSILON) continue\n            xp = x\n            yp = y\n\n            // skip seed triangle points\n            if (i == i0 || i == i1 || i == i2) continue\n\n            // find a visible edge on the convex hull using edge hash\n            var start = 0\n            for (j in 0 until hashSize) {\n                val key = hashKey(x, y)\n                start = hullHash[(key + j) % hashSize]\n                if (start != -1 && start != hullNext[start]) break\n            }\n\n\n            start = hullPrev[start]\n            var e = start\n            var q = hullNext[e]\n\n            while (!orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {\n                e = q\n                if (e == start) {\n                    e = Int.MAX_VALUE\n                    break\n                }\n\n                q = hullNext[e]\n            }\n\n            if (e == Int.MAX_VALUE) continue // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            var t = addTriangle(e, i, hullNext[e], -1, -1, hullTri[e])\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = legalize(t + 2)\n            hullTri[e] = t // keep track of boundary triangles on the hull\n            hullSize++\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            var next = hullNext[e]\n            q = hullNext[next]\n\n            while (orient(x, y, coords[2 * next], coords[2 * next + 1], coords[2 * q], coords[2 * q + 1])) {\n                t = addTriangle(next, i, q, hullTri[i], -1, hullTri[next])\n                hullTri[i] = legalize(t + 2)\n                hullNext[next] = next // mark as removed\n                hullSize--\n                next = q\n\n                q = hullNext[next]\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e == start) {\n                q = hullPrev[e]\n\n                while (orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {\n                    t = addTriangle(q, i, e, -1, hullTri[e], hullTri[q])\n                    legalize(t + 2)\n                    hullTri[q] = t\n                    hullNext[e] = e // mark as removed\n                    hullSize--\n                    e = q\n\n                    q = hullPrev[e]\n                }\n            }\n\n            // update the hull indices\n            hullPrev[i] = e\n            hullStart = e\n            hullPrev[next] = i\n            hullNext[e] = i\n            hullNext[i] = next\n\n            // save the two new edges in the hash table\n            hullHash[hashKey(x, y)] = i\n            hullHash[hashKey(coords[2 * e], coords[2 * e + 1])] = e\n        }\n\n        hull = Array(hullSize) { 0 }\n        var s = hullStart\n        for (i in 0 until hullSize) {\n            hull[i] = s\n            s = hullNext[s]\n        }\n\n        // get rid of temporary arrays\n        hullPrev.clear()\n        hullNext.clear()\n        hullTri.clear()\n\n        //// trim typed triangle mesh arrays\n        triangles = triangles.take(trianglesLen).toTypedArray()\n        halfedges = halfedges.take(trianglesLen).toTypedArray()\n    }\n\n    private fun hashKey(x: Double, y: Double): Int {\n        return (floor(pseudoAngle(x - cx, y - cy) * hashSize) % hashSize).toInt()\n    }\n\n    private fun pseudoAngle(dx: Double, dy: Double): Double {\n        val p = dx / (abs(dx) + abs(dy))\n        return (if (dy > 0) 3 - p else 1 + p) / 4 // [0..1]\n    }\n\n    private fun legalize(index: Int): Int {\n        var a = index\n        var i = 0\n        var ar: Int\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            val b = halfedges[a]\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            val a0 = a - a % 3\n            ar = a0 + (a + 2) % 3\n\n            if (b == -1) { // convex hull edge\n                if (i == 0) break\n                a = edgeStack[--i]\n                continue\n            }\n\n            val b0 = b - b % 3\n            val al = a0 + (a + 1) % 3\n            val bl = b0 + (b + 2) % 3\n\n            val p0 = triangles[ar]\n            val pr = triangles[a]\n            val pl = triangles[al]\n            val p1 = triangles[bl]\n\n            val illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]\n            )\n\n            if (illegal) {\n                triangles[a] = p1\n                triangles[b] = p0\n\n                val hbl = halfedges[bl]\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl == -1) {\n                    var e = hullStart\n                    do {\n                        if (hullTri[e] == bl) {\n                            hullTri[e] = a\n                            break\n                        }\n                        e = hullNext[e]\n                    } while (e != hullStart)\n                }\n                link(a, hbl)\n                link(b, halfedges[ar])\n                link(ar, bl)\n\n                val br = b0 + (b + 1) % 3\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < edgeStack.size) {\n                    edgeStack[i++] = br\n                }\n            } else {\n                if (i == 0) break\n                a = edgeStack[--i]\n            }\n        }\n\n        return ar\n    }\n\n    private fun inCircle(\n        ax: Double,\n        ay: Double,\n        bx: Double,\n        by: Double,\n        cx: Double,\n        cy: Double,\n        px: Double,\n        py: Double\n    ): Boolean {\n        val dx = ax - px\n        val dy = ay - py\n        val ex = bx - px\n        val ey = by - py\n        val fx = cx - px\n        val fy = cy - py\n        val ap = dx * dx + dy * dy\n        val bp = ex * ex + ey * ey\n        val cp = fx * fx + fy * fy\n        return dx * (ey * cp - bp * fy) -\n                dy * (ex * cp - bp * fx) +\n                ap * (ex * fy - ey * fx) < 0\n    }\n\n    private fun link(a: Int, b: Int) {\n        halfedges[a] = b\n        if (b != -1) halfedges[b] = a\n    }\n\n    private fun circumRadius(\n        ax: Double,\n        ay: Double,\n        bx: Double,\n        by: Double,\n        cx: Double,\n        cy: Double\n    ): Double {\n        val dx = bx - ax\n        val dy = by - ay\n        val ex = cx - ax\n        val ey = cy - ay\n        val bl = dx * dx + dy * dy\n        val cl = ex * ex + ey * ey\n        val d = 0.5 / (dx * ey - dy * ex)\n        val x = (ey * bl - dy * cl) * d\n        val y = (dx * cl - ex * bl) * d\n        return x * x + y * y\n    }\n\n    private fun quicksort(ids: Array<Int>, dists: Array<Double>, left: Int, right: Int) {\n        if (right - left <= 20) {\n            for (i in left + 1..right) {\n                val temp = ids[i]\n                val tempDist = dists[temp]\n                var j = i - 1\n                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--]\n                ids[j + 1] = temp\n            }\n        } else {\n            val median = left + right shr 1\n            var i = left + 1\n            var j = right\n            swap(ids, median, i)\n            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right)\n            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right)\n            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i)\n            val temp = ids[i]\n            val tempDist = dists[temp]\n            while (true) {\n                do i++ while (dists[ids[i]] < tempDist)\n                do j-- while (dists[ids[j]] > tempDist)\n                if (j < i) break\n                swap(ids, i, j)\n            }\n            ids[left + 1] = ids[j]\n            ids[j] = temp\n            if (right - i + 1 >= j - left) {\n                quicksort(ids, dists, i, right)\n                quicksort(ids, dists, left, j - 1)\n            } else {\n                quicksort(ids, dists, left, j - 1)\n                quicksort(ids, dists, i, right)\n            }\n        }\n    }\n\n    private fun swap(arr: Array<Int>, i: Int, j: Int) {\n        val tmp = arr[i]\n        arr[i] = arr[j]\n        arr[j] = tmp\n    }\n\n    private fun circumCenter(\n        ax: Double,\n        ay: Double,\n        bx: Double,\n        by: Double,\n        cx: Double,\n        cy: Double\n    ): Point {\n        val dx = bx - ax\n        val dy = by - ay\n        val ex = cx - ax\n        val ey = cy - ay\n        val bl = dx * dx + dy * dy\n        val cl = ex * ex + ey * ey\n        val d = 0.5 / (dx * ey - dy * ex)\n        val x = ax + (ey * bl - dy * cl) * d\n        val y = ay + (dx * cl - ex * bl) * d\n        return Point(x, y)\n    }\n\n    private fun orient(px: Double, py: Double, qx: Double, qy: Double, rx: Double, ry: Double): Boolean {\n        return (qy - py) * (rx - qx) - (qx - px) * (ry - qy) < 0\n    }\n\n    private fun addTriangle(i0: Int, i1: Int, i2: Int, a: Int, b: Int, c: Int): Int {\n        val t = trianglesLen\n        triangles[t] = i0\n        triangles[t + 1] = i1\n        triangles[t + 2] = i2\n        link(t, a)\n        link(t + 1, b)\n        link(t + 2, c)\n        trianglesLen += 3\n        return t\n    }\n\n    private fun dist(ax: Double, ay: Double, bx: Double, by: Double): Double {\n        val dx = ax - bx\n        val dy = ay - by\n        return dx * dx + dy * dy\n    }\n\n    private fun createHull(points: List<Point>): List<Edge> {\n        return points.mapIndexed { index: Int, point: Point ->\n            if (points.lastIndex == index) {\n                Edge(0, point, points.first())\n            } else {\n                Edge(0, point, points[index + 1])\n            }\n        }\n    }\n\n    private fun getHullPoints(): List<Point> {\n        return hull.map { x -> points[x] }\n    }\n\n    fun getHullEdges(): List<Edge> {\n        return createHull(getHullPoints())\n    }\n\n    fun getVoronoiCells(): Sequence<VoronoiCell> {\n        return sequence {\n            val seen = HashSet<Int>()  // of point ids\n            for (triangleId in triangles.indices) {\n                val id = triangles[nextHalfedgeIndex(triangleId)]\n                if (!seen.contains(id)) {\n                    seen.add(id)\n                    val edges = edgesAroundPoint(triangleId)\n                    val triangles = edges.map { x -> triangleOfEdge(x) }\n                    val vertices = triangles.map { x -> getTriangleCenter(x) }\n                    yield(VoronoiCell(id, vertices.toList()))\n                }\n            }\n        }\n    }\n\n    private fun getTriangleCenter(t: Int): Point {\n        val vertices = getTrianglePoints(t)\n        return getCentroid(vertices)\n    }\n\n    private fun getCentroid(points: List<Point>): Point {\n\n        var accumulatedArea = 0.0\n        var centerX = 0.0\n        var centerY = 0.0\n        var j = points.size - 1\n        for (i in points.indices) {\n            val temp = points[i].x * points[j].y - points[j].x * points[i].y\n            accumulatedArea += temp\n            centerX += (points[i].x + points[j].x) * temp\n            centerY += (points[i].y + points[j].y) * temp\n            j = i\n        }\n\n        accumulatedArea *= 3.0\n        return Point(\n            centerX / accumulatedArea,\n            centerY / accumulatedArea\n        )\n    }\n\n    private fun getTrianglePoints(t: Int): List<Point> {\n        return pointsOfTriangle(t).map { p -> points[p] }\n    }\n\n    private fun pointsOfTriangle(t: Int): List<Int> {\n        return edgesOfTriangle(t).map { e -> triangles[e] }\n    }\n\n    private fun edgesOfTriangle(t: Int): List<Int> {\n        return listOf(3 * t, 3 * t + 1, 3 * t + 2)\n    }\n\n    private fun triangleOfEdge(e: Int): Int {\n        return floor(e / 3.0).toInt()\n    }\n\n    private fun edgesAroundPoint(start: Int): Sequence<Int> {\n        return sequence {\n            var incoming = start\n            do {\n                yield(incoming)\n                val outgoing = nextHalfedgeIndex(incoming)\n                incoming = halfedges[outgoing]\n            } while (incoming != -1 && incoming != start)\n        }\n    }\n\n    private fun nextHalfedgeIndex(e: Int): Int {\n        return if (e % 3 == 2) e - 2 else e + 1\n    }\n\n    fun getEdges(): Sequence<Edge> {\n        return sequence {\n            for (e in triangles.indices) {\n                if (e > halfedges[e]) {\n                    val p = points[triangles[e]]\n                    val q = points[triangles[nextHalfedgeIndex(e)]]\n                    yield(Edge(e, p, q))\n                }\n            }\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return any { it == element }\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return any { it == element }\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Double>.max(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Float>.max(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.max(): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.max(): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.max(): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.max(): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.max(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.max(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.max(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Double>.min(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Float>.min(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.min(): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.min(): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.min(): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.min(): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.min(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.min(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.min(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package sw.warper\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL.Companion.GL_SCISSOR_TEST\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.OrthoCamera\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.primitives.Plane\nimport kmptemplate.gloo.primitives.intersect\nimport kmptemplate.input.KEY_D\nimport kmptemplate.input.KEY_O\nimport kmptemplate.input.KEY_Q\nimport kmptemplate.input.KEY_S\nimport kmptemplate.input.KEY_W\nimport kmptemplate.input.KEY_Z\nimport kmptemplate.input.Keyboard\nimport kmptemplate.io.saveFile\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.inversed\nimport kmptemplate.math.linearMap\nimport kmptemplate.math.setMult\nimport kmptemplate.math.sq\nimport kmptemplate.ui.UiEvent\nimport kotlinx.serialization.ExperimentalSerializationApi\nimport kotlinx.serialization.encodeToString\nimport kotlinx.serialization.json.Json\n//import kotlinx.serialization.json.decodeFromStream\n//import kotlinx.serialization.json.encodeToStream\nimport sw.delaunator.Delaunator\nimport sw.delaunator.Point\n//import java.io.FileInputStream\n//import java.io.FileOutputStream\nimport kotlin.random.Random\n\nclass WarperEditor : Entity() {\n\n    private lateinit var delaunator: Delaunator\n    private lateinit var im: ImmediateMode\n    private lateinit var gloo: GLOO\n\n    val cam = OrthoCamera()\n    val resCam = OrthoCamera()\n\n    private val srcPoints = mutableListOf<ControlPoint>()\n    private val destPoints = mutableListOf<ControlPoint>()\n\n    val plane = Plane(Vec3(), Vec3(1f, 0f, 0f), Vec3(0f, 1f, 0f))\n\n    lateinit var destTexture: Texture2D\n    lateinit var srcTexture: Texture2D\n    private var srcImgPath: String? = null\n    private var dstImgPath: String? = null\n\n    //transformation matrix of input image\n    val srcMat = Mat4().apply { setIdentity() }\n    private val srcTranslateMat = Mat4().apply { setIdentity() }\n    private val srcScaleMat = Mat4().apply { setIdentity() }\n\n    //transformation matrix of output image\n    val destMat = Mat4().apply { setTranslate(1f, 0f, 0f) }\n    private val destTranslateMat = Mat4().apply { setTranslate(1f, 0f, 0f) }\n    private val destScaleMat = Mat4().apply { setIdentity() }\n\n    var nearestDestControlPoint: ControlPoint? = null\n    var nearestSrcControlPoint: ControlPoint? = null\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n\n        im = ImmediateMode(gloo)\n\n        val editor = this\n\n        val rnd = Random(4208673204876L)\n        for (i in 0 until 3) {\n            addControlPoint(0.45f * rnd.nextFloat(), rnd.nextFloat())\n        }\n\n//        val delaunatorPoints = ArrayList<Point>()\n//        for (controlPoint in srcPoints) {\n//            delaunatorPoints.add(Point(controlPoint.x, controlPoint.y))\n//        }\n//\n//        delaunator = Delaunator(delaunatorPoints)\n//\n//        val triangles = delaunator.triangles\n//        for (triangle in triangles) {\n//            println(triangle)\n//        }\n\n    }\n\n    private var pointIdx = 0\n\n    val history = History()\n\n    fun addControlPoint(x: Float, y: Float, xDst: Float = x, yDst: Float = y) {\n\n        val newControlPoint = ControlPoint(this, x.toDouble(), y.toDouble(), pointIdx, ControlPointType.SRC)\n        newControlPoint.init(gloo)\n\n        val newDestPoint = ControlPoint(this, xDst.toDouble(), yDst.toDouble(), pointIdx, ControlPointType.DST)\n        newDestPoint.init(gloo)\n\n\n        srcPoints.add(newControlPoint)\n        destPoints.add(newDestPoint)\n\n        history.add(HistoryItem.Add(pointIdx, newControlPoint.x.toFloat(), newControlPoint.y.toFloat()))\n        pointIdx++\n\n        if (srcPoints.size < 3) return\n\n        val delaunatorPoints = ArrayList<Point>()\n        for (controlPoint in srcPoints) {\n            delaunatorPoints.add(Point(controlPoint.x, controlPoint.y))\n        }\n\n        delaunator = Delaunator(delaunatorPoints)\n\n    }\n\n    private val ray = Ray()\n\n    private val vecDragFrom = Vec3()\n    private val vecDragTo = Vec3()\n    private val vecTranslate = Vec3()\n\n    private val intersVec = Vec3()\n\n    private var dragStarted = false\n    private var dragStartX = 0.0f\n    private var dragStartY = 0.0f\n    private var scale = 1.0f\n\n    private val GRAB_MOUSE_BUTTON = UiEvent.MOUSE_BUTTON_MIDDLE\n    private val ADD_MOUSE_BUTTON = UiEvent.MOUSE_BUTTON_RIGHT\n\n    private val SCROLL_SENS = 0.03f\n\n    private val destCursorPos = Vec3()\n    private val srcCursorPos = Vec3()\n\n    private val viewport = Viewport(0, 0, 100, 100)\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n\n        if (input.justPressed(KEY_Z)) {\n            println(\"undo\")\n            val item = history.undo()\n            when (item) {\n                is HistoryItem.Add -> {\n\n                }\n\n                is HistoryItem.MoveSrc -> {\n                    val point = srcPoints.find { it.id == item.id }!!\n                    point.x = item.fromX.toDouble()\n                    point.y = item.fromY.toDouble()\n                }\n\n                is HistoryItem.MoveDst -> {\n                    val point = destPoints.find { it.id == item.id }!!\n                    point.x = item.fromX.toDouble()\n                    point.y = item.fromY.toDouble()\n                }\n\n                null -> {\n                    println(\"Undo actions empty\")\n                }\n            }\n        }\n\n        if (input.justPressed(KEY_D)) {\n            saveResult(\"/tmp/result.png\")\n        }\n\n        if (input.justPressed(KEY_S)) {\n            save()\n        }\n\n        if (input.justPressed(KEY_O)) {\n            load()\n        }\n\n        input.forEvents { event ->\n\n            if (event.type == UiEvent.SCROLL) {\n\n                val mat = if (event.x < viewport.w / 2) srcMat else destMat\n                val translateMat = if (event.x < viewport.w / 2) srcTranslateMat else destTranslateMat\n                val scaleMat = if (event.x < viewport.w / 2) srcScaleMat else destScaleMat\n\n                scale *= (1f + SCROLL_SENS * event.dy)\n                println(scale)\n                println(\"event ${event.dx} ${event.dy}\")\n                println(\"event.x = ${event.x}\")\n                println(\"event.y = ${event.y}\")\n\n                cam.rayThrough(ray, event.x, event.y)\n                intersVec.intersect(ray, plane, mat)\n\n                translateMat.setTranslate(-intersVec.x, -intersVec.y, -intersVec.z)\n                mat.setMult(translateMat, mat)\n\n                scaleMat.setScale(1f + SCROLL_SENS * event.dy)\n                mat.setMult(scaleMat, mat)\n\n                translateMat.setTranslate(+intersVec.x, +intersVec.y, +intersVec.z)\n                mat.setMult(translateMat, mat)\n            }\n\n            //adding control point\n            if (event.type == UiEvent.MOUSE_UP && event.button == ADD_MOUSE_BUTTON) {\n                val invMat = Mat4()\n                inversed(invMat, srcMat)\n//                cam.rayThrough(ray, event.x, event.y)\n                intersVec.intersect(ray, plane, srcMat)\n\n                val intersVecTransformed = Vec3()\n                intersVecTransformed.setMult(invMat, intersVec)\n\n                addControlPoint(intersVecTransformed.x, intersVecTransformed.y)\n            }\n\n            //start dest img grab/drag\n            if (event.type == UiEvent.MOUSE_DOWN && event.button == GRAB_MOUSE_BUTTON) {\n\n                if (event.x < viewport.w / 2) {\n                    dragStarted = true\n\n                    cam.rayThrough(ray, event.x, event.y)\n                    vecDragFrom.intersect(ray, plane, srcMat)\n\n                    dragStartX = event.x\n                    dragStartY = event.y\n                } else {\n                    dragStarted = true\n\n                    cam.rayThrough(ray, event.x, event.y)\n                    vecDragFrom.intersect(ray, plane, destMat)\n\n                    dragStartX = event.x\n                    dragStartY = event.y\n                }\n            }\n\n            //stop dest img grab/drag\n            if (event.type == UiEvent.MOUSE_UP && event.button == GRAB_MOUSE_BUTTON) {\n                dragStarted = false\n            }\n\n            //dest img grab/drag - moving\n            if (event.type == UiEvent.MOUSE_MOVE && dragStarted) {\n\n                if (event.x < viewport.w / 2) {\n                    cam.rayThrough(ray, event.x, event.y)\n                    vecDragTo.intersect(ray, plane, srcMat)\n\n                    vecTranslate.setDiff(vecDragTo, vecDragFrom)\n\n                    vecDragFrom.set(vecDragTo)\n                    println(\"vecTranslate = ${vecTranslate}\")\n\n                    srcTranslateMat.setTranslate(vecTranslate)\n\n                    //commit drag\n                    srcMat.setMult(srcTranslateMat, srcMat)\n                } else {\n                    cam.rayThrough(ray, event.x, event.y)\n                    vecDragTo.intersect(ray, plane, destMat)\n\n                    vecTranslate.setDiff(vecDragTo, vecDragFrom)\n\n                    vecDragFrom.set(vecDragTo)\n                    println(\"vecTranslate = ${vecTranslate}\")\n\n                    destTranslateMat.setTranslate(vecTranslate)\n\n                    //commit drag\n                    destMat.setMult(destTranslateMat, destMat)\n                }\n            }\n\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                cam.rayThrough(ray, event.x, event.y)\n\n                destCursorPos.intersect(ray, plane, destMat)\n                srcCursorPos.intersect(ray, plane, srcMat)\n            }\n\n            //handgling dropped files\n            if (event.type == UiEvent.FILE_DROPPED) {\n                println(\"dropped texture\")\n\n                if (!this::srcTexture.isInitialized) {\n                    srcTexture = gloo.createTexture2D(event.droppedImage!!)\n                    println(\"srcTexture ${srcTexture.width}x${srcTexture.height}\")\n                } else {\n                    destTexture = gloo.createTexture2D(event.droppedImage!!)\n                    println(\"dstTexture ${srcTexture.width}x${srcTexture.height}\")\n                }\n            }\n        }\n\n        if (input.justPressed(KEY_Q)) {\n            warpedColor.a += 0.1f\n            warpedColor.a = warpedColor.a.coerceIn(0.0f, 1.0f)\n        }\n\n        if (input.justPressed(KEY_W)) {\n            warpedColor.a -= 0.1f\n            warpedColor.a = warpedColor.a.coerceIn(0.0f, 1.0f)\n        }\n\n    }\n\n    private val destColor = Color(1f, 1f, 1f, 0.5f)\n    private val warpedColor = Color(1f, 1f, 1f, 0.5f)\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        this.viewport.copyFrom(viewport)\n//        cam.fitHeightCalcWidth(viewport, 1f)\n\n\n        cam.setScreenSize(viewport.w, viewport.h)\n        cam.fitW(-0.1f, 2.1f, 1f, 0f, 1.0f)\n\n//        println(\"viewport ${viewport}\")\n        gloo.gl.viewPort(0, 0, viewport.w, viewport.h)\n        gloo.gl.clearColor(COLOR_BLACK)\n        gloo.gl.clear()\n\n\n        gloo.gl.enable(GL_SCISSOR_TEST)\n\n\n        gloo.gl.scissor(0, viewport.y, viewport.w / 2, viewport.h)\n\n        //drawing src mesh\n        run {\n            im.clear()\n            val lineZ = 0.01f\n            val vertsCount = delaunator.triangles.size\n            for (i in 0 until vertsCount / 3) {\n                val v0 = delaunator.triangles[i * 3 + 0]\n                val v1 = delaunator.triangles[i * 3 + 1]\n                val v2 = delaunator.triangles[i * 3 + 2]\n\n                im.line(srcPoints[v0].x.toFloat(), srcPoints[v0].y.toFloat(), lineZ, srcPoints[v1].x.toFloat(), srcPoints[v1].y.toFloat(), lineZ)\n                im.line(srcPoints[v1].x.toFloat(), srcPoints[v1].y.toFloat(), lineZ, srcPoints[v2].x.toFloat(), srcPoints[v2].y.toFloat(), lineZ)\n                im.line(srcPoints[v2].x.toFloat(), srcPoints[v2].y.toFloat(), lineZ, srcPoints[v0].x.toFloat(), srcPoints[v0].y.toFloat(), lineZ)\n            }\n            im.renderColoredLines(cam, srcMat)\n        }\n\n\n        val imgZ = 0.0f\n\n        //src img background\n        if (this::srcTexture.isInitialized) {\n            val aspect = srcTexture.width.toFloat() / srcTexture.height.toFloat()\n\n            im.clear()\n\n            im.color(COLOR_WHITE)\n            im.texCoord(0f, 1f)\n            im.pos(-aspect, -1f, imgZ)\n\n            im.color(COLOR_WHITE)\n            im.texCoord(1f, 1f)\n            im.pos(aspect, -1f, imgZ)\n\n            im.color(COLOR_WHITE)\n            im.texCoord(1f, 0f)\n            im.pos(aspect, 1f, imgZ)\n\n            im.color(COLOR_WHITE)\n            im.texCoord(0f, 1f)\n            im.pos(-aspect, -1f, imgZ)\n\n            im.color(COLOR_WHITE)\n            im.texCoord(1f, 0f)\n            im.pos(aspect, 1f, imgZ)\n\n            im.color(COLOR_WHITE)\n            im.texCoord(0f, 0f)\n            im.pos(-aspect, 1f, imgZ)\n\n            im.renderTex(srcTexture, cam, srcMat)\n        }\n\n\n        gloo.gl.scissor(viewport.w / 2, viewport.y, viewport.w / 2, viewport.h)\n\n        //dest img background\n        destColor.a = 0.5f\n        if (this::destTexture.isInitialized) {\n\n            val aspect = destTexture.width.toFloat() / destTexture.height.toFloat()\n\n            im.clear()\n\n            im.color(destColor)\n            im.texCoord(0f, 1f)\n            im.pos(-aspect, -1f, imgZ)\n\n            im.color(destColor)\n            im.texCoord(1f, 1f)\n            im.pos(aspect, -1f, imgZ)\n\n            im.color(destColor)\n            im.texCoord(1f, 0f)\n            im.pos(aspect, 1f, imgZ)\n\n            im.color(destColor)\n            im.texCoord(0f, 1f)\n            im.pos(-aspect, -1f, imgZ)\n\n            im.color(destColor)\n            im.texCoord(1f, 0f)\n            im.pos(aspect, 1f, imgZ)\n\n            im.color(destColor)\n            im.texCoord(0f, 0f)\n            im.pos(-aspect, 1f, imgZ)\n\n            im.renderTex(destTexture, cam, destMat)\n        }\n\n        //drawing warped image\n        drawWarpedImage(cam, destMat, warpedColor)\n\n        val drawPlaneTriangle = false\n        if (drawPlaneTriangle) {\n            im.clear()\n\n            val v1 = Vec3()\n            val v2 = Vec3()\n\n            v1.setSum(plane.origin, plane.a)\n            v2.setSum(plane.origin, plane.b)\n\n            im.line(plane.origin, v1)\n            im.line(plane.origin, v2)\n            im.line(v1, v2)\n\n            im.renderColoredLines(cam, destMat)\n        }\n\n        im.clear()\n        val destCursorPosTransformed = Vec3()\n        val srcCursorPosTransformed = Vec3()\n\n        val invMat = Mat4()\n        inversed(invMat, destMat)\n\n        destCursorPosTransformed.setMult(invMat, destCursorPos)\n\n        inversed(invMat, srcMat)\n        srcCursorPosTransformed.setMult(invMat, srcCursorPos)\n\n        nearestDestControlPoint = destPoints.minBy {\n            sq(it.x.toFloat() - destCursorPosTransformed.x) + sq(it.y.toFloat() - destCursorPosTransformed.y)\n        }\n\n        nearestSrcControlPoint = srcPoints.minBy {\n            sq(it.x.toFloat() - srcCursorPosTransformed.x) + sq(it.y.toFloat() - srcCursorPosTransformed.y)\n        }\n\n//        im.pivot(destCursorPosTransformed)\n//        im.renderColoredLines(cam, destMat)\n\n        gloo.gl.disable(GL_SCISSOR_TEST)\n    }\n\n    private fun drawWarpedImage(cam: OrthoCamera, mat: Mat4, color: Color) {\n        run {\n            if (this::srcTexture.isInitialized) {\n                im.clear()\n\n                val vertsCount = delaunator.triangles.size\n\n                val tv0 = Vec3()\n                val tv1 = Vec3()\n                val tv2 = Vec3()\n\n                val p0 = Vec3()\n                val p1 = Vec3()\n                val p2 = Vec3()\n\n                val srcAspect = srcTexture.width.toFloat() / srcTexture.height.toFloat()\n\n                for (i in 0 until vertsCount / 3) {\n                    val i0 = delaunator.triangles[i * 3 + 0]\n                    val i1 = delaunator.triangles[i * 3 + 1]\n                    val i2 = delaunator.triangles[i * 3 + 2]\n\n                    // x:   map -aspect..aspect -> 0..1\n                    val x1 = srcPoints[i0].x.toFloat().linearMap(-srcAspect, srcAspect, 0f, 1f)\n                    val x2 = srcPoints[i1].x.toFloat().linearMap(-srcAspect, srcAspect, 0f, 1f)\n                    val x3 = srcPoints[i2].x.toFloat().linearMap(-srcAspect, srcAspect, 0f, 1f)\n\n                    // y:   map -1..1 -> 0..1\n                    val y1 = srcPoints[i0].y.toFloat().linearMap(-1f, 1f, 0f, 1f)\n                    val y2 = srcPoints[i1].y.toFloat().linearMap(-1f, 1f, 0f, 1f)\n                    val y3 = srcPoints[i2].y.toFloat().linearMap(-1f, 1f, 0f, 1f)\n\n                    tv0.set(x1, y1, 0.0f)\n                    tv1.set(x2, y2, 0.0f)\n                    tv2.set(x3, y3, 0.0f)\n\n                    p0.set(destPoints[i0].x.toFloat(), destPoints[i0].y.toFloat(), 0.1f)\n                    p1.set(destPoints[i1].x.toFloat(), destPoints[i1].y.toFloat(), 0.1f)\n                    p2.set(destPoints[i2].x.toFloat(), destPoints[i2].y.toFloat(), 0.1f)\n\n                    im.color(color)\n                    im.texCoord(tv0.x, 1f - tv0.y)\n                    im.pos(p0)\n\n                    im.color(color)\n                    im.texCoord(tv2.x, 1f - tv2.y)\n                    im.pos(p2)\n\n                    im.color(color)\n                    im.texCoord(tv1.x, 1f - tv1.y)\n                    im.pos(p1)\n                }\n\n                im.renderTex(srcTexture, cam, mat)\n            }\n        }\n    }\n\n    fun saveResult(filepath: String) {\n\n        println(\"Saving result...\")\n        val dstAspect = destTexture.width.toFloat() / destTexture.height.toFloat()\n\n        val h = 1024\n        val w = (h.toFloat() * dstAspect).toInt()\n\n        resCam.setScreenSize(w, h)\n        resCam.fit(-1f, 1f, -1f, 1f, 0f, 0f)\n\n        val fb = gloo.createFramebuffer()\n\n\n        val frameTexture = Texture2D(gloo.gl, gloo.gl.createTexture(), w, h)\n        frameTexture.bind(0)\n        frameTexture.createData()\n\n        fb.bind()\n        fb.setTexture(frameTexture)\n        println(\"fb.checkComplete() = ${fb.checkStatus()}\")\n\n        gloo.gl.viewPort(0, 0, w, h)\n        gloo.gl.clearColor(0f, 0f, 0f, 1.0f)\n        gloo.gl.clear()\n\n        drawWarpedImage(resCam, Mat4.IDENT, COLOR_WHITE)\n        gloo.gl.screenshot(filepath)\n\n        fb.unbind()\n        println(\"Saving result finished\")\n    }\n\n    fun save() {\n        require(srcPoints.size == destPoints.size)\n\n        val json = Json {\n            prettyPrint = true\n        }\n        val data = WrpFormat()\n//\n        srcMat.data.copyInto(data.srcMat)\n        destMat.data.copyInto(data.dstMat)\n//\n        for (i in srcPoints.indices) {\n            data.srcPoints.add(floatArrayOf(srcPoints[i].x.toFloat(), srcPoints[i].y.toFloat()))\n            data.dstPoints.add(floatArrayOf(destPoints[i].x.toFloat(), destPoints[i].y.toFloat()))\n        }\n//        data.srcImgPath = srcImgPath\n//        data.dstImgPath = dstImgPath\n\n        saveFile(json.encodeToString(data), \"/tmp/warp.txt\")\n    }\n\n    @OptIn(ExperimentalSerializationApi::class)\n    fun load() {\n\n//        childs.removeAll { it is ControlPoint }\n//\n//        val filePath = \"/tmp/warp.wrp\"\n//        try {\n//            val data = FileInputStream(filePath).buffered().use { stream ->\n//                Json.decodeFromStream<WrpFormat>(stream)\n//            }\n//\n//            require(data.srcPoints.size == data.dstPoints.size)\n//\n//            data.srcMat.copyInto(srcMat.data)\n//            data.dstMat.copyInto(destMat.data)\n//\n//            srcPoints.clear()\n//            destPoints.clear()\n//\n//            for (i in data.srcPoints.indices) {\n//                addControlPoint(data.srcPoints[i][0], data.srcPoints[i][1], data.dstPoints[i][0], data.dstPoints[i][1])\n//            }\n//        } catch (t: Throwable) {\n//            System.err.println(\"Failed to load ${filePath}\")\n//            t.printStackTrace()\n//        }\n    }\n}","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.max(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.max(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.min(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.min(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.convertToSetForSetOperation()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.convertToSetForSetOperation()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    @Suppress(\"DEPRECATION\")\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@Deprecated(\"Use sortWith instead\", ReplaceWith(\"this.sortWith(Comparator(comparison))\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n",null,null,"package sw.warper\n\nimport kmptemplate.color.COLOR_CYAN\nimport kmptemplate.color.COLOR_GRAY\nimport kmptemplate.color.COLOR_GREEN\nimport kmptemplate.color.COLOR_LIGHT_BLUE\nimport kmptemplate.color.COLOR_LIGHT_GREEN\nimport kmptemplate.color.COLOR_LIGHT_RED\nimport kmptemplate.color.COLOR_MAGENTA\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.color.COLOR_YELLOW\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.primitives.Sphere\nimport kmptemplate.gloo.primitives.intersect\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.inversed\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.math.setMult\nimport kmptemplate.math.setMultFree\nimport kmptemplate.ui.UiEvent\n\n\nenum class ControlPointType {\n    SRC, DST\n}\n\nclass ControlPoint(val editor: WarperEditor, var x: Double, var y: Double, val idx: Int, val type: ControlPointType) : Entity(parent = editor) {\n\n    companion object {\n        val COLORS = arrayOf(COLOR_YELLOW, COLOR_CYAN, COLOR_GREEN, COLOR_GRAY, COLOR_MAGENTA, COLOR_LIGHT_RED, COLOR_LIGHT_BLUE, COLOR_LIGHT_GREEN)\n        var nextColorIdx = 0\n    }\n\n    private lateinit var gloo: GLOO\n\n    private lateinit var im: ImmediateMode\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n\n        color.set(COLORS[idx % COLORS.size])\n    }\n\n    private val ray = Ray()\n    private val sphere = Sphere()\n    private val intersVec = Vec3()\n\n    private val color = Color(COLOR_YELLOW)\n    private var hovered = false\n\n    private var mouseDown = false\n\n    private val SZ = 0.03f\n\n    private var fromX = 0.0\n    private var fromY = 0.0\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n\n        input.forEvents { event ->\n\n            sphere.r = SZ\n            sphere.pos.set(x.toFloat(), y.toFloat(), 0.0f)\n\n            val mat = when (type) {\n                ControlPointType.SRC -> editor.srcMat\n                ControlPointType.DST -> editor.destMat\n            }\n\n            if (event.type == UiEvent.MOUSE_DOWN) {\n\n                if (this == editor.nearestDestControlPoint || this == editor.nearestSrcControlPoint) {\n                    editor.cam.rayThrough(ray, event.x, event.y)\n\n                    intersVec.intersect(ray, sphere, mat)\n                    if (intersVec.isNotNaN()) {\n                        fromX = x\n                        fromY = y\n                        mouseDown = true\n                    }\n                }\n            }\n\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                editor.cam.rayThrough(ray, event.x, event.y)\n\n                if (mouseDown) {\n                    val invMat = Mat4()\n                    inversed(invMat, mat)\n\n                    intersVec.intersect(ray, editor.plane, mat)\n\n                    val intersVecTransformed = Vec3()\n                    intersVecTransformed.setMult(invMat, intersVec)\n\n                    x = intersVecTransformed.x.toDouble()\n                    y = intersVecTransformed.y.toDouble()\n                }\n            }\n\n            if (event.type == UiEvent.MOUSE_UP) {\n\n                if (mouseDown) {\n                    val invMat = Mat4()\n                    inversed(invMat, mat)\n\n                    intersVec.intersect(ray, editor.plane, mat)\n\n                    val intersVecTransformed = Vec3()\n                    intersVecTransformed.setMult(invMat, intersVec)\n\n                    x = intersVecTransformed.x.toDouble()\n                    y = intersVecTransformed.y.toDouble()\n\n                    if (type == ControlPointType.DST) {\n                        editor.history.add(HistoryItem.MoveDst(id, fromX.toFloat(), fromY.toFloat(), x.toFloat(), y.toFloat()))\n                    }\n\n                    if (type == ControlPointType.SRC) {\n                        editor.history.add(HistoryItem.MoveSrc(id, fromX.toFloat(), fromY.toFloat(), x.toFloat(), y.toFloat()))\n                    }\n\n                }\n\n                mouseDown = false\n            }\n        }\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        im.clear()\n\n        val mat = when (type) {\n            ControlPointType.SRC -> editor.srcMat\n            ControlPointType.DST -> editor.destMat\n        }\n\n        val scaledSz = run {\n            val v = Vec3(SZ, 0f, 0f)\n            val invMat = Mat4()\n            inversed(invMat, mat)\n            v.setMultFree(invMat, v)\n            v.norm()\n        }\n\n\n        val pivotZ = 0.2f\n\n        im.color.set(if (hovered) COLOR_RED else color)\n\n        if (this == editor.nearestDestControlPoint || this == editor.nearestSrcControlPoint) {\n            im.pivot(x.toFloat(), y.toFloat(), pivotZ, sz = scaledSz)\n            im.diamond(x.toFloat(), y.toFloat(), pivotZ, sz = scaledSz)\n        } else {\n            im.pivot(x.toFloat(), y.toFloat(), pivotZ, sz = scaledSz)\n        }\n\n        im.renderColoredLines(editor.cam, mat)\n    }\n}","package sw.warper\n\n\nsealed class HistoryItem {\n    data class MoveSrc(val id: Int, val fromX: Float, val fromY: Float, val toX: Float, val toY: Float) : HistoryItem()\n\n    data class MoveDst(val id: Int, val fromX: Float, val fromY: Float, val toX: Float, val toY: Float) : HistoryItem()\n\n    data class Add(val id: Int, val x: Float, val y: Float) : HistoryItem()\n}\n\nclass History {\n    private val items = ArrayDeque<HistoryItem>()\n\n    fun add(item: HistoryItem) {\n        items.addLast(item)\n\n        println(\"HISTORY {\")\n        println(items.joinToString(\"\\n\"))\n        println(\"}\")\n    }\n\n    fun undo(): HistoryItem? {\n        return items.removeLastOrNull()\n    }\n\n    fun redo() {\n        TODO()\n    }\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package sw.warper\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\nclass WrpFormat {\n    val srcPoints = ArrayList<FloatArray>()\n    val dstPoints = ArrayList<FloatArray>()\n\n    val srcMat = FloatArray(16)\n    val dstMat = FloatArray(16)\n\n    var srcImgPath: String? = null\n    var dstImgPath: String? = null\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.gloo.FloatBuffer3\nimport kotlin.math.sqrt\n\nclass Vec3(x: Float, y: Float, z: Float) {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    constructor() : this(0f, 0f, 0f)\n\n    constructor(v: Vec3) : this(v.x, v.y, v.z)\n\n    val data = FloatArray(3)\n\n    var x: Float\n        get() = this.data[0]\n        set(v) {\n            this.data[0] = v\n        }\n\n    var y: Float\n        get() = this.data[1]\n        set(v) {\n            this.data[1] = v\n        }\n\n    var z: Float\n        get() = this.data[2]\n        set(v) {\n            this.data[2] = v\n        }\n\n    init {\n        this.x = x\n        this.y = y\n        this.z = z\n    }\n\n    fun norm(): Float = sqrt(x * x + y * y + z * z)\n\n    fun normSq(): Float = x * x + y * y + z * z\n\n    fun normalize() {\n        val norm = norm()\n        x /= norm\n        y /= norm\n        z /= norm\n    }\n\n    operator fun plusAssign(v: Vec3) {\n        x += v.x\n        y += v.y\n        z += v.z\n    }\n\n    operator fun minusAssign(v: Vec3) {\n        x -= v.x\n        y -= v.y\n        z -= v.z\n    }\n\n    operator fun timesAssign(a: Float) {\n        x *= a\n        y *= a\n        z *= a\n    }\n\n    inline fun setCross(a: Vec3, b: Vec3) {\n        //i  j k\n        //ax ay az\n        //bx by bz\n        require(this !== a)\n        require(this !== b)\n        x = a.y * b.z - a.z * b.y\n        y = a.z * b.x - a.x * b.z\n        z = a.x * b.y - a.y * b.x\n    }\n\n    override fun toString(): String {\n        return \"Vec3(${data[0]}, ${data[1]}, ${data[2]})\"\n    }\n\n    fun assign(v: Vec3) {\n        x = v.x\n        y = v.y\n        z = v.z\n    }\n\n    fun toVec4(): Vec4 {\n        return Vec4(x, y, z, 1.0f)\n    }\n\n    fun toVec4Free(): Vec4 {\n        return Vec4(x, y, z, 0.0f)\n    }\n\n    operator fun get(i: Int): Float {\n        return data[i]\n    }\n\n    fun set(v: Vec3) {\n        set(v.x, v.y, v.z)\n    }\n\n    fun set(x: Float, y: Float, z: Float) {\n        this.x = x\n        this.y = y\n        this.z = z\n    }\n\n    operator fun set(i: Int, value: Float) {\n        data[i] = value\n    }\n\n    fun setZero() {\n        set(0f, 0f, 0f)\n    }\n\n    fun setNormalizedDiff(a: Vec3, b: Vec3) {\n        val invD = 1f / dist(a, b)\n        this[0] = (a[0] - b[0]) * invD\n        this[1] = (a[1] - b[1]) * invD\n        this[2] = (a[2] - b[2]) * invD\n    }\n\n    inline fun setDiff(a: Vec3, b: Vec3) {\n        this[0] = a[0] - b[0]\n        this[1] = a[1] - b[1]\n        this[2] = a[2] - b[2]\n    }\n\n    inline fun setSum(a: Vec3, b: Vec3) {\n        this[0] = a[0] + b[0]\n        this[1] = a[1] + b[1]\n        this[2] = a[2] + b[2]\n    }\n\n    fun add(v: Vec3) {\n        this[0] += v[0]\n        this[1] += v[1]\n        this[2] += v[2]\n    }\n\n    fun addMult(a: Float, v: Vec3) {\n        this[0] += a * v[0]\n        this[1] += a * v[1]\n        this[2] += a * v[2]\n    }\n\n    fun setMult(a: Float, v: Vec3) {\n        this[0] = a * v[0]\n        this[1] = a * v[1]\n        this[2] = a * v[2]\n    }\n}\n\nfun dot(a: Vec3, b: Vec3) = a.x * b.x + a.y * b.y + a.z * b.z\n\nfun cos(a: Vec3, b: Vec3) = dot(a, b) / (a.norm() * b.norm())\n\n\nfun distSq(a: Vec3, b: Vec3): Float {\n    return sq(a[0] - b[0]) + sq(a[1] - b[1]) + sq(a[2] - b[2])\n}\n\nfun dist(a: Vec3, b: Vec3): Float {\n    return sqrt(sq(a[0] - b[0]) + sq(a[1] - b[1]) + sq(a[2] - b[2]))\n}\n\nfun Vec3.set(fb: FloatBuffer3, i: Int) {\n    set(fb[3 * i + 0], fb[3 * i + 1], fb[3 * i + 2])\n}\n\n\nfun Vec3.setNaN() {\n    set(Float.NaN, Float.NaN, Float.NaN)\n}\n\nfun Vec3.isNaN() = x.isNaN() || y.isNaN() || z.isNaN()\nfun Vec3.isNotNaN() = !isNaN()\n","package kmptemplate.math\n\nimport kotlin.math.cos\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sin\n\nconst val F_PI = 3.1415927f\nconst val F_2PI = 6.2831855f\nconst val F_PI_DIV2 = 1.5707964f\n\nfun clamp(t: Float, a: Float, b: Float): Float {\n    val min = min(a, b)\n    val max = max(a, b)\n\n    return if (t < min) min\n    else if (t > max) max\n    else t\n}\n\nfun smoothStep(t: Float, edge0: Float, edge1: Float): Float {\n    val x = clamp((t - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n    return x * x * (3f - 2f * x);\n}\n\nfun smoothStep(t: Float, t1: Float, v1: Float, t2: Float, v2: Float): Float {\n    val x = clamp((t - t1) / (t2 - t1), 0.0f, 1.0f)\n    val q = x * x * (3f - 2f * x)\n    return v1 + (v2 - v1) * q\n}\n\nfun sqPeak(t: Float) = max(0f, 1f - sq(t - 1f))\n\nfun sqPeak(t: Float, t0: Float, w: Float, a: Float) = a * sqPeak((t - t0) * 2.0f / w)\n\nfun sq(t: Float) = t * t\n\nfun qd(t: Float) = sq(sq(t))\n\nfun degToRad(deg: Float) = deg * F_PI / 180f\n\nfun sn(t: Double): Double {\n    return 0.5 * sin(t) + 0.5\n}\n\nfun cs(t: Double): Double {\n    return 0.5 * cos(t) + 0.5\n}\n\nfun cs(t: Float): Float {\n    return 0.5f * cos(t) + 0.5f\n}\n\nfun sn(t: Float): Float {\n    return 0.5f * sin(t) + 0.5f\n}\n\n\nfun frac(t: Double): Double {\n    return t % 1.0\n}\n\nfun frac(t: Float): Float {\n    return t % 1f\n}\n\ninline fun Float.linearMap(from1: Float, from2: Float, to1: Float, to2: Float): Float {\n    return to1 + (to2 - to1) * (this - from1) / (from2 - from1)\n}",null,"package sw.warper\n\nimport kmptemplate.entities.YaGamesJsPlayer\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\n\nfun warperMain() = GlobalScope.launch {\n    val player = YaGamesJsPlayer(\n        yaMetricaId = \"89962603\",\n        leaderBoardName = \"MainLeaderBoardV2\"\n    )\n\n    val entity = WarperEditor()\n\n    player.start(entity)\n}","package kmptemplate\n\nclass MutableInt(var value: Int = 0)\n\nclass PerformanceTracker {\n\n    var allocsCount = 0\n    var raytrace = 0\n\n    var drawCallsCount = 0\n    var drawVertsCount = 0\n\n    var glBufUploads = 0\n    var glBufUploadBytes = 0L\n\n    var tagToCount = HashMap<String, MutableInt>()\n\n    fun trackVec() {\n        allocsCount++\n    }\n\n    fun trackRayTrace() {\n        raytrace++\n    }\n\n    fun trackDrawCall(vertsCount: Int) {\n        drawCallsCount++\n        drawVertsCount += vertsCount\n    }\n\n    fun trackGLbufferData(bytesCount: Int) {\n        glBufUploads++\n        glBufUploadBytes += bytesCount\n    }\n\n    fun track(tag: String) {\n        tagToCount.getOrPut(tag) { MutableInt(0) }.value++\n    }\n\n    fun tagsInfo(): String = tagToCount.entries\n        .joinToString(separator = \"\\n\") { \"${it.key}: ${it.value.value}\" }\n\n    fun clear() {\n        allocsCount = 0\n        raytrace = 0\n\n        drawCallsCount = 0\n        drawVertsCount = 0\n\n        glBufUploads = 0\n        glBufUploadBytes = 0L\n\n        for (count in tagToCount.values) {\n            count.value = 0\n        }\n    }\n\n    fun trackUiEvent() {\n        allocsCount++\n    }\n}\n\nval PERF_TRACKER = PerformanceTracker()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","package kmptemplate.asteroids\n\nimport kmptemplate.asteroids.entities.RaceWorldEntity\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.KEY_H\nimport kmptemplate.input.KEY_I\nimport kmptemplate.input.KEY_J\nimport kmptemplate.input.KEY_K\nimport kmptemplate.input.KEY_L\nimport kmptemplate.input.KEY_Y\nimport kmptemplate.input.Keyboard\nimport kmptemplate.sound.SoundBuffer\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.time.currentTimeSeconds\nimport kmptemplate.ui.Text\nimport kotlin.random.Random\n\nval MAP_SZ = 30f\nval CELL_SZ = 50f\nval CELL_H = 10f\nval ROAD_W = 8f * 2f //about ten times car size\nval ROAD_HLFW = ROAD_W / 2\nval ROAD_H = 0.55f\nval CURB_W = 0.5f\nval CURB_H = 0.5f\n\nclass GridSampleRender(val gl: GL, val kb: Keyboard, val soundMan: SoundManager) {\n\n    val gloo = GLOO(gl)\n\n    private var startTime = 0.0\n\n    private lateinit var raceTimerText: Text\n\n\n    private lateinit var mouseTexture: Texture2D\n\n    private var width: Int = 1\n    private var height: Int = 1\n    fun onSizeChanged(width: Int, height: Int) {\n        gl.viewPort(0, 0, width, height)\n        this.width = width\n        this.height = height\n    }\n\n    val CONTROL_CAM_LEFT = KEY_J\n    val CONTROL_CAM_RIGHT = KEY_L\n    val CONTROL_CAM_FWD = KEY_I\n    val CONTROL_CAM_BACK = KEY_K\n    val CONTROL_CAM_UP = KEY_Y\n    val CONTROL_CAM_DOWN = KEY_H\n\n    lateinit var uiIm: ImmediateMode\n    lateinit var mitrFont: SdfFont\n\n    val rnd = Random(100500200600L)\n\n    private var raceStartTime = 0.0\n\n    private var raceFinishTime = 0.0\n\n    lateinit var worldEntity: RaceWorldEntity\n\n    lateinit var pulse: SoundBuffer\n\n    suspend fun init() {\n\n        gl.enable(GL.GL_DEPTH_TEST)\n\n        gl.enable(GL.GL_CULL_FACE)\n        gl.cullFace(GL.GL_BACK)\n\n        gl.enable(GL.GL_BLEND)\n        gl.blendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA)\n\n        uiIm = ImmediateMode(gloo)\n\n        mitrFont = SdfFont(gloo, gloo.createTexture2D(\"fonts/mitr.fnt.png\"))\n\n        raceTimerText = Text(\" \", mitrFont, 0.0f, 0.9f, 0.1f)\n\n        worldEntity = RaceWorldEntity(mitrFont)\n        worldEntity.initHierarchy(gloo)\n\n        worldEntity.carEntity.reset()\n\n        mouseTexture = gloo.createTexture2D(\"mouse.png\")\n        mouseTexture.bind(0)\n\n//        pulse = soundMan.loadSoundBuf(\"sounds/pulse_s8.raw\")\n        pulse = soundMan.loadSoundBuf(\"sounds/pulse.wav\")\n\n        startTime = currentTimeSeconds()\n    }\n\n    val uiCam = PlainCamera()\n\n    fun render() {\n        kb.pollMouse()\n\n        val dt = 1.0 / 60.0\n\n        val currentTimeSeconds = currentTimeSeconds()\n        val t = (currentTimeSeconds - startTime)\n\n        worldEntity.updateHierarchy(dt, t, kb)\n\n        gl.clearColor(0f, 0f, 0.2f, 1f)\n        gl.clear()\n\n        if (kb.mouseJustPressed(0)) {\n            val coords = kb.mouseCoords()\n            val x = 2f * coords.first.toFloat() / width - 1f\n            val y = 1f - 2f * coords.second.toFloat() / height\n            println(\"mouse pressed coords ${x} ${y}\")\n        }\n\n        if (kb.mouseJustPressed(0)) {\n            val (mx, my) = kb.mouseCoords()\n            val x = 2f * mx.toFloat() / width - 1f\n            val y = 1f - 2f * my.toFloat() / height\n\n            for (btn in worldEntity.menu.allBtns) {\n                btn.handleMouse(x, y)\n            }\n        }\n\n        if (kb.mouseJustPressed(0)) {\n            soundMan.play(pulse)\n            println(\"playing pulse\")\n        }\n\n\n        worldEntity.renderHierarchy(Viewport.FAKE_VIEWPORT, worldEntity.camEntity.cam, uiCam)\n\n        worldEntity.carEntity.prevCarPos.set(worldEntity.carEntity.car.pos)\n    }\n\n}","package kmptemplate.asteroids.entities\n\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\n\nclass RaceTimerEntity(val world: RaceWorldEntity, val font: SdfFont) : Entity(world) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var textIm: ImmediateMode\n\n    private var startTime = 0.0\n    private var time = 0.0\n    private var finishTime = 0.0\n    private var stopped = false\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        textIm = ImmediateMode(gloo)\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        if (!stopped) {\n            this.time = t\n        }\n    }\n\n    override fun render(viewport: Viewport, cam: Camera, uiCam: PlainCamera) {\n        val t = (time - startTime).toFloat()\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n        val hundreds = (t * 100.0).toLong() % 100L\n        var formatHundreds = hundreds.toString()\n        while (formatHundreds.length < 2) {\n            formatHundreds = '0' + formatHundreds\n        }\n\n        val seconds = t.toInt()\n        val formattedTime = \"${seconds}.${formatHundreds}\"\n\n        textIm.clear()\n        textIm.renderText(formattedTime, font, 0f, 0.9f, 0.1f, COLOR_WHITE, uiCam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n    fun reset(t: Double) {\n        stopped = false\n        startTime = t\n    }\n\n    fun stop(t: Double) {\n        stopped = true\n        finishTime = t\n    }\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\ninternal fun requireNonNegativeLimit(limit: Int) =\n    require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    requireNonNegativeLimit(limit)\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence to a list of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n * @sample samples.text.Strings.splitToSequence\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.splitToSequence(regex: Regex, limit: Int = 0): Sequence<String> = regex.splitToSequence(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.max(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.min(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","package kmptemplate.gloo.immediate\n\nimport kmptemplate.color.COLOR_BLUE\nimport kmptemplate.color.COLOR_GREEN\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.color.Color\nimport kmptemplate.gloo.Buffer\nimport kmptemplate.gloo.Cam\nimport kmptemplate.gloo.FloatBuffer2\nimport kmptemplate.gloo.FloatBuffer3\nimport kmptemplate.gloo.FloatBuffer4\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GL.Companion.GL_DEPTH_TEST\nimport kmptemplate.gloo.GL.Companion.GL_LINES\nimport kmptemplate.gloo.GL.Companion.GL_TRIANGLES\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.fonts.SdfFontShader\nimport kmptemplate.gloo.fonts.calcHeight\nimport kmptemplate.gloo.fonts.calcWidth\nimport kmptemplate.gloo.primitives.Mesh\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Vec3\nimport kotlin.math.absoluteValue\nimport kotlin.random.Random\n\nclass LightingShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        varying vec3 vPos;\n        \n        attribute vec3 aNormal;\n        varying vec3 vNormal;\n        \n        attribute vec4 aColor;\n        varying vec4 vColor;\n       \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            vNormal = (uModel * vec4(aNormal,0.0)).xyz;\n            vPos = (uModel * vec4(aPos,1.0)).xyz;\n            gl_Position =  uProj * uView * uModel * vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        varying vec3 vPos;\n        varying vec4 vColor;\n        varying vec3 vNormal;\n\n        uniform vec3 uLightPos;\n        uniform vec4 uLightColor;\n        \n        void main() {\n            vec3 dirToLight = normalize(uLightPos - vPos);\n            vec3 tint = vColor.rgb * uLightColor.rgb * ( 0.2 + 0.8*max(dot(dirToLight, vNormal), 0.0));\n            gl_FragColor = vec4(tint, 1.0);\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val aNormal = prog.getAttrib3f(\"aNormal\")\n\n    val uLightPos = prog.getUniform3f(\"uLightPos\")\n    val uLightColor = prog.getUniform4f(\"uLightColor\")\n    val uModel = prog.getUniformMat4f(\"uModel\");\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: LightingShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\nclass ColoredShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        \n        attribute vec4 aColor;\n        varying vec4 vColor;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            gl_Position =  uProj * uView * uModel * vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        varying vec4 vColor;\n        \n        void main() {\n            gl_FragColor = vColor;\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: ColoredShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\nclass TexturedShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n                \n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n\n        attribute vec4 aColor;\n        varying vec4 vColor;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            vTexCoord = aTexCoord;\n            gl_Position =  uProj * uView * uModel* vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uTexture;\n        varying vec4 vColor;\n        varying vec2 vTexCoord;\n\n        void main() {\n            gl_FragColor = vColor * texture2D(uTexture, vTexCoord);\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val uTexture = prog.getUniformSampler2D(\"uTexture\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: TexturedShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\nclass TableShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        varying vec3 vPos;\n                \n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n\n        attribute vec4 aColor;\n        varying vec4 vColor;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            vTexCoord = aTexCoord;\n            vPos = aPos;\n            gl_Position =  uProj * uView * uModel* vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uTexture;\n        varying vec4 vColor;\n        varying vec2 vTexCoord;\n        varying vec3 vPos;\n        \n        float sq(vec2 v) {\n            return dot(v,v);    \n        }\n\n        void main() {\n            vec2 lightPos1 = vec2(-9.0, 0.1);\n            vec2 lightPos2 = vec2(-3.0, -0.2);\n            vec2 lightPos3 = vec2(3.0, 0.2);\n            vec2 lightPos4 = vec2(9.0, -0.1);\n            \n            float invScale = 1.0 / 64.0;\n            float invCount = 1.0 / 4.0; //count of light sources\n            float brightness = 2.4;\n            \n            float light = 0.0;\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos1));\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos2));\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos3));\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos4));\n            \n            vec4 envColor = vec4(0.0,0.0,0.0,1.0);\n        \n            gl_FragColor = mix(vColor * texture2D(uTexture, vTexCoord), envColor, 1.1 - light * brightness);\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val uTexture = prog.getUniformSampler2D(\"uTexture\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: TableShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\n\nclass CardShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        attribute vec4 aColor;\n                        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        varying vec3 vPos;\n        varying vec4 vColor;\n        \n        void main() {\n            vColor = aColor;\n            vPos = aPos;\n            gl_Position =  uProj * uView * uModel * vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform vec2 uOrigin;\n        uniform vec2 uSize;\n        uniform vec4 uShColor;\n        uniform float uCornerR;\n        uniform float uShadowSz;\n                \n        varying vec3 vPos;\n        varying vec4 vColor;\n        \n        const vec2 V0 = vec2(0.0);\n                \n        float box(vec2 p, vec2 sz, vec2 offset) {\n            vec2 q = p - offset;\n            vec2 d = abs(q) - sz;\n            \n            return length( max(V0,d)) + min(max(d.x,d.y) , 0.0);\n        }\n        \n        float sn(float t) {\n            return 0.5 + 0.5 * sin(t);\n        }\n\n        void main() {\n            float px = 0.05;\n       \n            float d = box(vPos.xy, uSize - vec2(uCornerR), uOrigin);\n            vec4 fgColor = vColor;\n            vec4 bgColor = vec4(0.5, 0.6, 0.7, 1.0);\n        \n            float c = 1.0 - smoothstep(uCornerR, uCornerR + 0.75*px, d);//foreground intensity\n            float s = 1.0 - smoothstep(uCornerR, uCornerR + uShadowSz, d);//shadow intensity\n            \n//            c = sn(d*10.0);\n            \n            gl_FragColor =  mix(mix(bgColor,uShColor, s), fgColor, c);\n            gl_FragColor.a = s;\n//            gl_FragColor =  vec4(c,c,c,1.0);\n//            gl_FragColor =  uShColor;\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uView = prog.getUniformMat4f(\"uView\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n\n    val uOrigin = prog.getUniform2f(\"uOrigin\");\n    val uSize = prog.getUniform2f(\"uSize\");\n    val uShadowColor = prog.getUniform4f(\"uShColor\")\n\n    val uCornerR = prog.getUniform1f(\"uCornerR\")\n    val uShadowSz = prog.getUniform1f(\"uShadowSz\")\n\n    inline fun use(code: CardShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\ntypealias Align = Int\n\nprivate var cachedColoredShader: ColoredShader? = null\nprivate var cachedLightingShader: LightingShader? = null\nprivate var cachedCardShader: CardShader? = null\nprivate var cachedTableShader: TableShader? = null\nprivate var cachedTexturedShader: TexturedShader? = null\nprivate var cachedSdfFontShader: SdfFontShader? = null\n\nclass ImmediateMode(val gloo: GLOO) {\n    private var changed: Boolean = true\n\n    val color = Color(1f, 1f, 1f, 1f)\n\n    val posFB = FloatBuffer3()\n    private val colorFB = FloatBuffer4()\n    private val texCoordFB = FloatBuffer2()\n    private val normalsFB = FloatBuffer3()\n\n    var linePosBuf: Buffer\n    var lineColorBuf: Buffer\n    var texCoordsBuf: Buffer\n    private var normalsBuf: Buffer\n\n    private val coloredShader: ColoredShader\n        get() {\n            if (cachedColoredShader == null) {\n                cachedColoredShader = ColoredShader(gloo)\n            }\n            return cachedColoredShader!!\n        }\n\n    private val lightingShader: LightingShader\n        get() {\n            if (cachedLightingShader == null) {\n                cachedLightingShader = LightingShader(gloo)\n            }\n            return cachedLightingShader!!\n        }\n    private val cardShader: CardShader\n        get() {\n            if (cachedCardShader == null) {\n                cachedCardShader = CardShader(gloo)\n            }\n            return cachedCardShader!!\n        }\n    public val tableShader: TableShader\n        get() {\n            if (cachedTableShader == null) {\n                cachedTableShader = TableShader(gloo)\n            }\n            return cachedTableShader!!\n        }\n\n    val texShader: TexturedShader\n        get() {\n            if (cachedTexturedShader == null) {\n                cachedTexturedShader = TexturedShader(gloo)\n            }\n            return cachedTexturedShader!!\n        }\n\n    private val sdfFontShader: SdfFontShader\n        get() {\n            if (cachedSdfFontShader == null) {\n                cachedSdfFontShader = SdfFontShader(gloo)\n            }\n            return cachedSdfFontShader!!\n        }\n\n    init {\n        linePosBuf = gloo.createBuffer()\n        lineColorBuf = gloo.createBuffer()\n        texCoordsBuf = gloo.createBuffer()\n        normalsBuf = gloo.createBuffer()\n    }\n\n    fun pos(x: Float, y: Float, z: Float) {\n        posFB.add(x, y, z)\n        changed = true\n    }\n\n    fun pos(v: Vec3) {\n        pos(v.x, v.y, v.z)\n    }\n\n    fun normal(x: Float, y: Float, z: Float) {\n        normalsFB.add(x, y, z)\n        changed = true\n    }\n\n    fun texCoord(x: Float, y: Float) {\n        texCoordFB.add(x, y)\n        changed = true\n    }\n\n    fun color(r: Float, g: Float, b: Float, a: Float) {\n        colorFB.add(r, g, b, a)\n        changed = true\n    }\n\n    fun color(c: Color) {\n        color(c.r, c.g, c.b, c.a)\n    }\n\n    fun line(x1: Float, y1: Float, z1: Float, x2: Float, y2: Float, z2: Float) {\n        posFB.add(x1, y1, z1)\n        colorFB.add(color)\n\n        posFB.add(x2, y2, z2)\n        colorFB.add(color)\n\n        changed = true\n    }\n\n    fun line(v1: Vec3, v2: Vec3) {\n        posFB.add(v1.x, v1.y, v1.z)\n        colorFB.add(color)\n\n        posFB.add(v2.x, v2.y, v2.z)\n        colorFB.add(color)\n\n        changed = true\n    }\n\n    fun pivot(x: Float, y: Float, z: Float, sz: Float = 0.01f) {\n        val hsz = sz / 2\n        line(x - hsz, y, z, x + hsz, y, z)\n        line(x, y - hsz, z, x, y + hsz, z)\n        line(x, y, z - hsz, x, y, z + hsz)\n    }\n\n    fun diamond(x: Float, y: Float, z: Float, sz: Float = 0.01f) {\n        val hsz = sz / 2\n        line(x - hsz, y, z, x, y + hsz, z)\n        line(x, y + hsz, z, x + hsz, y, z)\n        line(x + hsz, y, z, x, y - hsz, z)\n        line(x, y - hsz, z, x - hsz, y, z)\n    }\n\n    fun pivot(v: Vec3, sz: Float = 0.01f) {\n        pivot(v.x, v.y, v.z, sz)\n    }\n\n    fun cell(\n        x1: Float, y1: Float, z1: Float,\n        x2: Float, y2: Float, z2: Float\n    ) {\n        color.set(COLOR_RED)\n        line(x1, y1, z1, x2, y1, z1)\n        line(x1, y1, z2, x2, y1, z2)\n        line(x1, y2, z2, x2, y2, z2)\n        line(x1, y2, z1, x2, y2, z1)\n\n        color.set(COLOR_GREEN)\n        line(x1, y1, z1, x1, y2, z1)\n        line(x1, y1, z2, x1, y2, z2)\n        line(x2, y1, z2, x2, y2, z2)\n        line(x2, y1, z1, x2, y2, z1)\n\n        color.set(COLOR_BLUE)\n        line(x1, y1, z1, x1, y1, z2)\n        line(x1, y2, z1, x1, y2, z2)\n        line(x2, y2, z1, x2, y2, z2)\n        line(x2, y1, z1, x2, y1, z2)\n    }\n\n    fun arrow(\n        x1: Float, y1: Float, z1: Float,\n        x2: Float, y2: Float, z2: Float\n    ) {\n        line(x1, y1, z1, x2, y2, z2)\n        pivot(x2, y2, z2, sz = 0.2f)\n    }\n\n    fun prepareBuffers() {\n        linePosBuf.setData(posFB)\n        lineColorBuf.setData(colorFB)\n        texCoordsBuf.setData(texCoordFB)\n\n        changed = false\n    }\n\n    fun renderColoredLines(cam: Cam, modelMat: Mat4 = Mat4.IDENT) {\n        if (changed) {\n            prepareBuffers()\n        }\n\n        coloredShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n\n            gloo.gl.drawArrays(GL.GL_LINES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderColoredTriangles(cam: Cam) {\n        if (changed) {\n            prepareBuffers()\n        }\n\n        coloredShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderTex(tex: Texture2D, cam: Cam, modelMat: Mat4 = Mat4.IDENT) {\n        if (changed) {\n            prepareBuffers()\n        }\n\n        texShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            uTexture.set(tex)\n            aTexCoord.set(texCoordsBuf)\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    companion object {\n        val ALIGN_CENTER = 0\n\n        /** object will be located to the top of specified (x,y) coordinates */\n        val ALIGN_TOP = 1\n\n        /** object will be located to the bottom of specified (x,y) coordinates */\n        val ALIGN_BOTTOM = 2\n\n        /** object will be located to the left of specified (x,y) coordinates */\n        val ALIGN_LEFT = 3\n\n        /** object will be located to the right of specified (x,y) coordinates */\n        val ALIGN_RIGHT = 4\n    }\n\n    fun renderText(text: String, font: SdfFont, x0: Float, y0: Float, h: Float, color: Color, cam: Cam? = null, horAlign: Align = ALIGN_CENTER, verAlign: Align = ALIGN_CENTER, z: Float = 0f, weight: Float = 0.5f, edge: Float = 8f / 256f, compress: Float = 1.0f, outlineColor: Color? = null) {\n\n        var textVertsCount = 0\n\n\n        val textWidth = calcWidth(text, h, compress)\n        val textHeight = calcHeight(text, h)\n\n        val fixX = when (horAlign) {\n            ALIGN_RIGHT -> 0.0f\n            ALIGN_LEFT -> -textWidth\n            ALIGN_CENTER -> -textWidth / 2.0f\n            else -> throw IllegalArgumentException(\"Unknown text alignment\")\n        }\n\n        val fixY = when (verAlign) {\n            ALIGN_TOP -> textHeight - h\n            ALIGN_BOTTOM -> -h\n            ALIGN_CENTER -> textHeight / 2f - h\n            else -> throw IllegalArgumentException(\"Unknown text alignment\")\n        }\n\n        val screenX0 = x0 + fixX\n        val screenY0 = y0 + fixY\n\n        var screenX = screenX0\n        var screenY = screenY0\n\n        val screenW = h * 0.75f\n        val screenH = h\n\n        val dz = 0.00001f\n        var zz = z\n\n        for (ch in text) {\n\n            if (ch == '\\n') {\n                screenY -= screenH;\n                screenX = screenX0;\n                continue\n            }\n\n            val sdfChar = font.charmap.get(ch.code) ?: continue\n\n            val x = sdfChar.x / font.texture.width.toFloat()\n            val y = sdfChar.y / font.texture.height.toFloat()\n            val w = sdfChar.width / font.texture.width.toFloat()\n            val h = sdfChar.height / font.texture.height.toFloat()\n\n            texCoord(x, y + h);\n            texCoord(x + w, y + h);\n            texCoord(x + w, y);\n\n            texCoord(x + w, y);\n            texCoord(x, y);\n            texCoord(x, y + h);\n\n            pos(screenX, screenY, zz)\n            pos(screenX + screenW, screenY, zz)\n            pos(screenX + screenW, screenY + screenH, zz)\n\n            pos(screenX + screenW, screenY + screenH, zz)\n            pos(screenX, screenY + screenH, zz)\n            pos(screenX, screenY, zz)\n\n            zz += dz\n\n            textVertsCount += 6\n\n            screenX += screenW * compress\n        }\n\n        if (outlineColor != null) {\n            sdfFontShader.use {\n                //outline\n\n                sdfFontShader.uFontTexture.set(font.texture)\n                sdfFontShader.uColor.set(outlineColor)\n                sdfFontShader.uWeight.set(1.1f * weight)\n                sdfFontShader.uThreshold.set(edge)\n                sdfFontShader.aTexCoord.set(texCoordsBuf)\n                sdfFontShader.aCoord.set(linePosBuf)\n                sdfFontShader.uModel.set(Mat4.IDENT)\n                sdfFontShader.uView.set(cam?.viewMatrix ?: Mat4.IDENT)\n                sdfFontShader.uProj.set(cam?.projMatrix ?: Mat4.IDENT)\n\n                if (changed) {\n                    prepareBuffers()\n                }\n\n                gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n            }\n        }\n\n\n        sdfFontShader.use {\n            //glyph\n\n            sdfFontShader.uFontTexture.set(font.texture)\n            sdfFontShader.uColor.set(color.r, color.g, color.b, color.a)\n            sdfFontShader.uWeight.set(weight)\n            sdfFontShader.uThreshold.set(edge)\n            sdfFontShader.aTexCoord.set(texCoordsBuf)\n            sdfFontShader.aCoord.set(linePosBuf)\n            sdfFontShader.uModel.set(Mat4.IDENT)\n            sdfFontShader.uView.set(cam?.viewMatrix ?: Mat4.IDENT)\n            sdfFontShader.uProj.set(cam?.projMatrix ?: Mat4.IDENT)\n\n            if (changed) {\n                prepareBuffers()\n            }\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderWireframe(mesh: Mesh, cam: Cam, renderNormals: Boolean = false, modelMat: Mat4 = Mat4.IDENT) {\n        val NORM_COEFF = 0.15f\n\n        for (i in 0 until mesh.vertsCount / 3) {\n            val x0 = mesh.posBuf[9 * i + 0]\n            val y0 = mesh.posBuf[9 * i + 1]\n            val z0 = mesh.posBuf[9 * i + 2]\n\n            val x1 = mesh.posBuf[9 * i + 3]\n            val y1 = mesh.posBuf[9 * i + 4]\n            val z1 = mesh.posBuf[9 * i + 5]\n\n            val x2 = mesh.posBuf[9 * i + 6]\n            val y2 = mesh.posBuf[9 * i + 7]\n            val z2 = mesh.posBuf[9 * i + 8]\n\n            pos(x0, y0, z0)\n            pos(x1, y1, z1)\n\n            pos(x1, y1, z1)\n            pos(x2, y2, z2)\n\n            pos(x2, y2, z2)\n            pos(x0, y0, z0)\n\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n\n            if (renderNormals) {\n                val nx0 = mesh.normalsBuf[9 * i + 0]\n                val ny0 = mesh.normalsBuf[9 * i + 1]\n                val nz0 = mesh.normalsBuf[9 * i + 2]\n\n                val nx1 = mesh.normalsBuf[9 * i + 3]\n                val ny1 = mesh.normalsBuf[9 * i + 4]\n                val nz1 = mesh.normalsBuf[9 * i + 5]\n\n                val nx2 = mesh.normalsBuf[9 * i + 6]\n                val ny2 = mesh.normalsBuf[9 * i + 7]\n                val nz2 = mesh.normalsBuf[9 * i + 8]\n\n\n                pos(x0, y0, z0)\n                pos(x0 + NORM_COEFF * nx0, y0 + NORM_COEFF * ny0, z0 + NORM_COEFF * nz0)\n\n                pos(x1, y1, z1)\n                pos(x1 + NORM_COEFF * nx1, y1 + NORM_COEFF * ny1, z1 + NORM_COEFF * nz1)\n\n                pos(x2, y2, z2)\n                pos(x2 + NORM_COEFF * nx2, y2 + NORM_COEFF * ny2, z2 + NORM_COEFF * nz2)\n\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n            }\n        }\n\n\n\n\n\n        coloredShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            gloo.gl.drawArrays(GL_LINES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderRandomColoredTriangles(mesh: Mesh, cam: Cam, meshColor: Color? = null) {\n        val rnd = Random(100500L)\n        posFB.reset()\n        colorFB.reset()\n\n        for (i in 0 until mesh.vertsCount / 3) {\n            val x0 = mesh.posBuf[9 * i + 0]\n            val y0 = mesh.posBuf[9 * i + 1]\n            val z0 = mesh.posBuf[9 * i + 2]\n\n            val x1 = mesh.posBuf[9 * i + 3]\n            val y1 = mesh.posBuf[9 * i + 4]\n            val z1 = mesh.posBuf[9 * i + 5]\n\n            val x2 = mesh.posBuf[9 * i + 6]\n            val y2 = mesh.posBuf[9 * i + 7]\n            val z2 = mesh.posBuf[9 * i + 8]\n\n            pos(x0, y0, z0)\n            pos(x1, y1, z1)\n            pos(x1, y1, z1)\n            pos(x2, y2, z2)\n\n            if (meshColor == null) {\n                color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1.0f)\n                color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1.0f)\n                color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1.0f)\n            } else {\n                color(meshColor)\n                color(meshColor)\n                color(meshColor)\n            }\n        }\n\n\n        coloredShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderWithLighting(mesh: Mesh, cam: Cam, lightPos: Vec3, modelMat: Mat4 = Mat4.IDENT) {\n        for (i in 0 until mesh.vertsCount / 3) {\n            val x0 = mesh.posBuf[9 * i + 0]\n            val y0 = mesh.posBuf[9 * i + 1]\n            val z0 = mesh.posBuf[9 * i + 2]\n\n            val x1 = mesh.posBuf[9 * i + 3]\n            val y1 = mesh.posBuf[9 * i + 4]\n            val z1 = mesh.posBuf[9 * i + 5]\n\n            val x2 = mesh.posBuf[9 * i + 6]\n            val y2 = mesh.posBuf[9 * i + 7]\n            val z2 = mesh.posBuf[9 * i + 8]\n\n            pos(x0, y0, z0)\n            pos(x1, y1, z1)\n            pos(x2, y2, z2)\n\n            color(0.6f, 0.6f, 0.6f, 1.0f)\n            color(0.6f, 0.6f, 0.6f, 1.0f)\n            color(0.6f, 0.6f, 0.6f, 1.0f)\n\n            val nx0 = mesh.normalsBuf[9 * i + 0]\n            val ny0 = mesh.normalsBuf[9 * i + 1]\n            val nz0 = mesh.normalsBuf[9 * i + 2]\n\n            val nx1 = mesh.normalsBuf[9 * i + 3]\n            val ny1 = mesh.normalsBuf[9 * i + 4]\n            val nz1 = mesh.normalsBuf[9 * i + 5]\n\n            val nx2 = mesh.normalsBuf[9 * i + 6]\n            val ny2 = mesh.normalsBuf[9 * i + 7]\n            val nz2 = mesh.normalsBuf[9 * i + 8]\n\n            normal(nx0, ny0, nz0)\n            normal(nx1, ny1, nz1)\n            normal(nx2, ny2, nz2)\n        }\n\n\n        lightingShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n            normalsBuf.setData(normalsFB)\n\n            uLightColor.set(1f, 1f, 0.7f, 1f)\n            uLightPos.set(lightPos)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            aNormal.set(normalsBuf)\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderWithLightingOpt(mesh: Mesh, cam: Cam, lightPos: Vec3, modelMat: Mat4 = Mat4.IDENT) {\n        if (changed) {\n            for (i in 0 until mesh.vertsCount / 3) {\n                val x0 = mesh.posBuf[9 * i + 0]\n                val y0 = mesh.posBuf[9 * i + 1]\n                val z0 = mesh.posBuf[9 * i + 2]\n\n                val x1 = mesh.posBuf[9 * i + 3]\n                val y1 = mesh.posBuf[9 * i + 4]\n                val z1 = mesh.posBuf[9 * i + 5]\n\n                val x2 = mesh.posBuf[9 * i + 6]\n                val y2 = mesh.posBuf[9 * i + 7]\n                val z2 = mesh.posBuf[9 * i + 8]\n\n                pos(x0, y0, z0)\n                pos(x1, y1, z1)\n                pos(x2, y2, z2)\n\n                color(0.6f, 0.6f, 0.6f, 1.0f)\n                color(0.6f, 0.6f, 0.6f, 1.0f)\n                color(0.6f, 0.6f, 0.6f, 1.0f)\n\n                val nx0 = mesh.normalsBuf[9 * i + 0]\n                val ny0 = mesh.normalsBuf[9 * i + 1]\n                val nz0 = mesh.normalsBuf[9 * i + 2]\n\n                val nx1 = mesh.normalsBuf[9 * i + 3]\n                val ny1 = mesh.normalsBuf[9 * i + 4]\n                val nz1 = mesh.normalsBuf[9 * i + 5]\n\n                val nx2 = mesh.normalsBuf[9 * i + 6]\n                val ny2 = mesh.normalsBuf[9 * i + 7]\n                val nz2 = mesh.normalsBuf[9 * i + 8]\n\n                normal(nx0, ny0, nz0)\n                normal(nx1, ny1, nz1)\n                normal(nx2, ny2, nz2)\n            }\n        }\n\n        lightingShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n            normalsBuf.setData(normalsFB)\n\n            uLightColor.set(1f, 1f, 0.7f, 1f)\n            uLightPos.set(lightPos)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            aNormal.set(normalsBuf)\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n\n    fun clear() {\n        posFB.reset()\n        colorFB.reset()\n        texCoordFB.reset()\n        normalsFB.reset()\n        changed = true\n    }\n\n\n    fun enableDepthTest() {\n        gloo.gl.enable(GL_DEPTH_TEST)\n    }\n\n    fun disableDepthTest() {\n        gloo.gl.disable(GL_DEPTH_TEST)\n    }\n\n    fun renderCard(x1: Float, y1: Float, x2: Float, y2: Float, r: Float, color1: Color, color2: Color, cam: Cam) {\n        posFB.add(x1, y1, 0f)\n        posFB.add(x2, y1, 0f)\n        posFB.add(x2, y2, 0f)\n\n        posFB.add(x1, y1, 0f)\n        posFB.add(x2, y2, 0f)\n        posFB.add(x1, y2, 0f)\n\n        colorFB.add(color1)\n        colorFB.add(color2)\n        colorFB.add(color1)\n\n        colorFB.add(color1)\n        colorFB.add(color1)\n        colorFB.add(color2)\n\n        renderColoredTriangles(cam)\n    }\n\n    private val cardColor = Color(0.0f, 0.05f, 0.1f, 0.05f)\n\n    fun renderCardNew(x1: Float, y1: Float, x2: Float, y2: Float, r: Float, shadowSz: Float, color1: Color, color2: Color, cam: Cam) {\n        val rr = shadowSz\n\n        posFB.add(x1 - rr, y1 - rr, 0f)\n        posFB.add(x2 + rr, y1 - rr, 0f)\n        posFB.add(x2 + rr, y2 + rr, 0f)\n\n        posFB.add(x1 - rr, y1 - rr, 0f)\n        posFB.add(x2 + rr, y2 + rr, 0f)\n        posFB.add(x1 - rr, y2 + rr, 0f)\n\n        colorFB.add(color1)\n        colorFB.add(color2)\n        colorFB.add(color1)\n\n        colorFB.add(color1)\n        colorFB.add(color1)\n        colorFB.add(color2)\n\n        prepareBuffers()\n\n        cardShader.use {\n            uOrigin.set((x1 + x2) * 0.5f, (y1 + y2) * 0.5f)\n            uSize.set((x2 - x1).absoluteValue * 0.5f, (y2 - y1).absoluteValue * 0.5f)\n            uShadowColor.set(cardColor)\n\n            uCornerR.set(r)\n            uShadowSz.set(shadowSz)\n\n            uModel.set(Mat4.IDENT)\n            uView.set(cam.viewMatrix)\n            uProj.set(cam.projMatrix)\n\n            aColor.set(lineColorBuf)\n            aPos.set(linePosBuf)\n\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, 6)\n        }\n    }\n\n\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    @Suppress(\"DEPRECATION\")\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@Deprecated(\"Use sortWith instead\", ReplaceWith(\"this.sortWith(Comparator(comparison))\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","package kmptemplate.tetris\n\nimport kmptemplate.arrays.IntArr2D\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.COLOR_YELLOW\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.sound.SoundBuffer\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.tetris.Shape.Companion.COLORS\n\nclass CupEntity(val tetrisGame: TetrisGame, val soundMan: SoundManager, val pulse: SoundBuffer) : Entity(parent = tetrisGame) {\n\n    private lateinit var gloo: GLOO\n\n    private lateinit var gridIm: ImmediateMode\n    private lateinit var cellsIm: ImmediateMode\n\n    val width = 10\n    val height = 20\n\n    val cells = IntArr2D(width, height + 4)\n\n    val EMPTY = -1\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n\n        gridIm = ImmediateMode(gloo)\n        cellsIm = ImmediateMode(gloo)\n\n        gridIm.color.set(COLOR_YELLOW)\n\n        cells.data.fill(EMPTY)\n    }\n\n    private var t = 0.0\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        this.t = t\n    }\n\n    val blockColor = Color(0f, 0f, 0f, 1f)\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        gridIm.clear()\n        gridIm.color.set(COLOR_YELLOW)\n        for (ix in 0..width) {\n            gridIm.line(\n                ix.toFloat(), 0f, 0f,\n                ix.toFloat(), height.toFloat(), 0f\n            )\n        }\n\n        for (iy in 0..height) {\n            gridIm.line(\n                0f, iy.toFloat(), 0f,\n                width.toFloat(), iy.toFloat(), 0f\n            )\n        }\n\n        gridIm.renderColoredLines(tetrisGame.cam)\n\n\n        val WHITENING = 0.6f\n        cellsIm.clear()\n        for (ix in 0 until width) {\n            for (iy in 0 until height) {\n                if (cells[ix, iy] >= 0) {\n\n                    val shapeColor = COLORS[cells[ix, iy]]\n                    blockColor.r = shapeColor.r * (1f - WHITENING) + COLOR_WHITE.r * WHITENING\n                    blockColor.g = shapeColor.g * (1f - WHITENING) + COLOR_WHITE.g * WHITENING\n                    blockColor.b = shapeColor.b * (1f - WHITENING) + COLOR_WHITE.b * WHITENING\n\n                    cellsIm.renderBlock(ix.toFloat(), iy.toFloat(), blockColor)\n                }\n            }\n        }\n\n        cellsIm.renderColoredTriangles(tetrisGame.cam)\n    }\n\n    fun petrify(dropEntity: DropEntity) {\n\n        var petrified = false\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (dropEntity.shape.cells[ix, iy, dropEntity.orientation] == 1) {\n                    cells[dropEntity.x + ix, dropEntity.y + iy] = dropEntity.shape.color\n                    petrified = true\n                }\n            }\n        }\n\n        if (petrified) {\n\n            val clearedLinesCount = clearCheck()\n\n            val multiplier = 1f + tetrisGame.score.level * 0.1\n\n            if (clearedLinesCount > 0) {\n                val score = when (clearedLinesCount) {\n                    1 -> 100L\n                    2 -> 300L\n                    3 -> 500L\n                    4 -> 1000L\n                    else -> 2000L //may be for pentris\n                }\n                tetrisGame.score.addScore((score * multiplier).toLong())\n                tetrisGame.score.addLines(clearedLinesCount)\n                soundMan.play(tetrisGame.dropSound)\n                soundMan.play(tetrisGame.clearSound)\n            } else {\n                soundMan.play(tetrisGame.dropSound)\n            }\n        }\n\n        if (petrified) {\n            tetrisGame.boom.activate(t, dropEntity.x, dropEntity.y, dropEntity.orientation, dropEntity.shape)\n        }\n\n        for (ix in 0 until width) {\n            if (cells[ix, height - 1] >= 0) {\n                tetrisGame.gameOverState()\n                break\n            }\n        }\n    }\n\n\n    private val emptyLinesBefore = IntArray(height + 4)\n\n    fun clearCheck(): Int {\n        var iy = 0\n\n        //clear filled lines\n        var emptyLinesCount = 0\n        var countLinesCleared = 0\n        while (iy < height) {\n            var lineFilled = true\n            for (ix in 0 until width) {\n                lineFilled = lineFilled && cells[ix, iy] >= 0\n            }\n\n            emptyLinesBefore[iy] = emptyLinesCount\n\n            if (lineFilled) {\n                for (ix in 0 until width) {\n                    cells[ix, iy] = EMPTY\n                }\n                emptyLinesCount++\n                countLinesCleared++\n            }\n\n            iy++\n        }\n\n        //shift empty lines\n        if (countLinesCleared > 0) {\n            for (iy in 0 until height) {\n                if (emptyLinesBefore[iy] > 0) {\n                    for (ix in 0 until width) {\n                        cells[ix, iy - emptyLinesBefore[iy]] = cells[ix, iy]\n                    }\n                }\n            }\n\n            soundMan.play(tetrisGame.clearSound)\n        }\n\n        return countLinesCleared\n    }\n\n    fun reset() {\n        cells.data.fill(EMPTY)\n    }\n}\n\nfun ImmediateMode.renderBlock(ix: Float, iy: Float, color: Color, z: Float = 0.0f, a: Float = 1.0f, sz: Float = 1.0f) {\n\n    val cellsIm = this\n\n    val shapeColor = color\n\n    val hsz = 0.5f * sz\n\n    //top\n    run {\n        val coef = 1.0f\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n\n    //right\n    run {\n        val coef = 0.9f\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        //right\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n\n    //left\n    run {\n        val coef = 0.8f\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n\n    //bottom\n    run {\n        val coef = 0.7f\n\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n}\n","package kmptemplate.tetris\n\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.KEY_ARROW_DOWN\nimport kmptemplate.input.KEY_ARROW_LEFT\nimport kmptemplate.input.KEY_ARROW_RIGHT\nimport kmptemplate.input.KEY_ARROW_UP\nimport kmptemplate.input.KEY_Q\nimport kmptemplate.input.KEY_SPACE\nimport kmptemplate.input.Keyboard\nimport kmptemplate.tetris.Shape.Companion.COLORS\nimport kotlin.math.pow\n\nclass DropEntity(val tetrisGame: TetrisGame) : Entity(parent = tetrisGame) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var im: ImmediateMode\n\n    lateinit var shape: Shape\n\n    var x = 0\n    var y = 0\n    var orientation = 0\n\n    val showGhost = true\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n\n        im = ImmediateMode(gloo)\n\n        resetShape()\n    }\n\n    private var prevUpdateTime = 0.0\n    private var tickTime = 1.0\n\n\n    fun resetShape() {\n        shape = tetrisGame.nextShape.poll()\n        x = tetrisGame.cup.width / 2\n        y = tetrisGame.cup.height - shape.lastLine - 1\n\n        orientation = 0\n    }\n\n    private var inputLocked = false\n\n    var gameTime = 0.0\n\n    override fun update(dt: Double, clockTime: Double, input: Keyboard) {\n\n        if (tetrisGame.gameOverEntity.active) return\n\n        //https://harddrop.com/wiki/Tetris_Worlds\n        //Time = (0.8-((Level-1)*0.007))^(Level-1)\n\n        val level_m1 = tetrisGame.score.level - 1.0\n        tickTime = (0.8 - level_m1 * 0.007).pow(level_m1 - 1.0)\n\n        if (gameTime - prevUpdateTime > tickTime) {\n            prevUpdateTime = gameTime\n\n            if (canMoveDown()) {\n                y--\n            } else {\n                tetrisGame.cup.petrify(this)\n                inputLocked = true\n                resetShape()\n            }\n        }\n\n        if (input.justPressed(KEY_Q)) {\n            tetrisGame.switchPause()\n        }\n\n        if (!tetrisGame.pauseEntity.active) {\n            gameTime += dt\n        } else {\n            //do not handle input on pause\n            return\n        }\n\n        if (input.anyKeyJustPressed() || tetrisGame.touchUI.anyBtnJustPressed()) {\n            inputLocked = false\n        }\n\n        if (!inputLocked) {\n\n            if (input.justPressed(KEY_ARROW_UP) || tetrisGame.touchUI.rotateBtn.justPressed()) {\n                if (canRotate(+1)) {\n                    orientation++\n                    orientation %= 4\n                    tetrisGame.soundManager.play(tetrisGame.rotateSound)\n                }\n            }\n\n\n            if (input.justPressed(KEY_ARROW_LEFT) || tetrisGame.touchUI.leftBtn.justPressed()) {\n                if (canMoveLeft()) {\n                    x--\n                    tetrisGame.soundManager.play(tetrisGame.moveSounnd)\n                }\n            }\n            if (input.justPressed(KEY_ARROW_RIGHT) || tetrisGame.touchUI.rightBtn.justPressed()) {\n                if (canMoveRight()) {\n                    x++\n                    tetrisGame.soundManager.play(tetrisGame.moveSounnd)\n                }\n            }\n\n            if (input.pressed(KEY_ARROW_DOWN) || input.pressed(KEY_SPACE) || tetrisGame.touchUI.downBtn.pressed()) {\n                //TODO remove code duplication upper\n                if (canMoveDown()) {\n                    y--\n                    tetrisGame.score.addScore(1)\n                } else {\n                    tetrisGame.cup.petrify(this)\n                    inputLocked = true\n                    resetShape()\n                }\n            }\n        }\n\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        im.clear()\n        im.color.set(COLOR_RED)\n\n        val z = -0.01f\n\n        var resGhostOffset = 0\n        if (showGhost) {\n            for (ghostOffset in 0 until tetrisGame.cup.height) {\n                var stopped = false\n                for (ix in 0 until 4) {\n                    for (iy in 0 until 4) {\n                        if (shape.cells[ix, iy, orientation] == 1) {\n                            val stoppedByWall = y + iy - ghostOffset == 0\n                            val stoppedByBrick = (iy + y - 1 - ghostOffset in 0 until tetrisGame.cup.height) && (tetrisGame.cup.cells[x + ix, iy + y - 1 - ghostOffset] >= 0)\n\n                            if (stoppedByWall || stoppedByBrick) {\n                                stopped = true\n                            }\n                        }\n                    }\n                }\n\n                if (stopped) {\n                    resGhostOffset = ghostOffset\n                    break\n                }\n            }\n        }\n\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n                    im.renderBlock(x + ix.toFloat(), y + iy.toFloat(), COLORS[shape.color])\n\n                    if (showGhost && resGhostOffset != 0) {\n                        im.renderBlock(x + ix.toFloat(), y + iy.toFloat() - resGhostOffset, COLORS[shape.color], a = 0.12f)\n                    }\n                }\n            }\n        }\n\n        im.renderColoredTriangles(tetrisGame.cam)\n    }\n\n    fun canMoveRight(): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n\n                    val stoppedByWall = x + ix == tetrisGame.cup.width - 1\n                    val stoppedByBrick = (ix + x + 1 in 0 until tetrisGame.cup.width) && (tetrisGame.cup.cells[x + ix + 1, iy + y] >= 0)\n\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n\n                }\n            }\n        }\n        return true\n    }\n\n    fun canMoveLeft(): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n\n                    val stoppedByWall = x + ix == 0\n                    val stoppedByBrick = (ix + x - 1 in 0 until tetrisGame.cup.width) && (tetrisGame.cup.cells[x + ix - 1, iy + y] >= 0)\n\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n\n                }\n            }\n        }\n        return true\n    }\n\n    fun canMoveDown(): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n\n                    val stoppedByWall = y + iy == 0\n                    val stoppedByBrick = (iy + y - 1 in 0 until tetrisGame.cup.height) && (tetrisGame.cup.cells[x + ix, iy + y - 1] >= 0)\n\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n                }\n            }\n        }\n        return true\n    }\n\n    fun canRotate(dir: Int): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                val newOrient = (orientation + dir + 4) % 4\n                if (shape.cells[ix, iy, newOrient] == 1) {\n                    val stoppedByWall = y + iy < 0 || x + ix < 0 || x + ix >= tetrisGame.cup.width\n                    val stoppedByBrick = (ix + x in 0 until tetrisGame.cup.width && iy + y in 0 until tetrisGame.cup.height) && (tetrisGame.cup.cells[x + ix, iy + y] >= 0)\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n                }\n            }\n        }\n        return true\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","package kmptemplate.analytics\n\nabstract class Analytics {\n    abstract fun sendEvent(event: String, map: Map<String, Any> = emptyMap())\n}\n\nclass PrintAnalytics : Analytics() {\n    override fun sendEvent(event: String, map: Map<String, Any>) {\n        println(\"analytics event: ${event} params: ${map}\")\n    }\n}\n\nclass CombinedAnalytics(vararg val analytics: Analytics) : Analytics() {\n    override fun sendEvent(event: String, map: Map<String, Any>) {\n        for (analytic in analytics) {\n            try {\n                analytic.sendEvent(event, map)\n            } catch (t: Throwable) {\n                println(\"Failed to send analytic event ${event} params: ${map}\")\n                t.printStackTrace()\n            }\n        }\n    }\n}","package kmptemplate.color\n\nimport kmptemplate.math.Vec4\n\nclass Color(red: Float, green: Float, blue: Float, alpha: Float) : Vec4(red, green, blue, alpha) {\n\n    var r: Float\n        get() = super.data[0]\n        set(value) {\n            super.data[0] = value\n        }\n\n    var g: Float\n        get() = super.data[1]\n        set(value) {\n            super.data[1] = value\n        }\n\n    var b: Float\n        get() = super.data[2]\n        set(value) {\n            super.data[2] = value\n        }\n\n    var a: Float\n        get() = super.data[3]\n        set(value) {\n            super.data[3] = value\n        }\n\n    constructor(c: Color) : this(c.r, c.g, c.b, c.a)\n\n    init {\n        r = red\n        g = green\n        b = blue\n        a = alpha\n    }\n\n    fun set(r: Float, g: Float, b: Float, a: Float) {\n        this.r = r\n        this.g = g\n        this.b = b\n        this.a = a\n    }\n\n    fun set(color: Color) {\n        set(color.r, color.g, color.b, color.a)\n    }\n\n    fun setMix(color1: Color, color2: Color, k: Float) {\n        val q = 1f - k\n        set(color1.r * q + color2.r * k, color1.g * q + color2.g * k, color1.b * q + color2.b * k, color1.a * q + color2.a * k)\n    }\n\n    fun set(r: Float, g: Float, b: Float) {\n        this.r = r\n        this.g = g\n        this.b = b\n        this.a = 1f\n    }\n\n}\n\nval COLOR_RED = Color(1f, 0f, 0f, 1f)\nval COLOR_GREEN = Color(0f, 1f, 0f, 1f)\nval COLOR_BLUE = Color(0f, 0f, 1f, 1f)\nval COLOR_YELLOW = Color(1f, 1f, 0f, 1f)\nval COLOR_CYAN = Color(0f, 1f, 1f, 1f)\nval COLOR_MAGENTA = Color(1f, 0f, 1f, 1f)\nval COLOR_BLACK = Color(0f, 0f, 0f, 1f)\nval COLOR_WHITE = Color(1f, 1f, 1f, 1f)\nval COLOR_GRAY = Color(0.5f, 0.5f, 0.5f, 1f)\n\nval COLOR_DARK_RED = Color(0.25f, 0f, 0f, 1f)\n\n\nval COLOR_LIGHT_RED = Color(1f, 0.5f, 0.5f, 1f)\nval COLOR_LIGHT_GREEN = Color(0.5f, 1f, 0.5f, 1f)\nval COLOR_LIGHT_BLUE = Color(0.5f, 0.5f, 1f, 1f)\n\n\n","package kmptemplate.entities\n\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.input.Keyboard\n\nprivate var idCounter = 1\n\nopen class Entity(val parent: Entity? = null, var childs: ArrayList<Entity> = ArrayList()) {\n\n    val id = idCounter++\n\n    init {\n        parent?.childs?.add(this)\n    }\n\n    var active = true\n\n    var inputActive = true\n\n    open suspend fun loadResources(gloo: GLOO) {}\n    open fun init(gloo: GLOO) {}\n    open fun preUpdate(dt: Double, t: Double, input: Keyboard) {}\n    open fun update(dt: Double, t: Double, input: Keyboard) {}\n    open fun render(viewport: Viewport, cam: Camera, uiCam: PlainCamera) {}\n\n    fun initHierarchy(gloo: GLOO) {\n        init(gloo)\n        for (child in childs) {\n            child.initHierarchy(gloo)\n        }\n    }\n\n    fun preUpdateHierarchy(dt: Double, t: Double, input: Keyboard) {\n        if (active) {\n            preUpdate(dt, t, input)\n            for (i in 0 until childs.size) {\n                val child = childs[childs.size - 1 - i]\n                child.preUpdateHierarchy(dt, t, input)\n            }\n        }\n    }\n\n    fun updateHierarchy(dt: Double, t: Double, input: Keyboard) {\n        if (active) {\n            update(dt, t, input)\n            for (i in 0 until childs.size) {\n                val child = childs[childs.size - 1 - i]\n                child.updateHierarchy(dt, t, input)\n            }\n        }\n    }\n\n    fun renderHierarchy(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        if (active) {\n            render(viewport, unused1, unused2)\n            for (child in childs) {\n                child.renderHierarchy(Viewport.FAKE_VIEWPORT, unused1, unused2)\n            }\n        }\n    }\n}\n","package kmptemplate.gloo\n\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.degToRad\nimport kmptemplate.math.setMult\nimport kotlin.math.tan\n\nabstract class Cam {\n    var width = 320\n    var height = 240\n\n    val projMatrix = Mat4()\n    val viewMatrix = Mat4()\n\n    fun setScreenSize(w: Int, h: Int) {\n        width = w\n        height = h\n        recalc()\n    }\n\n    abstract fun recalc()\n\n    @Deprecated(message = \"use Ray.ray() instead\")\n    abstract fun ray(x: Float, y: Float): Ray\n\n    abstract fun rayThrough(ray: Ray, x: Float, y: Float)\n}\n\nclass Camera : Cam() {\n\n    var fov = 90f\n        set(newFov) {\n            field = newFov\n            recalc()\n        }\n\n    var near = 0.05f\n        set(newNear) {\n            field = newNear\n            recalc()\n        }\n\n    var far = 10000f\n        set(newFar) {\n            field = newFar\n            recalc()\n        }\n\n    var pos = Vec3(0f, 0f, 0f)\n        set(newPos) {\n            field.assign(newPos)\n            recalc()\n        }\n\n    //normalized\n    val worldUp = Vec3(0f, 1f, 0f)\n\n    //normalized\n    var up = Vec3(0f, 1f, 0f)\n        set(newUp) {\n            field.assign(newUp)\n            recalc()\n        }\n\n    //normalized\n    var dir = Vec3(0f, 0f, -1f)\n        set(newDir) {\n            field.assign(newDir)\n            recalc()\n        }\n\n    //normalized\n    val right = Vec3(1f, 1f, 1f)\n\n    fun lookAt(center: Vec3) {\n        dir.assign(center)\n        dir.minusAssign(pos)\n\n        recalc()\n    }\n\n    fun lookDir(newDir: Vec3) {\n        dir.assign(newDir)\n        recalc()\n    }\n\n    private val tmpLookCenter = Vec3(0f, 0f, 0f)\n\n    override fun recalc() {\n        dir.normalize()\n\n        right.setCross(dir, worldUp)\n        right.normalize()\n\n        up.setCross(right, dir)\n        up.normalize()\n\n\n        tmpLookCenter.assign(pos)\n        tmpLookCenter.plusAssign(dir)\n\n        viewMatrix.setLookAt(pos, tmpLookCenter, up)\n        val aspect = width.toFloat() / height\n        projMatrix.setPerspective(degToRad(fov), aspect, near, far)\n    }\n\n    override fun ray(x: Float, y: Float): Ray {\n        recalc()\n\n        val ray = Ray()\n        ray.origin.set(pos)\n        ray.dir.set(dir)\n\n        val beta = fov / 2.0f\n\n        val l = 0.5f / tan(degToRad(beta))\n\n        ray.dir.setZero()\n        ray.dir.addMult(l, dir)\n        ray.dir.addMult(y / height, up)\n        ray.dir.addMult(x / height, right)\n\n        return ray\n    }\n\n    override fun rayThrough(ray: Ray, x: Float, y: Float) {\n        TODO(\"Not yet implemented\")\n    }\n}\n\nclass OrthoCamera : Cam() {\n\n    var w: Float = 2f\n    var h: Float = 2f\n\n    private var near = -10f\n    private var far = 10f\n\n    private val pos = Vec3(0f, 0f, 0f)\n    private val dir = Vec3(0f, 0f, -1f)\n    private val up = Vec3(0f, 1f, 0f)\n    private val right = Vec3(1f, 1f, 1f)\n    val worldUp = Vec3(0f, 1f, 0f)\n\n    fun setFullScreen() {\n        pos.set(0f, 0f, 0f)\n        dir.set(0f, 0f, -1f)\n\n        viewMatrix.setIdentity()\n\n        near = -10f\n        far = 10f\n\n        recalc()\n    }\n\n\n    fun fitH(b: Float, t: Float, cx: Float, cy: Float, cz: Float = 0f) {\n        pos.set(cx, cy, cz)\n        dir.set(0f, 0f, -1f)\n\n        val a: Float = width.toFloat() / height\n\n        val sz = (t - b) / 2\n\n        val left = -sz * a + cx\n        val right = sz * a + cx\n\n        val bottom = b + cy\n        val top = t + cy\n\n        w = right - left\n        h = top - bottom\n\n        recalc()\n    }\n\n    fun fitW(l: Float, r: Float, cx: Float, cy: Float, cz: Float = 0f) {\n        pos.set(cx, cy, cz)\n        dir.set(0f, 0f, -1f)\n\n        val a: Float = width.toFloat() / height\n\n        val sz = (r - l) / 2\n\n        val bottom = -sz / a\n        val top = sz / a\n\n        w = r - l\n        h = top - bottom\n\n        recalc()\n    }\n\n    fun fit(l: Float, r: Float, b: Float, t: Float, cx: Float, cy: Float, cz: Float = 0f) {\n        val screenAspect = width.toFloat() / height.toFloat()\n\n        val contentAspect = (r - l) / (t - b)\n\n        if (contentAspect > screenAspect) {\n            fitW(l, r, cx, cy, cz)\n        } else {\n            fitH(b, t, cx, cy, cz)\n        }\n    }\n\n    private val tmpLookCenter = Vec3(0f, 0f, 0f)\n\n    override fun recalc() {\n        dir.normalize()\n\n        right.setCross(dir, worldUp)\n        right.normalize()\n\n        up.setCross(right, dir)\n        up.normalize()\n\n        tmpLookCenter.assign(pos)\n        tmpLookCenter.plusAssign(dir)\n\n        viewMatrix.setLookAt(pos, tmpLookCenter, up)\n        projMatrix.setOrtho(-w / 2f, w / 2f, -h / 2f, h / 2f, near, far)\n    }\n\n\n    override fun ray(x: Float, y: Float): Ray {\n        recalc()\n\n        val winX: Float = x\n        val winY: Float = y\n        val winW: Float = width.toFloat()\n        val winH: Float = height.toFloat()\n\n        //x in -1..1 (left to right), y in -1..1 (bottom to top)\n        val fx = 2f * (winX / winW) - 1f\n        val fy = 1f - 2f * (winY / winH)\n\n        val ray = Ray()\n        ray.origin.set(pos)\n        ray.origin.addMult(fx / 2f * w, right)\n        ray.origin.addMult(fy / 2f * h, up)\n\n        ray.dir.set(dir)\n        ray.dir.normalize()\n\n        return ray\n    }\n\n    override fun rayThrough(ray: Ray, x: Float, y: Float) {\n        recalc()\n\n        val winX: Float = x\n        val winY: Float = y\n        val winW: Float = width.toFloat()\n        val winH: Float = height.toFloat()\n\n        //x in -1..1 (left to right), y in -1..1 (bottom to top)\n        val fx = 2f * (winX / winW) - 1f\n        val fy = 1f - 2f * (winY / winH)\n\n        ray.origin.set(pos)\n        ray.origin.addMult(fx / 2f * w, right)\n        ray.origin.addMult(fy / 2f * h, up)\n\n        ray.dir.set(dir)\n        ray.dir.normalize()\n    }\n\n\n    fun roll(a: Float) {\n        val m = Mat4()\n        m.setRotate(a, dir)\n\n        up.setMult(m, up)\n        right.setMult(m, right)\n        worldUp.setMult(m, worldUp)\n\n        recalc()\n    }\n\n    var verFov = 10f\n    var horFov = 10f\n\n    fun fitHeightCalcWidth(viewport: Viewport, h: Float) {\n        verFov = h\n        horFov = viewport.w * h / viewport.h\n\n        this.w = horFov\n        this.h = verFov\n    }\n\n    fun fitWidthCalcHeight(menuViewport: Viewport, w: Float) {\n        horFov = w\n        verFov = menuViewport.h * w / menuViewport.w\n\n\n        this.w = horFov\n        this.h = verFov\n    }\n\n    fun fitAll(w: Float, h: Float, viewPort: Viewport) {\n        if (w / h < viewPort.w.toFloat() / viewPort.h.toFloat()) {\n            verFov = h\n            horFov = h / viewPort.h * viewPort.w\n        } else {\n            horFov = w\n            verFov = w / viewPort.w * viewPort.h\n        }\n\n        this.w = horFov\n        this.h = verFov\n    }\n}","package kmptemplate.gloo\n\nimport kmptemplate.data.FloatArr\nimport kmptemplate.math.Vec2\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.Vec4\n\n\n\nopen class FloatBuffer {\n    var typedArr: FloatArr\n\n    /** pos to [prAdd] inside FloatBuffer (not inside underlying [typedArr])*/\n    var pos = 0\n    var capacity = 0\n\n    /** Offset inside [typedArr]*/\n    var offset = 0\n    var lengthField = 0\n\n    constructor(capacity: Int) : this(FloatArr(capacity), 0, 0)\n\n    constructor(buf: FloatArr, offset: Int, length: Int) {\n        typedArr = buf\n        capacity = buf.size - offset\n        pos = 0\n        this.offset = offset\n        this.lengthField = length\n    }\n\n    constructor(buf: FloatBuffer, offset: Int, length: Int) : this(buf.typedArr, buf.offset + offset, length)\n\n    fun prAdd(f: Float) {\n        if (pos >= capacity) {\n            capacity = capacity * 2\n            val newarr = FloatArr(capacity)\n            typedArr.copyInto(newarr)\n            typedArr = newarr\n        }\n        typedArr[pos] = f\n        pos++\n        lengthField++\n    }\n\n    operator fun get(i: Int): Float {\n        return typedArr[offset + i]\n    }\n\n    operator fun set(i: Int, v: Float) {\n        typedArr[offset + i] = v\n    }\n\n    fun length(): Int {\n        return lengthField\n    }\n\n    fun reset() {\n        pos = 0\n        lengthField = 0\n    }\n\n    override fun toString(): String {\n//        var res = \"\"\n//        for (i in 0 until pos) {\n//            res += typedArr[i]\n//            res += \" \"\n//        }\n//        return res\n        return \"FloatBuffer\"\n    }\n\n\n}\n\nclass FloatBuffer1 : FloatBuffer {\n\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun add(x: Float) {\n        prAdd(x)\n    }\n}\n\nclass FloatBuffer2 : FloatBuffer {\n\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun add(x: Float, y: Float) {\n        prAdd(x)\n        prAdd(y)\n    }\n\n    fun add(v: Vec2) {\n        add(v.x, v.y)\n    }\n}\n\nclass FloatBuffer3 : FloatBuffer {\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun set(i: Int, x: Float, y: Float, z: Float) {\n        set(i * 3, x)\n        set(i * 3 + 1, y)\n        set(i * 3 + 2, z)\n    }\n\n    fun add(x: Float, y: Float, z: Float) {\n        prAdd(x)\n        prAdd(y)\n        prAdd(z)\n    }\n\n    fun add(v: Vec3) {\n        add(v.x, v.y, v.z)\n    }\n}\n\nclass FloatBuffer4 : FloatBuffer {\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun add(x: Float, y: Float, z: Float, w: Float) {\n        prAdd(x)\n        prAdd(y)\n        prAdd(z)\n        prAdd(w)\n    }\n\n    fun add(v: Vec4) {\n        add(v.x, v.y, v.z, v.w)\n    }\n}","package kmptemplate.gloo\n\n\nclass FramebufferHandle(val value: Any?)\n\nexpect fun createScreenFramebufferHandle(): FramebufferHandle\n\n\nclass Framebuffer(val gl: GL, val handle: FramebufferHandle) {\n\n    fun bind() {\n        gl.bindFramebuffer(GL.GL_FRAMEBUFFER, handle)\n    }\n\n    fun unbind() {\n        gl.bindFramebuffer(GL.GL_FRAMEBUFFER, ScreenHandle)\n    }\n\n    fun setTexture(texture: Texture2D) {\n        gl.framebufferTexture2D(GL.GL_FRAMEBUFFER, GL.GL_COLOR_ATTACHMENT0, GL.GL_TEXTURE_2D, texture.handle, 0)\n    }\n\n//    fun setDepth(texture: Texture2D) {\n//        gl.framebufferTexture2D(GL.GL_FRAMEBUFFER, GL.GL_DEPTH_ATTACHMENT, GL.GL_TEXTURE_2D, texture.handle, 0)\n//    }\n\n    fun checkStatus(): Int {\n        val status = gl.checkFramebufferStatus(GL.GL_FRAMEBUFFER)\n        if (status != GL.GL_FRAMEBUFFER_COMPLETE) {\n            throw RuntimeException(\"Framebuffer not complete (status=${status})\")\n        }\n        return status\n    }\n\n    companion object {\n        val ScreenHandle = createScreenFramebufferHandle()\n    }\n}\n","package kmptemplate.gloo\n\nimport kmptemplate.color.Color\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.math.Mat2\nimport kmptemplate.math.Mat3\nimport kmptemplate.math.Mat4\n\ndata class ShaderType(val value: Int)\ndata class ShaderHandle(val value: Any)\ndata class ProgramHandle(val value: Any)\n\ndata class BufferTarget(val value: Int)\ndata class BufferUsage(val value: Int)\n\ndata class BufferHandle(val value: Any)\n\ndata class TextureHandle(val value: Any)\n\ndata class UniformLocation(val value: Any)\ndata class AttribLocation(val value: Int)\n\ndata class DataType(val value: Int)\n\ndata class DrawMode(val value: Int)\n\ndata class ShaderQuery(val value: Int)\ndata class ProgramQuery(val value: Int)\n\nabstract class GL {\n    companion object {\n        val FRAGMENT_SHADER = ShaderType(35632)\n        val VERTEX_SHADER = ShaderType(35633)\n\n        val ARRAY_BUFFER = BufferTarget(34962)\n        val ELEMENT_ARRAY_BUFFER = BufferTarget(34963)\n\n        val STATIC_DRAW = BufferUsage(35044)\n        val DYNAMIC_DRAW = BufferUsage(35048)\n        val STREAM_DRAW = BufferUsage(35040)\n\n        val GL_FLOAT = DataType(5126)\n\n        val GL_POINTS = DrawMode(0)\n        val GL_LINES = DrawMode(1)\n        val GL_LINE_LOOP = DrawMode(2)\n        val GL_LINE_STRIP = DrawMode(3)\n        val GL_TRIANGLES = DrawMode(4)\n        val GL_TRIANGLE_STRIP = DrawMode(5)\n        val GL_TRIANGLE_FAN = DrawMode(6)\n\n        val GL_COLOR_BUFFER_BIT = 16384\n        val GL_DEPTH_BUFFER_BIT = 256\n\n        val GL_LINK_STATUS = ProgramQuery(35714)\n        val GL_VALIDATE_STATUS = ProgramQuery(35715)\n        val GL_ACTIVE_ATTRIBUTES = ProgramQuery(35721)\n        val GL_ACTIVE_UNIFORMS = ProgramQuery(35718)\n\n        val GL_SHADER_TYPE = ShaderQuery(35663)\n        val GL_COMPILE_STATUS = ShaderQuery(35713)\n        val GL_INFO_LOG_LENGTH = ShaderQuery(35716)\n        val GL_SHADER_SOURCE_LENGTH = ShaderQuery(35720)\n\n        val GL_NO_ERROR = 0\n        val GL_INVALID_ENUM = 1280\n        val GL_INVALID_VALUE = 1281\n        val GL_INVALID_OPERATION = 1282\n        val GL_INVALID_FRAMEBUFFER_OPERATION = 1286\n        val GL_OUT_OF_MEMORY = 1285\n\n        val GL_TEXTURE0 = 33984\n        val GL_TEXTURE_2D = 3553\n        val GL_RGBA = 6408\n        val GL_UNSIGNED_BYTE = 5121\n\n        val GL_TEXTURE_MAG_FILTER = 10240\n        val GL_TEXTURE_MIN_FILTER = 10241\n\n        val GL_LINEAR = 9729\n        val GL_NEAREST = 9728\n        val GL_NEAREST_MIPMAP_NEAREST = 9984\n        val GL_LINEAR_MIPMAP_NEAREST = 9985\n        val GL_NEAREST_MIPMAP_LINEAR = 9986\n        val GL_LINEAR_MIPMAP_LINEAR = 9987\n\n        val GL_CLAMP_TO_EDGE = 33071\n        val GL_REPEAT = 10497\n        val GL_MIRRORED_REPEAT = 33648\n\n        val GL_TEXTURE_WRAP_S = 10242\n        val GL_TEXTURE_WRAP_T = 10243\n\n        val GL_DEPTH_TEST = 2929\n        val GL_BLEND = 3042\n\n        val GL_CULL_FACE = 2884\n        val GL_FRONT = 1028\n        val GL_BACK = 1029\n\n        val GL_CW = 2304\n        val GL_CCW = 2305\n\n        val GL_SRC_ALPHA = 770\n        val GL_ONE_MINUS_SRC_ALPHA = 771\n\n        val GL_SCISSOR_TEST = 3089\n\n        val GL_FRAMEBUFFER = 36160\n        val GL_COLOR_ATTACHMENT0 = 36064\n        val GL_DEPTH_ATTACHMENT = 36096\n\n        val GL_FRAMEBUFFER_COMPLETE = 36053\n    }\n\n    var errorChecking = true\n\n    abstract fun clear()\n    abstract fun clearColor(r: Float, g: Float, b: Float, a: Float)\n\n    fun clearColor(color: Color) {\n        clearColor(color.r, color.g, color.b, color.a)\n    }\n\n    abstract fun viewPort(x: Int, y: Int, width: Int, height: Int)\n\n    abstract fun createShader(type: ShaderType): ShaderHandle\n\n    abstract fun shaderSource(shader: ShaderHandle, code: String)\n\n    abstract fun compileShader(shader: ShaderHandle)\n    fun compileShaderOrThrow(shader: ShaderHandle) {\n        compileShader(shader)\n        val compilationLog = glGetShaderInfoLog(shader)\n        if (!compilationLog.isNullOrBlank()) {\n            throw Exception(\"Failed to compile shader\\n${compilationLog}\")\n        }\n    }\n\n    abstract fun createProgram(): ProgramHandle\n\n    abstract fun attachShader(program: ProgramHandle, shader: ShaderHandle)\n\n    abstract fun linkProgram(program: ProgramHandle)\n    fun linkProgramOrThrow(program: ProgramHandle) {\n        linkProgram(program)\n        val linkLog = glGetProgramInfoLog(program)\n        if (!linkLog.isNullOrBlank()) {\n            throw Exception(\"Shader Compilation failed\\n${linkLog}\")\n        }\n    }\n\n    abstract fun useProgram(program: ProgramHandle)\n\n    abstract fun getUniformLocation(program: ProgramHandle, uniformName: String): UniformLocation\n    abstract fun glUniform1f(location: UniformLocation, x: Float)\n    abstract fun glUniform2f(location: UniformLocation, x: Float, y: Float)\n    abstract fun glUniform3f(location: UniformLocation, x: Float, y: Float, z: Float)\n    abstract fun glUniform4f(location: UniformLocation, x: Float, y: Float, z: Float, w: Float)\n\n    abstract fun glUniformMat2f(location: UniformLocation, data: FloatArray)\n    abstract fun glUniformMat3f(location: UniformLocation, data: FloatArray)\n    abstract fun glUniformMat4f(location: UniformLocation, data: FloatArray)\n\n    abstract fun glUniform1i(location: UniformLocation, v: Int)\n\n    fun glUniformMat2f(location: UniformLocation, m: Mat2) {\n        glUniformMat2f(location, m.data)\n    }\n\n    fun glUniformMat3f(location: UniformLocation, m: Mat3) {\n        glUniformMat3f(location, m.data)\n    }\n\n    fun glUniformMat4f(location: UniformLocation, m: Mat4) {\n        glUniformMat4f(location, m.data)\n    }\n\n    abstract fun getAttribLocation(program: ProgramHandle, attribName: String): AttribLocation\n    abstract fun vertexAttribPointer(\n        location: AttribLocation,\n        coordsPerVertex: Int,\n        type: DataType,\n        normalized: Boolean = false,\n        stride: Int = 0,\n        pointer: Int = 0\n    )\n\n    abstract fun createTexture(): TextureHandle\n    abstract fun texParameteri(target: Int, param: Int, value: Int)\n    abstract fun activeTexture(texture: Int)\n    abstract fun bindTexture(target: Int, handle: TextureHandle)\n\n    abstract fun createBuffer(): BufferHandle\n    abstract fun bufferData(target: BufferTarget, data: FloatBuffer, usage: BufferUsage)\n    abstract fun bindBuffer(target: BufferTarget, buffer: BufferHandle)\n\n    abstract fun drawArrays(mode: DrawMode, first: Int, countVerts: Int)\n\n    abstract fun glEnableVertexAttribArray(location: AttribLocation)\n\n    abstract fun glGetShaderInfoLog(shader: ShaderHandle): String\n\n    abstract fun glGetProgramInfoLog(program: ProgramHandle): String\n\n    abstract fun glGetError(): Int\n    fun checkErrors() {\n        if (errorChecking) {\n            val err = glGetError()\n            if (err != GL_NO_ERROR) {\n                val errStr = when (err) {\n                    GL_INVALID_ENUM -> \"GL_INVALID_ENUM\"\n                    GL_INVALID_VALUE -> \"GL_INVALID_VALUE\"\n                    GL_INVALID_OPERATION -> \"GL_INVALID_OPERATION\"\n                    GL_INVALID_FRAMEBUFFER_OPERATION -> \"GL_INVALID_FRAMEBUFFER_OPERATION\"\n                    GL_OUT_OF_MEMORY -> \"GL_OUT_OF_MEMORY\"\n                    else -> \"Unknown Error: ${err}\"\n                }\n                throw Exception(\"glGetError returned ${errStr}\")\n            }\n        }\n    }\n\n    abstract fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, offset: Int)\n    abstract suspend fun texImage2D(textureHandle: TextureHandle, path: String): Pair<Int, Int>\n\n    abstract fun texImage2D(textureHandle: TextureHandle, droppedImage: DroppedImage): Pair<Int, Int>\n\n    abstract fun cullFace(mode: Int)\n\n    abstract fun frontFace(mode: Int)\n\n    abstract fun blendFunc(sfactor: Int, dfactor: Int)\n\n    abstract fun enable(capability: Int)\n\n    abstract fun disable(capability: Int)\n\n    abstract fun scissor(x: Int, y: Int, w: Int, h: Int)\n\n    abstract fun genFramebuffer(): FramebufferHandle\n\n    abstract fun bindFramebuffer(target: Int, handle: FramebufferHandle)\n\n    abstract fun framebufferTexture2D(target: Int, attachment: Int, texTarget: Int, texture: TextureHandle, level: Int)\n\n    abstract fun readPixels(x: Int, y: Int, w: Int, h: Int, format: Int, type: Int, data: FloatArray)\n\n    abstract fun screenshot(path: String)\n\n    abstract fun checkFramebufferStatus(target: Int): Int\n}\n","package kmptemplate.gloo\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.gloo.GL.Companion.GL_TEXTURE0\nimport kmptemplate.gloo.GL.Companion.GL_TEXTURE_2D\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Vec2\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.Vec4\n\n\nclass Texture2D(val gl: GL, val handle: TextureHandle, val width: Int, val height: Int) {\n\n    fun bind(unit: Int) {\n        gl.activeTexture(GL_TEXTURE0 + unit)\n        gl.checkErrors()\n        gl.bindTexture(GL_TEXTURE_2D, handle)\n        gl.checkErrors()\n    }\n\n    //TODO make GLOO.createTexture(w,h) : Texture2D instead of this\n    fun createData() {\n        gl.texImage2D(GL_TEXTURE_2D, 0, GL.GL_RGBA, width, height, 0, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, 0)\n        gl.checkErrors()\n    }\n\n    companion object {\n        val POWERS_OF_TWO = IntArray(16) { i -> 2 shl i }\n    }\n}\n\nclass Buffer(val gl: GL, val handle: BufferHandle) {\n\n    fun setData(floatBuffer: FloatBuffer, usage: BufferUsage = GL.STATIC_DRAW) {\n        bind()\n        PERF_TRACKER.trackGLbufferData(Float.SIZE_BYTES * floatBuffer.length())\n        gl.bufferData(GL.ARRAY_BUFFER, floatBuffer, usage)\n    }\n\n    fun bind() {\n        gl.bindBuffer(GL.ARRAY_BUFFER, handle)\n    }\n}\n\nclass VertexShader(val gl: GL, val handle: ShaderHandle) {\n\n}\n\nclass FragmentShader(val gl: GL, val handle: ShaderHandle) {\n\n}\n\n\nclass Uniform1f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(v: Float) {\n        program.gl.glUniform1f(location, v)\n    }\n}\n\nclass Uniform2f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(x: Float, y: Float) {\n        program.gl.glUniform2f(location, x, y)\n    }\n\n    fun set(v: Vec2) {\n        set(v.x, v.y)\n    }\n}\n\nclass Uniform3f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(x: Float, y: Float, z: Float) {\n        program.gl.glUniform3f(location, x, y, z)\n    }\n\n    fun set(v: Vec3) {\n        set(v.x, v.y, v.z)\n    }\n}\n\nclass Uniform4f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(x: Float, y: Float, z: Float, w: Float) {\n        program.gl.glUniform4f(location, x, y, z, w)\n    }\n\n    fun set(v: Vec4) {\n        set(v.x, v.y, v.z, v.w)\n    }\n}\n\nclass UniformMat4f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(mat: Mat4) {\n        program.gl.glUniformMat4f(location, mat)\n    }\n}\n\nclass UniformSampler2D(val program: ShaderProgram, val location: UniformLocation, val texUnit: Int) {\n\n    fun set(texture: Texture2D) {\n        texture.bind(texUnit)\n        program.gl.glUniform1i(location, texUnit)\n    }\n}\n\nclass Attrib1f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 1, GL.GL_FLOAT)\n    }\n\n    fun set(v: Float) {\n        TODO(\"not implemented yet (if it's even possible)\")\n    }\n}\n\nclass Attrib2f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 2, GL.GL_FLOAT)\n    }\n\n    fun set(vec: Vec2) {\n        TODO(\"not implemented yet (if it's even possible)\")\n    }\n}\n\nclass Attrib3f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 3, GL.GL_FLOAT)\n    }\n\n    fun set(vec: Vec3) {\n        TODO(\"not implemented yet (if it's even possible)\")\n    }\n}\n\nclass Attrib4f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 4, GL.GL_FLOAT)\n    }\n\n    fun set(vec: Vec4) {\n        TODO(\"not implemented yet (if it's even possible)\")\n        //glVertexAttrib should be used\n    }\n}\n\nopen class ShaderProgram(val gl: GL, val handle: ProgramHandle, val vertexShader: VertexShader, val fragmentShader: FragmentShader) {\n\n    private var unit = 0\n    private val uniformToTextureUnit = mutableMapOf<String, Int>()\n\n    fun use() {\n        gl.useProgram(handle)\n    }\n\n    fun getUniform1f(name: String): Uniform1f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform1f(this, location)\n    }\n\n    fun getUniform2f(name: String): Uniform2f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform2f(this, location)\n    }\n\n    fun getUniform3f(name: String): Uniform3f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform3f(this, location)\n    }\n\n    fun getUniform4f(name: String): Uniform4f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform4f(this, location)\n    }\n\n    fun getUniformMat4f(name: String): UniformMat4f {\n        val location = gl.getUniformLocation(handle, name)\n        return UniformMat4f(this, location)\n    }\n\n    fun getUniformSampler2D(name: String): UniformSampler2D {\n        val location = gl.getUniformLocation(handle, name)\n        val texUnit = uniformToTextureUnit[name] ?: unit++\n        return UniformSampler2D(this, location, texUnit)\n    }\n\n    fun getAttrib4f(name: String): Attrib4f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib4f(this, location)\n    }\n\n    fun getAttrib3f(name: String): Attrib3f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib3f(this, location)\n    }\n\n    fun getAttrib2f(name: String): Attrib2f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib2f(this, location)\n    }\n\n    fun getAttrib1f(name: String): Attrib1f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib1f(this, location)\n    }\n\n}\n\nclass GLOO(val gl: GL) {\n\n    fun createBuffer(): Buffer {\n        val handle = gl.createBuffer()\n        return Buffer(gl, handle)\n    }\n\n    fun createVertexShader(code: String): VertexShader {\n        val handle = gl.createShader(GL.VERTEX_SHADER)\n        gl.shaderSource(handle, code)\n        gl.compileShader(handle)\n        val compilationLog = gl.glGetShaderInfoLog(handle)\n        if (compilationLog.isNotBlank()) {\n            throw Exception(\"Failed to compile vertex shader\\n${compilationLog}\")\n        }\n\n        return VertexShader(gl, handle)\n    }\n\n    fun createFragmentShader(code: String): FragmentShader {\n        val handle = gl.createShader(GL.FRAGMENT_SHADER)\n        gl.shaderSource(handle, code)\n        gl.compileShader(handle)\n        val compilationLog = gl.glGetShaderInfoLog(handle)\n        if (compilationLog.isNotBlank()) {\n            throw Exception(\"Failed to compile fragment shader\\n${compilationLog}\")\n        }\n        return FragmentShader(gl, handle)\n    }\n\n    fun createShaderProgram(vertexShaderCode: String, fragmentShaderCode: String): ShaderProgram {\n        val programHandle = gl.createProgram()\n\n        val vertesShader = createVertexShader(vertexShaderCode)\n        val fragmentShader = createFragmentShader(fragmentShaderCode)\n\n        gl.attachShader(programHandle, vertesShader.handle)\n        gl.attachShader(programHandle, fragmentShader.handle)\n\n        gl.linkProgram(programHandle)\n        val linkLog = gl.glGetProgramInfoLog(programHandle)\n        if (linkLog.isNotBlank()) {\n            throw Exception(\"Shader Compilation failed\\n${linkLog}\")\n        }\n\n        return ShaderProgram(gl, programHandle, vertesShader, fragmentShader)\n    }\n\n    suspend fun createTexture2D(path: String): Texture2D {\n        val textureHandle = gl.createTexture()\n        gl.bindTexture(GL_TEXTURE_2D, textureHandle)\n        val (w, h) = gl.texImage2D(textureHandle, path)\n\n        val texture = Texture2D(gl, textureHandle, w, h)\n        return texture\n    }\n\n    fun createTexture2D(droppedImage: DroppedImage): Texture2D {\n        val textureHandle = gl.createTexture()\n        gl.bindTexture(GL_TEXTURE_2D, textureHandle)\n        val (w, h) = gl.texImage2D(textureHandle, droppedImage)\n\n        val texture = Texture2D(gl, textureHandle, w, h)\n        return texture\n    }\n\n    fun createFramebuffer(): Framebuffer {\n        return Framebuffer(gl, gl.genFramebuffer())\n    }\n}\n\n","package kmptemplate.gloo\n\nimport kmptemplate.math.Ray\n\nclass PlainCamera : Cam() {\n    override fun recalc() {\n        viewMatrix.setIdentity()\n        projMatrix.setIdentity()\n    }\n\n    override fun ray(x: Float, y: Float): Ray {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun rayThrough(ray: Ray, x: Float, y: Float) {\n        TODO(\"Not yet implemented\")\n    }\n}","package kmptemplate.gloo\n\n/**\nRepresentation of [GL viewport](https://docs.gl/es2/glViewport)\n\nx, y - specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).\n\nw, h - specify the width and height of the viewport.\n */\ndata class Viewport(var w: Int, var h: Int, var x: Int = 0, var y: Int = 0) {\n\n    fun horizontal() = w > h\n    fun vertical() = !horizontal()\n\n    fun copyFrom(viewport: Viewport) {\n        this.w = viewport.w\n        this.h = viewport.h\n        this.x = viewport.x\n        this.y = viewport.y\n    }\n\n    companion object {\n        val FAKE_VIEWPORT = Viewport(100, 100)\n    }\n}\n\n","package kmptemplate.gloo.fonts\n\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.Texture2D\nimport kotlin.math.max\n\nclass SdfFontShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aCoord;\n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main(void)\n        {\n            vTexCoord = aTexCoord;\n            gl_Position =  uProj * uView * uModel * vec4(aCoord, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uFontTexture;\n        uniform float uThreshold;// for example 0.2;\n        uniform float uWeight;// for example 0.4;\n        uniform vec4 uColor;\n        \n        varying vec2 vTexCoord;\n        \n        void main(void)\n        {\n//            float base = 1.0 - uWeight;\n//            float a = texture2D(uFontTexture, vTexCoord).a;\n//            vec4 res = uColor * smoothstep(base-uThreshold, base + uThreshold, a);\n            float distance = 1.0 - texture2D(uFontTexture, vTexCoord).a;\n            float a = 1.0 - smoothstep(uWeight, uWeight+uThreshold,distance);\n\n            gl_FragColor = vec4(uColor.rgb,a*uColor.a);\n        }\n        \"\"\".trimIndent()\n    )\n\n    val aCoord = prog.getAttrib3f(\"aCoord\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uFontTexture = prog.getUniformSampler2D(\"uFontTexture\")\n    val uThreshold = prog.getUniform1f(\"uThreshold\")\n    val uWeight = prog.getUniform1f(\"uWeight\")\n    val uColor = prog.getUniform4f(\"uColor\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: SdfFontShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\ndata class SdfChar(val id: Int, val x: Int, val y: Int, val width: Int, val height: Int, val xoffset: Int, val yoffset: Int, val xadvance: Int, val page: Int, val chnl: Int)\n\nclass SdfFont(val gloo: GLOO, val texture: Texture2D) {\n\n    val charmap = HashMap<Int, SdfChar>()\n\n    init {\n        loadCharMap()\n    }\n\n    private fun loadCharMap() {\n        val text = \"\"\"\ninfo face=\"Roboto Mono Light\" size=32 bold=0 italic=0 charset=\"\" unicode=0 stretchH=100 smooth=1 aa=1 padding=10,10,10,10 spacing=0,0\ncommon lineHeight=63 base=34 scaleW=512 scaleH=512 pages=1 packed=0\npage id=0 file=\"roboto.png\"\nchars count=163\nchar id=0       x=0    y=0    width=0    height=0    xoffset=-10  yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=10      x=0    y=0    width=0    height=0    xoffset=-10  yoffset=0    xadvance=20   page=0    chnl=0 \nchar id=32      x=0    y=0    width=0    height=0    xoffset=-10  yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=33      x=282  y=147  width=23   height=44   xoffset=-2   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=34      x=302  y=439  width=27   height=27   xoffset=-4   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=35      x=282  y=234  width=39   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=36      x=172  y=0    width=35   height=51   xoffset=-8   yoffset=-3   xadvance=39   page=0    chnl=0 \nchar id=37      x=132  y=102  width=39   height=45   xoffset=-10  yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=38      x=171  y=102  width=37   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=39      x=329  y=439  width=22   height=27   xoffset=-2   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=40      x=0    y=0    width=29   height=54   xoffset=-5   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=41      x=29   y=0    width=28   height=54   xoffset=-5   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=42      x=105  y=439  width=36   height=35   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=43      x=463  y=363  width=37   height=37   xoffset=-9   yoffset=5    xadvance=39   page=0    chnl=0 \nchar id=44      x=278  y=439  width=24   height=28   xoffset=-4   yoffset=21   xadvance=39   page=0    chnl=0 \nchar id=45      x=440  y=439  width=33   height=22   xoffset=-7   yoffset=13   xadvance=39   page=0    chnl=0 \nchar id=46      x=416  y=439  width=24   height=24   xoffset=-2   yoffset=21   xadvance=39   page=0    chnl=0 \nchar id=47      x=68   y=102  width=32   height=45   xoffset=-6   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=48      x=0    y=102  width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=49      x=180  y=234  width=29   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=50      x=176  y=147  width=36   height=44   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=51      x=395  y=54   width=35   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=52      x=209  y=234  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=53      x=212  y=147  width=35   height=44   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=54      x=247  y=147  width=35   height=44   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=55      x=246  y=234  width=36   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=56      x=430  y=54   width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=57      x=466  y=54   width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=58      x=485  y=320  width=24   height=38   xoffset=-1   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=59      x=212  y=320  width=25   height=42   xoffset=-2   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=60      x=141  y=439  width=34   height=34   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=61      x=243  y=439  width=35   height=29   xoffset=-8   yoffset=9    xadvance=39   page=0    chnl=0 \nchar id=62      x=175  y=439  width=35   height=34   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=63      x=35   y=102  width=33   height=45   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=64      x=305  y=147  width=39   height=44   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=65      x=420  y=147  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=66      x=458  y=147  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=67      x=73   y=54   width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=68      x=0    y=191  width=36   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=69      x=36   y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=70      x=70   y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=71      x=110  y=54   width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=72      x=104  y=191  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=73      x=139  y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=74      x=460  y=102  width=35   height=44   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=75      x=173  y=191  width=36   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=76      x=209  y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=77      x=243  y=191  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=78      x=278  y=191  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=79      x=147  y=54   width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=80      x=313  y=191  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=81      x=0    y=54   width=37   height=48   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=82      x=348  y=191  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=83      x=184  y=54   width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=84      x=383  y=191  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=85      x=0    y=147  width=35   height=44   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=86      x=420  y=191  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=87      x=457  y=191  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=88      x=0    y=234  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=89      x=38   y=234  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=90      x=75   y=234  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=91      x=119  y=0    width=26   height=51   xoffset=-3   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=92      x=100  y=102  width=32   height=45   xoffset=-6   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=93      x=145  y=0    width=27   height=51   xoffset=-4   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=94      x=210  y=439  width=33   height=33   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=95      x=473  y=439  width=35   height=22   xoffset=-8   yoffset=24   xadvance=39   page=0    chnl=0 \nchar id=96      x=390  y=439  width=26   height=25   xoffset=-3   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=97      x=274  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=98      x=476  y=0    width=34   height=45   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=99      x=309  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=100     x=220  y=54   width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=101     x=344  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=102     x=255  y=54   width=36   height=45   xoffset=-8   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=103     x=291  y=54   width=35   height=45   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=104     x=35   y=147  width=34   height=44   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=105     x=110  y=234  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=106     x=243  y=0    width=31   height=50   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=107     x=69   y=147  width=35   height=44   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=108     x=104  y=147  width=35   height=44   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=109     x=178  y=363  width=37   height=38   xoffset=-9   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=110     x=215  y=363  width=34   height=38   xoffset=-7   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=111     x=379  y=320  width=36   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=112     x=326  y=54   width=34   height=45   xoffset=-7   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=113     x=360  y=54   width=35   height=45   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=114     x=249  y=363  width=32   height=38   xoffset=-5   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=115     x=415  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=116     x=145  y=234  width=35   height=43   xoffset=-8   yoffset=2    xadvance=39   page=0    chnl=0 \nchar id=117     x=281  y=363  width=34   height=38   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=118     x=315  y=363  width=37   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=119     x=352  y=363  width=39   height=37   xoffset=-10  yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=120     x=391  y=363  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=121     x=139  y=147  width=37   height=44   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=122     x=427  y=363  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=123     x=57   y=0    width=31   height=52   xoffset=-5   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=124     x=274  y=0    width=23   height=49   xoffset=-2   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=125     x=88   y=0    width=31   height=52   xoffset=-5   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=126     x=351  y=439  width=39   height=27   xoffset=-10  yoffset=11   xadvance=39   page=0    chnl=0 \nchar id=1025    x=334  y=0    width=34   height=49   xoffset=-7   yoffset=-5   xadvance=39   page=0    chnl=0 \nchar id=1040    x=321  y=234  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1041    x=359  y=234  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1042    x=394  y=234  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1043    x=429  y=234  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1044    x=297  y=0    width=37   height=49   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1045    x=464  y=234  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1046    x=0    y=277  width=39   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1047    x=208  y=102  width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1048    x=39   y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1049    x=368  y=0    width=35   height=49   xoffset=-8   yoffset=-5   xadvance=39   page=0    chnl=0 \nchar id=1050    x=74   y=277  width=36   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1051    x=110  y=277  width=37   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1052    x=147  y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1053    x=182  y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1054    x=245  y=102  width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1055    x=217  y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1056    x=252  y=277  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1057    x=282  y=102  width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1058    x=287  y=277  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1059    x=344  y=147  width=39   height=44   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1060    x=324  y=277  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1061    x=361  y=277  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1062    x=403  y=0    width=36   height=49   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1063    x=399  y=277  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1064    x=433  y=277  width=36   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1065    x=439  y=0    width=37   height=49   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1066    x=469  y=277  width=38   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1067    x=0    y=320  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1068    x=35   y=320  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1069    x=319  y=102  width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1070    x=355  y=102  width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1071    x=69   y=320  width=36   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1072    x=450  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1073    x=37   y=54   width=36   height=46   xoffset=-8   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=1074    x=0    y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1075    x=35   y=402  width=34   height=37   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1076    x=237  y=320  width=37   height=42   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1077    x=0    y=363  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1078    x=69   y=402  width=39   height=37   xoffset=-10  yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1079    x=35   y=363  width=36   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1080    x=108  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1081    x=105  y=320  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1082    x=143  y=402  width=36   height=37   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1083    x=179  y=402  width=36   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1084    x=215  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1085    x=250  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1086    x=379  y=320  width=36   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1087    x=285  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1088    x=426  y=102  width=34   height=45   xoffset=-7   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1089    x=71   y=363  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1090    x=320  y=402  width=37   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1091    x=383  y=147  width=37   height=44   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1092    x=207  y=0    width=36   height=51   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1093    x=357  y=402  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1094    x=140  y=320  width=35   height=43   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1095    x=393  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1096    x=428  y=402  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1097    x=175  y=320  width=37   height=43   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1098    x=464  y=402  width=38   height=37   xoffset=-10  yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1099    x=0    y=439  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1100    x=35   y=439  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1101    x=106  y=363  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1102    x=141  y=363  width=37   height=39   xoffset=-9   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1103    x=70   y=439  width=35   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1105    x=391  y=102  width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \n\"\"\".trimIndent()\n\n        for (line in text.lineSequence()) {\n            if (line.startsWith(\"char \")) {\n                val props = line.split(\" \").filter { it.isNotBlank() }\n\n                var id = 0\n                var x = 0\n                var y = 0\n                var width = 0\n                var height = 0\n                var xoffset = 0\n                var yoffset = 0\n                var xadvance = 0\n                var page = 0\n                var chnl = 0\n                for (prop in props) {\n                    if (prop.startsWith(\"id=\")) {\n                        id = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"x=\")) {\n                        x = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"y=\")) {\n                        y = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"width=\")) {\n                        width = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"height=\")) {\n                        height = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"xoffset=\")) {\n                        xoffset = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"yoffset=\")) {\n                        yoffset = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"xadvance=\")) {\n                        xadvance = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"page=\")) {\n                        page = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"chnl=\")) {\n                        chnl = prop.substringAfter('=').toInt()\n                    }\n                }\n\n                charmap.put(id, SdfChar(id, x, y, width, height, xoffset, yoffset, xadvance, page, chnl))\n            }\n        }\n    }\n\n}\n\nfun calcWidth(btnText: String, h: Float, compress: Float = 1f): Float {\n    var maxCountInLine = 0\n    var countInLine = 0\n    for (ch in btnText) {\n        if (ch == '\\n') {\n            countInLine = 0\n        } else {\n            countInLine++\n        }\n        maxCountInLine = max(maxCountInLine, countInLine)\n    }\n    return 0.75f * ((maxCountInLine - 1) * h * compress + h)\n}\n\nfun calcHeight(btnText: String, h: Float): Float {\n    return (btnText.count { it == '\\n' } + 1) * h\n}","package kmptemplate.gloo.primitives\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.dist\nimport kmptemplate.math.distSq\nimport kmptemplate.math.dot\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.math.setMult\nimport kmptemplate.math.setMultFree\nimport kmptemplate.math.setNaN\nimport kmptemplate.math.sq\nimport kotlin.math.min\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\n\nprivate val e1_tmp_rayTriangleIntersect = Vec3()\nprivate val e2_tmp_rayTriangleIntersect = Vec3()\nprivate val pvec_tmp_rayTriangleIntersect = Vec3()\nprivate val tvec_tmp_rayTriangleIntersect = Vec3()\nprivate val qvec_tmp_rayTriangleIntersect = Vec3()\nprivate val dir_tmp_rayTriangleIntersect = Vec3()\nprivate val res_tmp_rayTriangleIntersect = Vec3()\n\n//https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9C%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%A2%D1%80%D1%83%D0%BC%D0%B1%D0%BE%D1%80%D0%B0\nfun Vec3.rayTriangleIntersect(ray: Ray, v0: Vec3, v1: Vec3, v2: Vec3) {\n    val EPS = 1e-8f\n\n    val e1 = e1_tmp_rayTriangleIntersect\n    val e2 = e2_tmp_rayTriangleIntersect\n    val pvec = pvec_tmp_rayTriangleIntersect\n    val tvec = tvec_tmp_rayTriangleIntersect\n    val qvec = qvec_tmp_rayTriangleIntersect\n\n    val dir = dir_tmp_rayTriangleIntersect\n    dir.set(ray.dir)\n\n    val res = res_tmp_rayTriangleIntersect\n\n    e1.setDiff(v1, v0)\n    e2.setDiff(v2, v0)\n\n    // Calculating normal to plane\n    pvec.setCross(ray.dir, e2)\n    val det = dot(e1, pvec)\n\n    // ray is parallel to plane\n    if (det < EPS && det > -EPS) {\n        setNaN()\n        return\n    }\n\n    val invDet = 1.0f / det\n\n    tvec.setDiff(ray.origin, v0);\n    val u = dot(tvec, pvec) * invDet;\n    if (u < 0.0f || u > 1.0f) {\n        setNaN()\n        return\n    }\n\n    qvec.setCross(tvec, e1)\n    val v = dot(ray.dir, qvec) * invDet;\n    if (v < 0.0f || u + v > 1.0f) {\n        setNaN()\n        return\n    }\n\n    dir.normalize()\n    dir *= (dot(e2, qvec) * invDet)\n\n    res.setSum(ray.origin, dir)\n\n    set(res)\n}\n\n/*semi-optimized version of intersection, non transforming model itself - just transforming a ray with inverse transformation */\n//fun intersectSemiOptimized(ray: Ray, mesh: Mesh, modelMat: Mat4): Vec3 {\n//    val M = Mat4()\n//\n//    M.assign(modelMat)\n//    val invM = inversed(Mat4(), M)\n//\n//    val ro = Vec3()\n//    val rd = Vec3()\n//\n//    ro.setMult(invM, ray.origin)\n//\n//    rd.setMultFree(invM, ray.dir)\n//    rd.normalize()\n//\n//    val vertsCount = mesh.posBuf.length() / 3\n//    val trisCount = vertsCount / 3\n//\n//    val EPS = 1e-8f\n//\n//    val e1 = Vec3(0f, 0f, 0f)\n//    val e2 = Vec3(0f, 0f, 0f)\n//\n//    val pvec = Vec3(0f, 0f, 0f)\n//    val tvec = Vec3(0f, 0f, 0f)\n//    val qvec = Vec3(0f, 0f, 0f)\n//\n//    val v0 = Vec3()\n//    val v1 = Vec3()\n//    val v2 = Vec3()\n//\n//    val res = Vec3()\n//    res.setNaN()\n//\n//    for (tri in 0 until trisCount) {\n//        v0.x = mesh.posBuf[tri * 9 + 0]\n//        v0.y = mesh.posBuf[tri * 9 + 1]\n//        v0.z = mesh.posBuf[tri * 9 + 2]\n//\n//        v1.x = mesh.posBuf[tri * 9 + 3]\n//        v1.y = mesh.posBuf[tri * 9 + 4]\n//        v1.z = mesh.posBuf[tri * 9 + 5]\n//\n//        v2.x = mesh.posBuf[tri * 9 + 6]\n//        v2.y = mesh.posBuf[tri * 9 + 7]\n//        v2.z = mesh.posBuf[tri * 9 + 8]\n//\n//        e1.x = v1.x - v0.x\n//        e1.y = v1.y - v0.y\n//        e1.z = v1.z - v0.z\n//\n//        e2.x = v2.x - v0.x\n//        e2.y = v2.y - v0.y\n//        e2.z = v2.z - v0.z\n//\n//        pvec.setCross(rd, e2)\n//        val det = dot(e1, pvec)\n//\n//        // Ray is parallel to plane\n//        if (det < EPS && det > -EPS) {\n//            continue\n//        }\n//\n//        val inv_det = 1.0f / det\n//\n//        tvec.x = ro.x - v0.x\n//        tvec.y = ro.y - v0.y\n//        tvec.z = ro.z - v0.z\n//\n//        val u = dot(tvec, pvec) * inv_det;\n//        if (u < 0.0f || u > 1.0f) {\n//            continue\n//        }\n//\n//        qvec.setCross(tvec, e1)\n//\n//        val v = dot(rd, qvec) * inv_det;\n//        if (v < 0.0f || u + v > 1.0f) {\n//            continue\n//        }\n//\n//        res.set(rd)\n//        res.normalize()\n//        res *= (dot(e2, qvec) * inv_det)\n//        res += ro\n//\n//        res.setMult(M, res)\n//        return res\n//    }\n//\n//    return res\n//}\n\nfun min(a: Float, b: Float, c: Float) = min(min(a, b), c)\nfun max(a: Float, b: Float, c: Float) = max(max(a, b), c)\n\nclass AABB {\n    val min = Vec3()\n    val max = Vec3()\n\n    fun of(v1: Vec3, v2: Vec3, v3: Vec3) {\n        min.set(min(v1.x, v2.x, v3.x), min(v1.y, v2.y, v3.y), min(v1.z, v2.z, v3.z))\n        max.set(max(v1.x, v2.x, v3.x), max(v1.y, v2.y, v3.y), max(v1.z, v2.z, v3.z))\n    }\n\n    fun of(v1: Vec3, v2: Vec3) {\n        min.set(min(v1.x, v2.x), min(v1.y, v2.y), min(v1.z, v2.z))\n        max.set(max(v1.x, v2.x), max(v1.y, v2.y), max(v1.z, v2.z))\n    }\n\n    fun of(ray: Ray) = with(ray) {\n        min.set(min(origin.x, origin.x + dir.x), min(origin.y, origin.y + dir.y), min(origin.z, origin.z + dir.z))\n        max.set(max(origin.x, origin.x + dir.x), max(origin.y, origin.y + dir.y), max(origin.z, origin.z + dir.z))\n    }\n\n    override fun toString() = \"AABB (${min.x}, ${min.y}, ${min.z}) - (${max.x}, ${max.y}, ${max.z})\"\n}\n\nfun intersects(a: AABB, b: AABB): Boolean {\n    if (a.max[0] < b.min[0] || a.min[0] > b.max[0]) return false;\n    if (a.max[1] < b.min[1] || a.min[1] > b.max[1]) return false;\n    if (a.max[2] < b.min[2] || a.min[2] > b.max[2]) return false;\n    return true\n}\n\n/*non optimized version - intersecting ray with transformed entity */\nfun intersectNonOptimizedNearest(ray: Ray, mesh: Mesh, modelMat: Mat4, maxDist: Float = 1E6f): Vec3 {\n\n    val M = Mat4()\n    M.assign(modelMat)\n\n    val nearestIntersection = Vec3()\n    nearestIntersection.setNaN()\n    var nearestDist = 1E20f\n\n    val vertsCount = mesh.posBuf.length() / 3\n    val trisCount = vertsCount / 3\n\n    val EPS = 1e-8f\n\n    val e1 = Vec3(0f, 0f, 0f)\n    val e2 = Vec3(0f, 0f, 0f)\n\n    val pvec = Vec3(0f, 0f, 0f)\n    val tvec = Vec3(0f, 0f, 0f)\n    val qvec = Vec3(0f, 0f, 0f)\n\n    val dirNormalized = Vec3()\n    dirNormalized.set(ray.dir)\n    dirNormalized.normalize()\n\n    val v0 = Vec3()\n    val v1 = Vec3()\n    val v2 = Vec3()\n\n    val res = Vec3()\n    res.setZero()\n\n    val triAABB = AABB()\n    val rayAABB = AABB()\n\n    for (tri in 0 until trisCount) {\n\n        v0.x = mesh.posBuf[tri * 9 + 0]\n        v0.y = mesh.posBuf[tri * 9 + 1]\n        v0.z = mesh.posBuf[tri * 9 + 2]\n\n        v1.x = mesh.posBuf[tri * 9 + 3]\n        v1.y = mesh.posBuf[tri * 9 + 4]\n        v1.z = mesh.posBuf[tri * 9 + 5]\n\n        v2.x = mesh.posBuf[tri * 9 + 6]\n        v2.y = mesh.posBuf[tri * 9 + 7]\n        v2.z = mesh.posBuf[tri * 9 + 8]\n\n        v0.setMult(M, v0)\n        v1.setMult(M, v1)\n        v2.setMult(M, v2)\n\n        triAABB.of(v0, v1, v2)\n        rayAABB.of(ray)\n        PERF_TRACKER.track(\"earlyRT\")\n//        if (!intersects(triAABB, rayAABB)) continue\n//        PERF_TRACKER.track(\"lateRT\")\n\n//        println(v0)\n//        println(v1)\n//        println(v2)\n\n        e1.setDiff(v1, v0)\n        e2.setDiff(v2, v0)\n\n        pvec.setCross(dirNormalized, e2)\n        val det = dot(e1, pvec)\n\n        //   \n        if (det < EPS && det > -EPS) {\n            res.setNaN()\n            continue\n        }\n\n        val inv_det = 1.0f / det\n\n        tvec.setDiff(ray.origin, v0)\n\n        val u = dot(tvec, pvec) * inv_det;\n        if (u < 0.0f || u > 1.0f) {\n            res.setNaN()\n            continue\n        }\n\n        qvec.setCross(tvec, e1)\n\n        val v = dot(dirNormalized, qvec) * inv_det;\n        if (v < 0.0f || u + v > 1.0f) {\n            res.setNaN()\n            continue\n        }\n\n        res.set(dirNormalized)\n        res *= (dot(e2, qvec) * inv_det)\n        res += ray.origin\n\n        if (res.isNotNaN() && distSq(ray.origin, res) <= ray.dir.normSq()) {\n\n//            if (!intersects(triAABB, rayAABB)) {\n//                println(\"why aabb not working here\")\n//                val iii = intersects(triAABB, rayAABB)\n//            }\n\n            val d = dist(ray.origin, res)\n            if (d < nearestDist) {\n                nearestIntersection.set(res)\n                nearestDist = d\n            }\n        }\n    }\n\n//    if(nearestIntersection.isNotNaN()) {\n//        val inters = intersects(triAABB, rayAABB)\n//        println(inters)\n//    }\n\n\n    return nearestIntersection\n}\n\nclass Sphere(var r: Float = 0.03f, val pos: Vec3 = Vec3(0.0f, 0.0f, 0.0f)) {\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    override fun toString(): String {\n        return \"Sphere r=${r}, pos=${pos}\"\n    }\n}\n\nclass Plane(val origin: Vec3, val a: Vec3, val b: Vec3) {\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val n = Vec3().apply { setCross(a, b) }\n}\n\n\nprivate val origin_pos_tmp_intersect = Vec3()\nfun Vec3.intersect(ray: Ray, sphere: Sphere) {\n\n    val a = ray.dir.normSq()\n\n    val origin_pos = origin_pos_tmp_intersect\n    origin_pos.setDiff(ray.origin, sphere.pos)\n\n    val b = 2.0f * dot(ray.dir, origin_pos)\n    val c = distSq(ray.origin, sphere.pos) - sq(sphere.r)\n\n    val d = sq(b) - 4.0f * a * c\n\n    if (d >= 0.0f) {\n        val t = (-b - sqrt(d)) / 2.0f / a\n\n        this.setZero()\n        this.add(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        setNaN()\n    }\n}\n\nprivate val origin_pos_tmp_intersect2 = Vec3()\n\nfun Vec3.intersect(ray: Ray, sphere: Sphere, mat: Mat4) {\n\n    val a = ray.dir.normSq()\n\n    val origin_pos = origin_pos_tmp_intersect2\n\n    val r00 = Vec3()\n    r00.setMultFree(mat, Vec3(sphere.r, 0f, 0f))\n    val r = r00.norm()\n\n    val p = Vec3()\n\n    p.setMult(mat, sphere.pos)\n    origin_pos.setDiff(ray.origin, p)\n\n    val b = 2.0f * dot(ray.dir, origin_pos)\n    val c = distSq(ray.origin, p) - sq(r)\n\n    val d = sq(b) - 4.0f * a * c\n\n    if (d >= 0.0f) {\n        val t = (-b - sqrt(d)) / 2.0f / a\n\n        this.setZero()\n        this.add(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        setNaN()\n    }\n\n}\n\nfun Vec3.intersect(ray: Ray, plane: Plane) {\n    val rox = ray.origin.x\n    val roy = ray.origin.y\n    val roz = ray.origin.z\n\n    val rdx = ray.dir.x\n    val rdy = ray.dir.y\n    val rdz = ray.dir.z\n\n    val pox = plane.origin.x\n    val poy = plane.origin.y\n    val poz = plane.origin.z\n\n    val pax = plane.a.x\n    val pay = plane.a.y\n    val paz = plane.a.z\n\n    val pbx = plane.b.x\n    val pby = plane.b.y\n    val pbz = plane.b.z\n\n    val t = -(pbx * (pay * (roz - poz) - paz * roy + paz * poy) + pax * (pby * (poz - roz) + pbz * roy - pbz * poy) + (paz * pby - pay * pbz) * rox + (pay * pbz - paz * pby) * pox) /\n            (pax * (pbz * rdy - pby * rdz) + pbx * (pay * rdz - paz * rdy) + (paz * pby - pay * pbz) * rdx)\n\n\n    if (t >= 0.0f) {\n        this.set(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        return setNaN()\n    }\n}\n\nfun Vec3.intersect(ray: Ray, plane: Plane, m: Mat4) {\n    val rox = ray.origin.x\n    val roy = ray.origin.y\n    val roz = ray.origin.z\n\n    val rdx = ray.dir.x\n    val rdy = ray.dir.y\n    val rdz = ray.dir.z\n\n    val po = Vec3()\n    po.setMult(m, plane.origin)\n\n    val pa = Vec3()\n    pa.setMultFree(m, plane.a)\n\n    val pb = Vec3()\n    pb.setMultFree(m, plane.b)\n\n    val pox = po.x\n    val poy = po.y\n    val poz = po.z\n\n    val pax = pa.x\n    val pay = pa.y\n    val paz = pa.z\n\n    val pbx = pb.x\n    val pby = pb.y\n    val pbz = pb.z\n\n    val t = -(pbx * (pay * (roz - poz) - paz * roy + paz * poy) + pax * (pby * (poz - roz) + pbz * roy - pbz * poy) + (paz * pby - pay * pbz) * rox + (pay * pbz - paz * pby) * pox) /\n            (pax * (pbz * rdy - pby * rdz) + pbx * (pay * rdz - paz * rdy) + (paz * pby - pay * pbz) * rdx)\n\n    if (t >= 0.0f) {\n        this.set(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        return setNaN()\n    }\n}\n\nfun Vec3.intersect3(ray: Ray, plane: Plane) {\n\n    val rox = ray.origin.x\n    val roy = ray.origin.y\n    val roz = ray.origin.z\n\n    val rdx = ray.dir.x\n    val rdy = ray.dir.y\n    val rdz = ray.dir.z\n\n    val pox = plane.origin.x\n    val poy = plane.origin.y\n    val poz = plane.origin.z\n\n    val pax = plane.a.x\n    val pay = plane.a.y\n    val paz = plane.a.z\n\n    val pbx = plane.b.x\n    val pby = plane.b.y\n    val pbz = plane.b.z\n\n    val t = -(pbx * (pay * (roz - poz) - paz * roy + paz * poy) + pax * (pby * (poz - roz) + pbz * roy - pbz * poy) + (paz * pby - pay * pbz) * rox + (pay * pbz - paz * pby) * pox) /\n            (pax * (pbz * rdy - pby * rdz) + pbx * (pay * rdz - paz * rdy) + (paz * pby - pay * pbz) * rdx)\n\n\n    if (t >= 0.0f) {\n        this.set(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        return setNaN()\n    }\n}\n","package kmptemplate.input\n\nimport kmptemplate.ui.UiEvent\n\nexpect class Key\n\nexpect val KEY_Q: Key\nexpect val KEY_W: Key\nexpect val KEY_E: Key\nexpect val KEY_R: Key\nexpect val KEY_T: Key\nexpect val KEY_Y: Key\nexpect val KEY_U: Key\nexpect val KEY_I: Key\nexpect val KEY_O: Key\nexpect val KEY_P: Key\n\nexpect val KEY_A: Key\nexpect val KEY_S: Key\nexpect val KEY_D: Key\nexpect val KEY_F: Key\nexpect val KEY_G: Key\nexpect val KEY_H: Key\nexpect val KEY_J: Key\nexpect val KEY_K: Key\nexpect val KEY_L: Key\n\nexpect val KEY_Z: Key\nexpect val KEY_X: Key\nexpect val KEY_C: Key\nexpect val KEY_V: Key\nexpect val KEY_B: Key\nexpect val KEY_N: Key\nexpect val KEY_M: Key\n\nexpect val KEY_ARROW_UP: Key\nexpect val KEY_ARROW_DOWN: Key\nexpect val KEY_ARROW_LEFT: Key\nexpect val KEY_ARROW_RIGHT: Key\n\nexpect val KEY_ENTER: Key\nexpect val KEY_SPACE: Key\nexpect val KEY_BACKSPACE: Key\n\n\nabstract class Keyboard {\n\n    companion object {\n        val ALL_KEYS = arrayOf(\n            KEY_Q,\n            KEY_W,\n            KEY_E,\n            KEY_R,\n            KEY_T,\n            KEY_Y,\n            KEY_U,\n            KEY_I,\n            KEY_O,\n            KEY_P,\n\n            KEY_A,\n            KEY_S,\n            KEY_D,\n            KEY_F,\n            KEY_G,\n            KEY_H,\n            KEY_J,\n            KEY_K,\n            KEY_L,\n\n            KEY_Z,\n            KEY_X,\n            KEY_C,\n            KEY_V,\n            KEY_B,\n            KEY_N,\n            KEY_M,\n\n            KEY_ARROW_UP,\n            KEY_ARROW_DOWN,\n            KEY_ARROW_LEFT,\n            KEY_ARROW_RIGHT,\n\n            KEY_ENTER,\n            KEY_SPACE,\n            KEY_BACKSPACE\n        )\n    }\n\n    abstract fun pressed(key: Key): Boolean\n    abstract fun justPressed(key: Key): Boolean\n    abstract fun justReleased(key: Key): Boolean\n    abstract fun pollKeyboard()\n\n    abstract fun pollMouse()\n    abstract fun mousePressed(btn: Int): Boolean\n    abstract fun mouseCoords(): Pair<Double, Double>\n    abstract fun mouseJustPressed(btn: Int): Boolean\n    abstract fun mouseJustReleased(btn: Int): Boolean\n\n    abstract fun anyKeyJustPressed(): Boolean\n\n    val events = ArrayList<UiEvent>()\n    fun notifyEvent(event: UiEvent) {\n        events.add(event)\n    }\n\n    fun forEvents(codeblock: (UiEvent) -> Unit) {\n        for (event in events) {\n            if (!event.consumed) {\n                codeblock(event)\n            }\n        }\n    }\n\n    fun forTouchedPointers(codeblock: (x: Float, y: Float, pid: Int) -> Unit) {\n\n        var countTouched = 0\n        for (pointerId in coordX.indices) {\n            if (!coordX[pointerId].isNaN()) {\n                codeblock(coordX[pointerId], coordY[pointerId], pointerId)\n//                print(\"touched ${pointerId}\")\n                countTouched++\n            }\n        }\n\n//        if (countTouched > 0) {\n//            println()\n//        }\n    }\n\n    private var coordX = FloatArray(10) { Float.NaN }\n    private var coordY = FloatArray(10) { Float.NaN }\n\n    private var mouseX = 0f\n    private var mouseY = 0f\n\n    fun translateEventsToState() {\n        forEvents { event ->\n\n//            println(event)\n//            G_CONSOLE.println { event.toString() }\n\n            if (event.type == UiEvent.MOUSE_DOWN) {\n                mouseX = event.x\n                mouseY = event.y\n            }\n\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                mouseX = event.x\n                mouseY = event.y\n            }\n\n            if (event.type == UiEvent.MOUSE_UP) {\n                mouseX = event.x\n                mouseY = event.y\n            }\n\n            if (event.type == UiEvent.TOUCH_DOWN) {\n                coordX[event.pointerId] = event.x\n                coordY[event.pointerId] = event.y\n            }\n\n            if (event.type == UiEvent.POINTER_DOWN) {\n                coordX[event.pointerId] = event.x\n                coordY[event.pointerId] = event.y\n            }\n\n            if (event.type == UiEvent.POINTER_MOVE) {\n                coordX[event.pointerId] = event.x\n                coordY[event.pointerId] = event.y\n            }\n\n            if (event.type == UiEvent.POINTER_UP) {\n                coordX[event.pointerId] = Float.NaN\n                coordY[event.pointerId] = Float.NaN\n            }\n\n            if (event.type == UiEvent.TOUCH_UP) {\n                coordX[event.pointerId] = Float.NaN\n                coordY[event.pointerId] = Float.NaN\n\n                if (coordX.any { !it.isNaN() } || coordY.any { !it.isNaN() }) {\n                    println(\"warning: TOUCH_UP event but some pointer coords existing\")\n                }\n            }\n        }\n    }\n\n    fun dumpState() {\n        for (i in 0 until coordX.size) {\n            print(\"coords: \")\n            print(coordX[i])\n            print(\",\")\n            print(coordY[i])\n            print(\"    \")\n        }\n        println()\n    }\n\n    fun clearEvents() {\n        events.clear()\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n *\n * If the program that calls this function is written in a way that only valid [code] is passed as the argument,\n * using the overload that takes a [UShort] argument is preferable (`Char(intValue.toUShort())`).\n * That overload doesn't check validity of the argument, and may improve program performance when the function is called routinely inside a loop.\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun Char(code: Int): Char {\n    if (code < Char.MIN_VALUE.code || code > Char.MAX_VALUE.code) {\n        throw IllegalArgumentException(\"Invalid Char code: $code\")\n    }\n    return code.toChar()\n}\n\n/**\n * Creates a Char with the specified [code].\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun Char(code: UShort): Char\n\n/**\n * Returns the code of this Char.\n *\n * Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.\n *\n * @sample samples.text.Chars.code\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline val Char.code: Int get() = this.toInt()\n","package kmptemplate.loading\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.launch\n\ninterface Loader {\n    suspend fun add(codeblock: suspend () -> Unit)\n    suspend fun join()\n}\n\nclass ParallelLoader(val scope: CoroutineScope) : Loader {\n    private val jobs = ArrayList<Job>()\n    override suspend fun add(codeblock: suspend () -> Unit) {\n        val job = scope.launch {\n            codeblock()\n        }\n\n        jobs.add(job)\n    }\n\n    override suspend fun join() {\n        for (job in jobs) {\n            job.join()\n        }\n    }\n}\n\nclass SequentialLoader : Loader {\n    val jobs = ArrayList<Job>()\n    override suspend fun add(codeblock: suspend () -> Unit) {\n        codeblock()\n    }\n\n    override suspend fun join() {\n    }\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.sqrt\nimport kotlin.math.tan\n\nclass Mat4 {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    companion object {\n        const val SZ = 4\n\n        val IDENT = Mat4().apply { setIdentity() }\n    }\n\n    val data = FloatArray(SZ * SZ)\n\n    fun assign(m: Mat4) {\n        m.data.copyInto(data)\n    }\n\n    fun setZero() {\n        data.fill(0.0f)\n    }\n\n    fun setIdentity() {\n        data.fill(0.0f)\n        var pos = 0\n        for (i in 0 until SZ) {\n            data[pos] = 1.0f\n            pos += SZ + 1\n        }\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun get(col: Int, row: Int): Float {\n        return data[col * SZ + row]\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun set(col: Int, row: Int, v: Float) {\n        data[col * SZ + row] = v\n    }\n\n    fun setTranslate(tx: Float, ty: Float, tz: Float) {\n        setIdentity()\n        data[12] = tx\n        data[13] = ty\n        data[14] = tz\n    }\n\n    fun setTranslate(t: Vec3) {\n        setTranslate(t[0], t[1], t[2])\n    }\n\n    //https://wikimedia.org/api/rest_v1/media/math/render/svg/7dc67eaa6d74f6629767726f854a5ff8bf7e5477\n    fun setRotate(a: Float, x: Float, y: Float, z: Float) {\n        setIdentity()\n\n        val s = sin(a)\n        val c = cos(a)\n        val oc = 1.0f - c\n\n        data[0] = c + oc * x * x\n        data[1] = oc * y * x + s * z\n        data[2] = oc * z * x - s * y\n\n        data[4] = oc * x * y - s * z\n        data[5] = c + oc * y * y\n        data[6] = oc * z * y + s * x\n\n        data[8] = oc * x * z + s * y\n        data[9] = oc * y * z - s * x\n        data[10] = c + oc * z * z\n    }\n\n    fun setRotate(a: Float, v: Vec3) {\n        setRotate(a, v.x, v.y, v.z)\n    }\n\n    fun setScale(sx: Float, sy: Float, sz: Float) {\n        setIdentity()\n        data[0] = sx\n        data[5] = sy\n        data[10] = sz\n        data[15] = 1.0f\n    }\n\n    fun setScale(s: Float) = setScale(s, s, s)\n\n    /**\n     *     this = A*B\n     *     this can be A and/or B\n     */\n    fun setMult(A: Mat4, B: Mat4) {\n        val a = A.data\n        val b = B.data\n\n        //doing like this saves from allocating array and alsow allows A and/or B to be the same as this\n        val c0 = b[3] * a[12] + b[2] * a[8] + b[1] * a[4] + a[0] * b[0]\n        val c1 = b[3] * a[13] + b[2] * a[9] + b[1] * a[5] + b[0] * a[1]\n        val c2 = b[3] * a[14] + b[2] * a[10] + b[1] * a[6] + b[0] * a[2]\n        val c3 = b[3] * a[15] + b[2] * a[11] + b[1] * a[7] + b[0] * a[3]\n        val c4 = b[7] * a[12] + b[6] * a[8] + a[4] * b[5] + a[0] * b[4]\n        val c5 = b[7] * a[13] + b[6] * a[9] + a[5] * b[5] + a[1] * b[4]\n        val c6 = b[7] * a[14] + b[6] * a[10] + b[5] * a[6] + a[2] * b[4]\n        val c7 = b[7] * a[15] + b[6] * a[11] + b[5] * a[7] + a[3] * b[4]\n        val c8 = b[11] * a[12] + a[8] * b[10] + a[4] * b[9] + a[0] * b[8]\n        val c9 = b[11] * a[13] + a[9] * b[10] + a[5] * b[9] + a[1] * b[8]\n        val c10 = b[11] * a[14] + a[10] * b[10] + a[6] * b[9] + a[2] * b[8]\n        val c11 = b[11] * a[15] + b[10] * a[11] + a[7] * b[9] + a[3] * b[8]\n        val c12 = a[12] * b[15] + a[8] * b[14] + a[4] * b[13] + a[0] * b[12]\n        val c13 = a[13] * b[15] + a[9] * b[14] + a[5] * b[13] + a[1] * b[12]\n        val c14 = a[14] * b[15] + a[10] * b[14] + a[6] * b[13] + a[2] * b[12]\n        val c15 = a[15] * b[15] + a[11] * b[14] + a[7] * b[13] + a[3] * b[12]\n\n        val c = this.data\n\n        c[0] = c0\n        c[1] = c1\n        c[2] = c2\n        c[3] = c3\n        c[4] = c4\n        c[5] = c5\n        c[6] = c6\n        c[7] = c7\n        c[8] = c8\n        c[9] = c9\n        c[10] = c10\n        c[11] = c11\n        c[12] = c12\n        c[13] = c13\n        c[14] = c14\n        c[15] = c15\n    }\n\n    fun setLookAt(eye: Vec3, center: Vec3, up: Vec3) {\n        // f = normalize(center - eye)\n        var fX = center.x - eye.x\n        var fY = center.y - eye.y\n        var fZ = center.z - eye.z\n        var inv = 1f / sqrt(fX * fX + fY * fY + fZ * fZ)\n        fX *= inv\n        fY *= inv\n        fZ *= inv\n\n        // s = normalize(cross(f, up))\n        var sX = fY * up.z - up.y * fZ\n        var sY = fZ * up.x - up.z * fX\n        var sZ = fX * up.y - up.x * fY\n        inv = 1f / sqrt(sX * sX + sY * sY + sZ * sZ)\n        sX *= inv\n        sY *= inv\n        sZ *= inv\n\n        // u = cross(s, f)\n        val uX = sY * fZ - fY * sZ\n        val uY = sZ * fX - fZ * sX\n        val uZ = sX * fY - fX * sY\n\n        this.setIdentity()\n\n        this[0, 0] = sX\n        this[1, 0] = sY\n        this[2, 0] = sZ\n\n        this[0, 1] = uX\n        this[1, 1] = uY\n        this[2, 1] = uZ\n\n        this[0, 2] = -fX\n        this[1, 2] = -fY\n        this[2, 2] = -fZ\n\n//        res[3,0] =-dot(s, eye)\n        this[3, 0] = -(sX * eye.x + sY * eye.y + sZ * eye.z)\n\n//        res[3,1] =-dot(u, eye)\n        this[3, 1] = -(uX * eye.x + uY * eye.y + uZ * eye.z)\n\n//        res[3,2] = dot(f, eye)\n        this[3, 2] = fX * eye.x + fY * eye.y + fZ * eye.z\n    }\n\n    fun setPerspective(fovY: Float, aspect: Float, near: Float, far: Float) {\n        val tanHalfFovy = tan(fovY / 2f)\n        setZero()\n\n        this[0, 0] = 1f / (aspect * tanHalfFovy)\n        this[1, 1] = 1f / (tanHalfFovy)\n        this[2, 2] = -(far + near) / (far - near)\n        this[2, 3] = -1f\n        this[3, 2] = -(2f * far * near) / (far - near)\n    }\n\n    fun setOrtho(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) {\n        setZero()\n\n        this[0, 0] = 2f / (right - left)\n        this[1, 1] = 2f / (top - bottom)\n        this[2, 2] = 2f / (near - far)\n        this[3, 3] = 1f\n\n//        this[0, 3] = (left + right) / (left - right)\n//        this[1, 3] = (bottom + top) / (bottom - top)\n//        this[2, 3] = (near + far) / (near - far)\n\n        this[3, 0] = (left + right) / (left - right)\n        this[3, 1] = (bottom + top) / (bottom - top)\n        this[3, 2] = (near + far) / (near - far)\n\n\n    }\n\n    fun dump() {\n        for (row in 0 until SZ) {\n            for (col in 0 until SZ) {\n                print(\"${this[col, row]}\\t\\t\\t\")\n            }\n            println()\n        }\n    }\n\n}\n\nclass Mat3 {\n\n    companion object {\n        const val SZ = 3\n    }\n\n    val data = FloatArray(SZ * SZ)\n\n    fun setIdentity() {\n        data.fill(0.0f)\n        var pos = 0\n        for (i in 0 until SZ) {\n            data[pos] = 1.0f\n            pos += SZ + 1\n        }\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun get(col: Int, row: Int): Float {\n        return data[col * SZ + row]\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun set(col: Int, row: Int, v: Float) {\n        data[col * SZ + row] = v\n    }\n}\n\nclass Mat2 {\n\n    companion object {\n        const val SZ = 2\n    }\n\n    val data = FloatArray(SZ * SZ)\n\n    fun setIdentity() {\n        data.fill(0.0f)\n        var pos = 0\n        for (i in 0 until SZ) {\n            data[pos] = 1.0f\n            pos += SZ + 1\n        }\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun get(col: Int, row: Int): Float {\n        return data[col * SZ + row]\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun set(col: Int, row: Int, v: Float) {\n        data[col * SZ + row] = v\n    }\n}\n\n\n/**\nv can be this\n */\nfun Vec3.setMult(m: Mat4, v: Vec3) {\n    val a = m.data\n    val newX = a[12] + v[2] * a[8] + v[1] * a[4] + a[0] * v[0]\n    val newY = a[13] + v[2] * a[9] + v[1] * a[5] + v[0] * a[1]\n    val newZ = a[14] + v[2] * a[10] + v[1] * a[6] + v[0] * a[2]\n    set(newX, newY, newZ)\n}\n\nfun Vec3.setMultFree(m: Mat4, v: Vec3) {\n    val a = m.data\n    val newX = v[2] * a[8] + v[1] * a[4] + a[0] * v[0]\n    val newY = v[2] * a[9] + v[1] * a[5] + v[0] * a[1]\n    val newZ = v[2] * a[10] + v[1] * a[6] + v[0] * a[2]\n    set(newX, newY, newZ)\n}\n\nfun inversed(res: Mat4, m: Mat4): Mat4 {\n\n    val c00 = m[2, 2] * m[3, 3] - m[3, 2] * m[2, 3]\n    val c02 = m[1, 2] * m[3, 3] - m[3, 2] * m[1, 3]\n    val c03 = m[1, 2] * m[2, 3] - m[2, 2] * m[1, 3]\n\n    val c04 = m[2, 1] * m[3, 3] - m[3, 1] * m[2, 3]\n    val c06 = m[1, 1] * m[3, 3] - m[3, 1] * m[1, 3]\n    val c07 = m[1, 1] * m[2, 3] - m[2, 1] * m[1, 3]\n\n    val c08 = m[2, 1] * m[3, 2] - m[3, 1] * m[2, 2]\n    val c10 = m[1, 1] * m[3, 2] - m[3, 1] * m[1, 2]\n    val c11 = m[1, 1] * m[2, 2] - m[2, 1] * m[1, 2]\n\n    val c12 = m[2, 0] * m[3, 3] - m[3, 0] * m[2, 3]\n    val c14 = m[1, 0] * m[3, 3] - m[3, 0] * m[1, 3]\n    val c15 = m[1, 0] * m[2, 3] - m[2, 0] * m[1, 3]\n\n    val c16 = m[2, 0] * m[3, 2] - m[3, 0] * m[2, 2]\n    val c18 = m[1, 0] * m[3, 2] - m[3, 0] * m[1, 2]\n    val c19 = m[1, 0] * m[2, 2] - m[2, 0] * m[1, 2]\n\n    val c20 = m[2, 0] * m[3, 1] - m[3, 0] * m[2, 1]\n    val c22 = m[1, 0] * m[3, 1] - m[3, 0] * m[1, 1]\n    val c23 = m[1, 0] * m[2, 1] - m[2, 0] * m[1, 1]\n\n    val i00 = +(m[1, 1] * c00 - m[1, 2] * c04 + m[1, 3] * c08)\n    val i01 = -(m[0, 1] * c00 - m[0, 2] * c04 + m[0, 3] * c08)\n    val i02 = +(m[0, 1] * c02 - m[0, 2] * c06 + m[0, 3] * c10)\n    val i03 = -(m[0, 1] * c03 - m[0, 2] * c07 + m[0, 3] * c11)\n\n    val i10 = -(m[1, 0] * c00 - m[1, 2] * c12 + m[1, 3] * c16)\n    val i11 = +(m[0, 0] * c00 - m[0, 2] * c12 + m[0, 3] * c16)\n    val i12 = -(m[0, 0] * c02 - m[0, 2] * c14 + m[0, 3] * c18)\n    val i13 = +(m[0, 0] * c03 - m[0, 2] * c15 + m[0, 3] * c19)\n\n    val i20 = +(m[1, 0] * c04 - m[1, 1] * c12 + m[1, 3] * c20)\n    val i21 = -(m[0, 0] * c04 - m[0, 1] * c12 + m[0, 3] * c20)\n    val i22 = +(m[0, 0] * c06 - m[0, 1] * c14 + m[0, 3] * c22)\n    val i23 = -(m[0, 0] * c07 - m[0, 1] * c15 + m[0, 3] * c23)\n\n    val i30 = -(m[1, 0] * c08 - m[1, 1] * c16 + m[1, 2] * c20)\n    val i31 = +(m[0, 0] * c08 - m[0, 1] * c16 + m[0, 2] * c20)\n    val i32 = -(m[0, 0] * c10 - m[0, 1] * c18 + m[0, 2] * c22)\n    val i33 = +(m[0, 0] * c11 - m[0, 1] * c19 + m[0, 2] * c23)\n\n    val oneOverDet = 1.0f / (m[0, 0] * i00 + m[0, 1] * i10 + m[0, 2] * i20 + m[0, 3] * i30)\n\n    res[0, 0] = i00 * oneOverDet\n    res[0, 1] = i01 * oneOverDet\n    res[0, 2] = i02 * oneOverDet\n    res[0, 3] = i03 * oneOverDet\n\n    res[1, 0] = i10 * oneOverDet\n    res[1, 1] = i11 * oneOverDet\n    res[1, 2] = i12 * oneOverDet\n    res[1, 3] = i13 * oneOverDet\n\n    res[2, 0] = i20 * oneOverDet\n    res[2, 1] = i21 * oneOverDet\n    res[2, 2] = i22 * oneOverDet\n    res[2, 3] = i23 * oneOverDet\n\n    res[3, 0] = i30 * oneOverDet\n    res[3, 1] = i31 * oneOverDet\n    res[3, 2] = i32 * oneOverDet\n    res[3, 3] = i33 * oneOverDet\n\n    return res\n}\n\nfun Mat4.rebase(v1: Vec3, v2: Vec3, v3: Vec3, w1: Vec3, w2: Vec3, w3: Vec3, p: Vec3, q: Vec3) {\n    val V = Mat4()\n    val W = Mat4()\n\n    V.data[0] = v1.x\n    V.data[1] = v1.y\n    V.data[2] = v1.z\n    V.data[3] = 0f\n\n    V.data[4] = v2.x\n    V.data[5] = v2.y\n    V.data[6] = v2.z\n    V.data[7] = 0f\n\n    V.data[8] = v3.x\n    V.data[9] = v3.y\n    V.data[10] = v3.z\n    V.data[11] = 0f\n\n    V.data[12] = p.x\n    V.data[13] = p.y\n    V.data[14] = p.z\n    V.data[15] = 1f\n\n\n    W.data[0] = w1.x\n    W.data[1] = w1.y\n    W.data[2] = w1.z\n    W.data[3] = 0f\n\n    W.data[4] = w2.x\n    W.data[5] = w2.y\n    W.data[6] = w2.z\n    W.data[7] = 0f\n\n    W.data[8] = w3.x\n    W.data[9] = w3.y\n    W.data[10] = w3.z\n    W.data[11] = 0f\n\n    W.data[12] = q.x\n    W.data[13] = q.y\n    W.data[14] = q.z\n    W.data[15] = 1f\n\n    inversed(V, V)\n\n    setMult(W, V)\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\n\nclass Ray {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val origin: Vec3 = Vec3(0f, 0f, 0f)\n    val dir: Vec3 = Vec3(1f, 0f, 0f)\n\n    fun set(o: Vec3, d: Vec3) {\n        origin.assign(o)\n        dir.assign(d)\n    }\n\n    override fun toString(): String {\n        return \"Ray(origin=$origin, dir=$dir)\"\n    }\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\n\nopen class Vec4(x: Float, y: Float, z: Float, w: Float) {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val data = FloatArray(4)\n\n    var x: Float\n        get() = this.data[0]\n        set(v) {\n            this.data[0] = v\n        }\n\n    var y: Float\n        get() = this.data[1]\n        set(v) {\n            this.data[1] = v\n        }\n\n    var z: Float\n        get() = this.data[2]\n        set(v) {\n            this.data[2] = v\n        }\n\n    var w: Float\n        get() = this.data[3]\n        set(v) {\n            this.data[3] = v\n        }\n\n    init {\n        data[0] = x\n        data[1] = y\n        data[2] = z\n        data[3] = w\n    }\n\n    fun assign(v: Vec4) {\n        x = v.x\n        y = v.y\n        z = v.z\n        w = v.w\n    }\n\n    fun toVec3(): Vec3 {\n        return Vec3(x / w, y / w, z / w)\n    }\n\n    override fun toString(): String {\n        return \"Vec4(${data})\"\n    }\n}\n\n","package kmptemplate.pool\n\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\n\nobject VecPool {\n\n    val size: Int = 4096\n\n    private val rays = Array(size) { Ray() }\n    private val arr3 = Array(size) { Vec3() }\n    private var i3 = 0\n    private var r = 0\n\n    fun obtainVec3(): Vec3 {\n        return arr3[i3++]\n    }\n\n    fun obtainVec3(v: Vec3): Vec3 {\n        val res = arr3[i3++]\n        res.set(v)\n        return res\n    }\n\n    fun reset() {\n//        println(\"rays obtained: ${r}\")\n//        println(\"vec3 obtained: ${i3}\")\n\n        i3 = 0\n        r = 0\n    }\n\n    fun obtainVec3(x: Float, y: Float, z: Float): Vec3 {\n        val res = arr3[i3++]\n        res.set(x, y, z)\n        return res\n    }\n\n    fun obtainRay(): Ray {\n        return rays[r++]\n    }\n}","package kmptemplate.sound\n\nabstract class SoundBuffer {\n}\n\nclass Playback(val start: Long, val soundBuffer: SoundBuffer)\n\nabstract class SoundManager() {\n    abstract fun play(sound: SoundBuffer): Playback\n\n    abstract fun stop(playback: Playback)\n    abstract suspend fun loadSoundBuf(path: String): SoundBuffer\n}","package kmptemplate.storage\n\nabstract class Storage {\n    abstract fun set(k: String, v: String)\n    abstract fun get(k: String): String?\n\n    abstract fun remove(k: String)\n    abstract fun clear()\n\n    fun setLong(k: String, v: Long) {\n        set(k, v.toString())\n    }\n\n    fun getLong(k: String, defValue: Long): Long {\n        return get(k)?.toLongOrNull() ?: defValue\n    }\n\n    fun setInt(k: String, v: Int) {\n        set(k, v.toString())\n    }\n\n    fun getInt(k: String, defValue: Int): Int {\n        return get(k)?.toIntOrNull() ?: defValue\n    }\n\n    fun setBoolean(k: String, v: Boolean) {\n        set(k, v.toString())\n    }\n\n    fun getBoolean(k: String, defValue: Boolean): Boolean {\n        return get(k)?.toBooleanStrictOrNull() ?: defValue\n    }\n\n    fun setIntList(k: String, list: List<Int>) {\n        val v = list.joinToString(separator = \",\")\n        set(k, v)\n    }\n\n    fun getIntList(k: String): List<Int> {\n        val v = get(k)\n        return v?.split(',')?.map { it.toInt() } ?: emptyList()\n    }\n}","package kmptemplate.tetris\n\nabstract class Ads {\n    abstract fun showInterstitial()\n    abstract fun showRewarded(\n        onReward: () -> Unit,\n        onOpen: () -> Unit = {},\n        onClose: () -> Unit = {},\n        onError: (Any) -> Unit = {}\n    )\n}\n\nclass NoAds : Ads() {\n    override fun showInterstitial() {\n    }\n\n    override fun showRewarded(onReward: () -> Unit, onOpen: () -> Unit, onClose: () -> Unit, onError: (Any) -> Unit) {\n    }\n}\n\nclass PrintAds : Ads() {\n    override fun showInterstitial() {\n        println(\"Showing interstitial ads\")\n    }\n\n    override fun showRewarded(onReward: () -> Unit, onOpen: () -> Unit, onClose: () -> Unit, onError: (Any) -> Unit) {\n        println(\"Showing rewarded ads\")\n        onReward()\n    }\n}","package kmptemplate.ui\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.color.COLOR_MAGENTA\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.gloo.Cam\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.fonts.calcHeight\nimport kmptemplate.gloo.fonts.calcWidth\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.immediate.ImmediateMode.Companion.ALIGN_CENTER\nimport kmptemplate.gloo.primitives.rayTriangleIntersect\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.nodes.Node\nimport kotlin.math.max\n\ntypealias UiEventType = Int\n\ndata class UiEvent(var x: Float, var y: Float, var type: UiEventType, var pointerId: Int, var button: Int, var dropped: List<String>?, var consumed: Boolean, var dx: Float = 0.0f, var dy: Float = 0.0f, var droppedImage: DroppedImage? = null) {\n\n    init {\n        PERF_TRACKER.trackUiEvent()\n    }\n\n    companion object {\n        val MOUSE_DOWN = 1\n        val MOUSE_UP = 2\n        val MOUSE_MOVE = 3\n\n        val MOUSE_BUTTON_LEFT = 1\n        val MOUSE_BUTTON_RIGHT = 2\n        val MOUSE_BUTTON_MIDDLE = 3\n\n        val TOUCH_DOWN = 4\n        val POINTER_DOWN = 5\n        val POINTER_MOVE = 6\n        val POINTER_UP = 7\n        val TOUCH_UP = 8\n\n        val FOCUSED = 10\n        val UNFOCUSED = 11\n\n        val FILE_DROPPED = 12\n\n        val MOUSE_ENTER = 13\n        val MOUSE_LEAVE = 14\n\n        val SCROLL = 15\n\n        fun eventTypeToString(type: UiEventType) = when (type) {\n            MOUSE_DOWN -> \"MOUSE_DOWN\"\n            MOUSE_UP -> \"MOUSE_UP\"\n            MOUSE_MOVE -> \"MOUSE_MOVE\"\n\n            TOUCH_DOWN -> \"TOUCH_DOWN\"\n            POINTER_DOWN -> \"POINTER_DOWN\"\n            POINTER_MOVE -> \"MOVE\"\n            POINTER_UP -> \"POINTER_UP\"\n            TOUCH_UP -> \"TOUCH_UP\"\n\n            FOCUSED -> \"FOCUSED\"\n            UNFOCUSED -> \"UNFOCUSED\"\n\n            FILE_DROPPED -> \"FILE_DROPPED\"\n\n            MOUSE_ENTER -> \"MOUSE_ENTER\"\n            MOUSE_LEAVE -> \"MOUSE_LEAVE\"\n\n            SCROLL -> \"SCROLL\"\n\n            else -> type.toString()\n        }\n    }\n\n    fun consume() {\n        consumed = true\n    }\n\n    override fun toString(): String {\n        return \"UiEvent(${eventTypeToString(type)}, x=${x.toInt()}, y=${y.toInt()}, ptr=$pointerId)\"\n    }\n}\n\n\nobject UiEventPool {\n    val size: Int = 2048\n\n    private val arr = Array(size) { UiEvent(0f, 0f, 0, 0, 0, null, false) }\n    private var i = 0\n\n    fun obtain(x: Float, y: Float, type: UiEventType, pointerId: Int, button: Int, dropped: List<String>? = null, dx: Float = 0.0f, dy: Float = 0.0f, droppedImage: DroppedImage? = null): UiEvent {\n        val event = arr[i++]\n        event.x = x\n        event.y = y\n        event.type = type\n        event.pointerId = pointerId\n        event.button = button\n        event.dropped = dropped\n        event.consumed = false\n        event.dx = dx\n        event.dy = dy\n        event.droppedImage = droppedImage\n        return event\n    }\n\n    fun reset() {\n        i = 0\n    }\n}\n\nabstract class Widget {\n\n    var matrix = Node(Mat4().apply { setIdentity() })\n\n    var width: Float = 0f\n    var height: Float = 0f\n\n    /** x center of the widget*/\n    var x: Float = 0.0f\n\n    /** y center of the widget*/\n    var y: Float = 0.0f\n\n    val bgColor = Node(COLOR_MAGENTA)\n\n    var renderOutline = false\n\n    var drawBg = false\n\n    var visible = Node(true)\n\n    abstract fun measureSelf()\n\n    open fun layoutChilds() {}\n\n    open fun render(im: ImmediateMode, cam: Cam) {\n        if (drawBg) {\n            renderBg(im, cam)\n        }\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n\n    fun renderOutline(im: ImmediateMode, cam: Cam) {\n        im.clear()\n        im.color.set(COLOR_MAGENTA)\n\n        im.line(x - width / 2f, y - height / 2f, 0f, x + width / 2f, y - height / 2f, 0f)\n        im.line(x + width / 2f, y - height / 2f, 0f, x + width / 2f, y + height / 2f, 0f)\n        im.line(x + width / 2f, y + height / 2f, 0f, x - width / 2f, y + height / 2f, 0f)\n        im.line(x - width / 2f, y + height / 2f, 0f, x - width / 2f, y - height / 2f, 0f)\n\n        im.renderColoredLines(cam)\n    }\n\n    val renderBgColor1 = Node(Color(0.95f, 1f, 1f, 1f))\n    val renderBgColor2 = Node(Color(1f, 1f, 1f, 1f))\n    val cornerR = Node(0.3f)\n\n\n    fun renderBg(im: ImmediateMode, cam: Cam) {\n        im.clear()\n        im.renderCardNew(x - width / 2f, y - height / 2f, x + width / 2f, y + height / 2f, cornerR.value, 0.2f, renderBgColor2.value, renderBgColor1.value, cam)\n    }\n\n\n    override fun toString(): String {\n        return \"${this::class.simpleName}(width=$width, height=$height, x=$x, y=$y)\"\n    }\n\n    private val intersection1_tmp_inside = Vec3()\n    private val intersection2_tmp_inside = Vec3()\n    private val v1_tmp_inside = Vec3()\n    private val v2_tmp_inside = Vec3()\n    private val v3_tmp_inside = Vec3()\n    private val v4_tmp_inside = Vec3()\n    private val ray_tmp_inside = Ray()\n\n    fun inside(eventX: Float, eventY: Float, cam: Cam): Boolean {\n        val ray = ray_tmp_inside\n        cam.rayThrough(ray, eventX, eventY)\n\n        val intersection1 = intersection1_tmp_inside\n        val intersection2 = intersection2_tmp_inside\n\n        val v1 = v1_tmp_inside\n        val v2 = v2_tmp_inside\n        val v3 = v3_tmp_inside\n        val v4 = v4_tmp_inside\n\n        v1.set(x - width / 2f, y - height / 2f, 0f)\n        v2.set(x + width / 2f, y - height / 2f, 0f)\n        v3.set(x + width / 2f, y + height / 2f, 0f)\n        v4.set(x - width / 2f, y + height / 2f, 0f)\n\n        intersection1.rayTriangleIntersect(ray, v1, v2, v3)\n        intersection2.rayTriangleIntersect(ray, v1, v3, v4)\n\n        return intersection1.isNotNaN() || intersection2.isNotNaN()\n\n//        return x > this.x - width / 2 && x < this.x + width / 2\n//                && y > this.y - height / 2 && x < this.y + height / 2\n    }\n\n\n    open fun handleEvent(event: UiEvent, cam: Cam) {\n        val inside = inside(event.x, event.y, cam)\n        if (inside) {\n\n            if (event.type == UiEvent.TOUCH_DOWN) {\n                onTouchDown?.invoke(event)\n                event.consume()\n            }\n\n            if (event.type == UiEvent.MOUSE_DOWN) {\n                onMouseDown?.invoke(event)\n                event.consume()\n            }\n\n            if (event.type == UiEvent.TOUCH_UP) {\n                onTouchUp?.invoke(event)\n            }\n\n            if (event.type == UiEvent.MOUSE_UP) {\n                onMouseUp?.invoke(event)\n            }\n\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                onMouseEnter?.invoke(event)\n            }\n        } else {\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                onMouseLeave?.invoke(event)\n            }\n        }\n    }\n\n    var onTouchDown: ((UiEvent) -> Unit)? = null\n    var onTouchUp: ((UiEvent) -> Unit)? = null\n\n    var onMouseDown: ((UiEvent) -> Unit)? = null\n    var onMouseUp: ((UiEvent) -> Unit)? = null\n    var onMouseMove: ((UiEvent) -> Unit)? = null\n\n    var onMouseEnter: ((UiEvent) -> Unit)? = null\n    var onMouseLeave: ((UiEvent) -> Unit)? = null\n\n}\n\nabstract class Compound : Widget() {\n    val widgets = ArrayList<Widget>()\n\n    fun add(widget: Widget) {\n        widgets.add(widget)\n    }\n\n    override fun handleEvent(event: UiEvent, cam: Cam) {\n        for (widget in widgets) {\n            widget.handleEvent(event, cam)\n        }\n        super.handleEvent(event, cam)\n    }\n}\n\nclass Row : Compound() {\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        for (widget in widgets) {\n            widget.measureSelf()\n\n            width += widget.width\n            height = max(height, widget.height)\n        }\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        if (!visible.value) return\n\n        super.render(im, cam)\n\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n    }\n\n    override fun layoutChilds() {\n        val dir = +1 //left to right\n\n        var lx = x - dir * width / 2f\n        val ly = y\n        for (widget in widgets) {\n            widget.x = lx + dir * widget.width / 2f\n            widget.y = ly\n            lx += dir * widget.width\n            widget.layoutChilds()\n        }\n    }\n}\n\n\nfun row(content: (Row.() -> Unit)? = null): Row {\n    val widget = Row()\n    content?.invoke(widget)\n    return widget\n}\n\n\nfun Compound.row(content: (Row.() -> Unit)? = null): Row {\n    val widget = Row()\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nopen class Column : Compound() {\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        for (widget in widgets) {\n            widget.measureSelf()\n            height += widget.height\n            width = max(width, widget.width)\n        }\n    }\n\n    override fun layoutChilds() {\n        val dir = -1 //top to bottom\n\n        val lx = x\n        var ly = y - dir * height / 2f\n        for (widget in widgets) {\n            widget.x = lx\n            widget.y = ly + dir * widget.height / 2f\n            ly += dir * widget.height\n\n            widget.layoutChilds()\n        }\n    }\n\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n\n        super.render(im, cam)\n\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n}\n\nopen class Box : Compound() {\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        for (widget in widgets) {\n            widget.measureSelf()\n            height = max(height, widget.height)\n            width = max(width, widget.width)\n        }\n    }\n\n    override fun layoutChilds() {\n        val lx = x\n        var ly = y\n        for (widget in widgets) {\n            widget.x = lx\n            widget.y = ly\n\n            widget.layoutChilds()\n        }\n    }\n\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n\n        super.render(im, cam)\n\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n}\n\nclass Grid : Compound() {\n\n    var columns = 2\n    var rows = -1\n\n    private var cellWidth = 0.0f\n    private var cellHeight = 0.0f\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        rows = 0\n\n        for ((i, widget) in widgets.withIndex()) {\n            val newRow = i % columns == 0\n            if (newRow) {\n                rows++\n            }\n\n            widget.measureSelf()\n\n            cellWidth = max(cellWidth, widget.width)\n            cellHeight = max(cellHeight, widget.height)\n        }\n\n\n        width = cellWidth * columns\n        height = cellHeight * rows\n    }\n\n    override fun layoutChilds() {\n        val verDir = -1 //top to bottom\n\n        val horDir = 1 //left to right\n\n        val lx = x - horDir * width / 2f\n        var ly = y - verDir * height / 2f\n\n        for ((i, widget) in widgets.withIndex()) {\n\n            val col = i % columns\n            val row = i / columns\n\n            widget.x = lx + horDir * col * cellWidth + horDir * cellWidth / 2f\n            widget.y = ly + verDir * row * cellHeight + verDir * cellHeight / 2f\n\n            widget.layoutChilds()\n        }\n    }\n\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n    }\n}\n\n\nfun column(content: (Column.() -> Unit)? = null): Column {\n    val widget = Column()\n    content?.invoke(widget)\n    return widget\n}\n\nfun Compound.column(content: (Column.() -> Unit)? = null): Column {\n    val widget = Column()\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\n\nfun Compound.box(content: (Box.() -> Unit)? = null): Box {\n    val widget = Box()\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nfun Compound.grid(content: (Grid.() -> Unit)? = null): Grid {\n    val g = Grid()\n    content?.invoke(g)\n    add(g)\n    return g\n}\n\nfun grid(content: (Grid.() -> Unit)? = null): Grid {\n    val g = Grid()\n    content?.invoke(g)\n    return g\n}\n\nclass Space(w: Float, h: Float) : Widget() {\n    init {\n        width = w\n        height = h\n    }\n\n    override fun measureSelf() {\n    }\n\n    override fun layoutChilds() {\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        super.render(im, cam)\n    }\n\n}\n\nfun Compound.space(w: Float, h: Float = w, content: (Space.() -> Unit)? = null): Space {\n    val widget = Space(w, h)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\n\nclass Padding(val left: Float, val right: Float, val top: Float, val bottom: Float) : Compound() {\n    override fun measureSelf() {\n\n        require(widgets.size == 1) { \"Padding supports only one and single widget inside\" }\n        val widget = widgets[0]\n        widget.measureSelf()\n\n        width = widget.width + left + right\n        height = widget.height + top + bottom\n    }\n\n    override fun layoutChilds() {\n        require(widgets.size == 1) { \"Padding supports only single widget inside\" }\n        val widget = widgets[0]\n\n        widget.x = x - width / 2f + left + widget.width / 2f\n        widget.y = y - height / 2f + bottom + widget.height / 2f\n\n        widget.layoutChilds()\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        super.render(im, cam)\n        widgets[0].render(im, cam)\n    }\n}\n\nfun Compound.padding(left: Float, right: Float, top: Float, bottom: Float, content: (Padding.() -> Unit)? = null): Padding {\n    val widget = Padding(left, right, top, bottom)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nfun Compound.padding(p: Float, content: (Padding.() -> Unit)? = null) = padding(p, p, p, p, content)\n\nclass TextWidget(var text: Node<String>, val font: SdfFont, var fontSize: Float = 8f) : Widget() {\n    var color = Node(COLOR_WHITE)\n    var outlineColor = Node<Color?>(null)\n\n    var compress = 0.65f\n\n    constructor(text: String, font: SdfFont, fontSize: Float = 8f) :\n            this(Node(text), font, fontSize)\n\n    override fun measureSelf() {\n        width = calcWidth(text.value, fontSize, compress)\n        height = calcHeight(text.value, fontSize)\n    }\n\n    override fun layoutChilds() {\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        im.clear()\n\n        super.render(im, cam)\n\n        im.clear()\n        im.renderText(text.value, font, x, y, fontSize, color.value, cam, horAlign = ALIGN_CENTER, verAlign = ALIGN_CENTER, weight = 0.52f, compress = compress, outlineColor = outlineColor.value)\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n\n        if (DEBUG_RENDERING) {\n            im.clear()\n            im.color.set(COLOR_RED)\n            im.pivot(x, y, 0f, 1.0f)\n            im.renderColoredLines(cam)\n        }\n    }\n\n    override fun toString(): String {\n        return super.toString() + \" (text='$text', font=$font, fontSize=$fontSize)\"\n    }\n\n    companion object {\n        val DEBUG_RENDERING = false\n    }\n\n\n}\n\nfun Compound.text(text: Node<String>, font: SdfFont, fontSize: Float, content: (TextWidget.() -> Unit)? = null): TextWidget {\n    val widget = TextWidget(text, font, fontSize)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nfun Compound.text(text: String, font: SdfFont, fontSize: Float, content: (TextWidget.() -> Unit)? = null): TextWidget {\n    val widget = TextWidget(text, font, fontSize)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nclass ImageWidget(texture: Texture2D, w: Float, var h: Float) : Widget() {\n    var texture = Node(texture)\n    var color = Node(COLOR_WHITE)\n\n    var compress = 0.65f\n\n    init {\n        width = w\n        height = h\n    }\n\n    override fun measureSelf() {\n    }\n\n    override fun layoutChilds() {\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        if (!visible.value) return\n\n        im.clear()\n\n        im.pos(x - width / 2f, y - width / 2f, 0f)\n        im.pos(x + width / 2f, y - width / 2f, 0f)\n        im.pos(x + width / 2f, y + width / 2f, 0f)\n        im.texCoord(0f, 1f)\n        im.texCoord(1f, 1f)\n        im.texCoord(1f, 0f)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.pos(x - width / 2f, y - width / 2f, 0f)\n        im.pos(x + width / 2f, y + width / 2f, 0f)\n        im.pos(x - width / 2f, y + width / 2f, 0f)\n        im.texCoord(0f, 1f)\n        im.texCoord(1f, 0f)\n        im.texCoord(0f, 0f)\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.renderTex(texture.value, cam, matrix.value)\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n}\n\nfun Compound.img(texture: Texture2D, w: Float, h: Float, content: (ImageWidget.() -> Unit)? = null): ImageWidget {\n    val widget = ImageWidget(texture, w, h)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n","package kmptemplate.analytics\n\nimport kotlinx.browser.window\nimport kotlin.js.json\n\nclass JsYaMetricaAnalytics(val id: String) : Analytics() {\n\n    override fun sendEvent(event: String, map: Map<String, Any>) {\n        val w = window.asDynamic()\n\n        val arrayOfPairs = map.entries.map { Pair(it.key, it.value) }.toTypedArray()\n        val jsMap = json(*arrayOfPairs)\n\n        w.ym(id, \"reachGoal\", event, jsMap)\n    }\n}","package kmptemplate.asteroids\n\nimport kotlinx.browser.window\n\nactual val platformName: String = \"js\"\n\nprivate val mobilePlatforms = listOf(\"iPhone\", \"iPod\", \"iPad\", \"Android\", \"IEmobile\", \"Blackberry\", \"WebOS\", \"Opera Mini\", \"Opera Mobile\")\n\nfun hasTouchUi() = mobilePlatforms.any { platform ->\n    window.navigator.userAgent.contains(platform, ignoreCase = true)\n}\n\nactual fun hasHardwareKeyboard() = !hasTouchUi()\n","package kmptemplate.browser\n\nimport kotlinx.browser.document\nimport org.w3c.dom.HTMLElement\n\nfun downloadContent(content: String, filename: String) {\n\n    val pom = document.createElement(\"a\") as HTMLElement\n    pom.setAttribute(\"href\", \"data:text/plain;charset=utf-8,\" + encodeURIComponent(content));\n    pom.setAttribute(\"download\", filename)\n\n    pom.click()\n}\n\nfun downloadData(dataUrl: String, filename: String) {\n    val pom = document.createElement(\"a\") as HTMLElement\n    pom.setAttribute(\"href\", dataUrl);\n    pom.setAttribute(\"download\", filename)\n\n    pom.click()\n}\n\nexternal fun encodeURIComponent(content: String): String","package kmptemplate.data\n\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.get\nimport org.khronos.webgl.set\n\nactual class FloatArr actual constructor(actual val size: Int) {\n    val data = Float32Array(size)\n    actual operator fun get(index: Int): Float {\n        return data[index]\n    }\n    actual operator fun set(index: Int, value: Float) {\n        data[index] = value\n    }\n\n    actual fun copyInto(newarr: FloatArr) {\n        for(i in 0 until size) {\n            newarr[i] = data[i]\n        }\n    }\n}","package kmptemplate.entities\n\nimport org.w3c.dom.Image\n\nactual class DroppedImage(val img: Image)","package kmptemplate.entities\n\nimport kmptemplate.analytics.Analytics\nimport kmptemplate.analytics.CombinedAnalytics\nimport kmptemplate.analytics.JsYaMetricaAnalytics\nimport kmptemplate.analytics.PrintAnalytics\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.WebGL\nimport kmptemplate.input.JsKeyboard\nimport kmptemplate.loading.ParallelLoader\nimport kmptemplate.pool.VecPool\nimport kmptemplate.sound.HowlerSoundManager\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.storage.JsLocalStorage\nimport kmptemplate.storage.Storage\nimport kmptemplate.storage.YaGamesSafeStorage\nimport kmptemplate.tetris.YaGamesAds\nimport kmptemplate.time.currentTimeSeconds\nimport kmptemplate.ui.UiEvent.Companion.FILE_DROPPED\nimport kmptemplate.ui.UiEventPool\nimport kmptemplate.yagames.YaGamesLeaderBoard\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport kotlinx.coroutines.GlobalScope\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.w3c.dom.HTMLCanvasElement\nimport org.w3c.dom.Image\nimport org.w3c.files.File\nimport org.w3c.files.FileReader\n\nclass YaGamesJsPlayer(\n    val yaMetricaId: String,\n    val leaderBoardName: String,\n    val loader: ParallelLoader = ParallelLoader(GlobalScope),\n    val soundman: SoundManager = HowlerSoundManager(),\n    val ads: YaGamesAds = YaGamesAds(),\n    val storage: Storage = if (window.asDynamic().yaGamesSafeStorage == undefined) JsLocalStorage() else YaGamesSafeStorage(),\n    val analytics: Analytics = CombinedAnalytics(JsYaMetricaAnalytics(yaMetricaId), PrintAnalytics()),\n    val leaderBoard: YaGamesLeaderBoard = YaGamesLeaderBoard(leaderBoardName)\n) {\n\n    private var tPrev = Double.NaN\n    private lateinit var keyboard: JsKeyboard\n\n    suspend fun start(entity: Entity) {\n        val canvas = document.getElementById(\"glcanvas\") as HTMLCanvasElement\n\n        val webglContext = canvas.getContext(\"webgl\", mapOf(\"premultipliedAlpha\" to false, \"alpha\" to false, \"antialias\" to false)) as WebGLRenderingContext\n\n        keyboard = JsKeyboard(canvas)\n\n        canvas.ondrop = { e ->\n            e.stopPropagation()\n            e.preventDefault()\n            e.dataTransfer?.files?.let { filelist ->\n                println(filelist)\n                for (i in 0 until filelist.length) {\n\n                    val fileItem = filelist.item(i)!!\n                    val imageFile = fileItem.name.endsWith(\".png\", true) || fileItem.name.endsWith(\".jpg\", true) || fileItem.name.endsWith(\".jpeg\", true)\n                    println(\"dropped file: ${fileItem.name}\")\n                    if (imageFile) {\n                        println(\"image file dropped\")\n                        onImageFileDropped(fileItem)\n                    }\n                }\n            }\n            true\n        }\n        //ondrop not working without it\n        canvas.ondragover = { e ->\n            e.stopPropagation()\n            e.preventDefault()\n            println(\"dragging\")\n        }\n\n        val gl = WebGL(webglContext)\n        gl.viewPort(0, 0, webglContext.canvas.clientWidth, webglContext.canvas.clientHeight)\n\n//        webglContext.pixelStorei(WebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1); // -        \n\n        val soundman = HowlerSoundManager()\n        soundman.init()\n\n        val gloo = GLOO(gl)\n        entity.loadResources(gloo)\n\n        loader.join()\n\n        var lastFrameTime = -100000000.0\n\n        val FRAME_PERIOD = 0.0\n\n        var frameFunc: (Double) -> Unit = { }\n\n        var focused = true\n\n        val unusedCam1 = Camera()\n        val unusedCam2 = PlainCamera()\n\n        gl.enable(kmptemplate.gloo.GL.GL_DEPTH_TEST)\n\n        gl.enable(kmptemplate.gloo.GL.GL_CULL_FACE)\n        gl.cullFace(kmptemplate.gloo.GL.GL_BACK)\n\n        gl.enable(kmptemplate.gloo.GL.GL_BLEND)\n        gl.blendFunc(kmptemplate.gloo.GL.GL_SRC_ALPHA, kmptemplate.gloo.GL.GL_ONE_MINUS_SRC_ALPHA)\n\n        entity.initHierarchy(gloo)\n\n        val viewport = Viewport(100, 100)\n        frameFunc = { now: Double ->\n            val frameTime = now - lastFrameTime\n            if (frameTime > FRAME_PERIOD) {\n                lastFrameTime = now\n\n                val w = (window.innerWidth * window.devicePixelRatio).toInt()\n                val h = (window.innerHeight * window.devicePixelRatio).toInt()\n                canvas.width = w\n                canvas.height = h\n\n                viewport.w = w\n                viewport.h = h\n\n                keyboard.pollKeyboard()\n                keyboard.pollMouse()\n                keyboard.translateEventsToState()\n\n                val t = currentTimeSeconds()\n                if (!tPrev.isNaN()) {\n                    val dt = (t - tPrev).coerceIn(1.0 / 200.0, 1.0 / 30.0)\n                    entity.preUpdateHierarchy(dt, t, keyboard)\n                    entity.updateHierarchy(dt, t, keyboard)\n                }\n                tPrev = t\n\n                entity.renderHierarchy(viewport, unusedCam1, unusedCam2)\n            }\n\n            keyboard.clearEvents()\n            VecPool.reset()\n            UiEventPool.reset()\n\n            if (focused) {\n                window.requestAnimationFrame(frameFunc)\n            }\n        }\n\n        //https://stackoverflow.com/a/3478759/1075978\n        window.addEventListener(\"focus\", {\n            println(\"winow focused\")\n            focused = true\n            window.requestAnimationFrame(frameFunc)\n        }, false)\n        window.addEventListener(\"blur\", {\n            println(\"winow unfocused\")\n            focused = false\n        }, false)\n\n        js(\"\"\"console.log(\"first frame timing: \" + (performance.now()/1000.0 - window.loadingStartTime))\"\"\")\n\n        window.requestAnimationFrame(frameFunc)\n    }\n\n    private fun onImageFileDropped(item: File) {\n        val imgReader = FileReader()\n        imgReader.onload = { e ->\n            val img = Image()\n\n            img.onload = { onloadEvent ->\n                println(\"img.onload ${img.width}x${img.height}\")\n                onImageDropped(DroppedImage(img))\n            }\n\n            img.src = e.asDynamic().target.result as String\n\n\n            println(\"imgReader.onload\")\n            Unit\n        }\n        imgReader.readAsDataURL(item)\n    }\n\n    private fun onImageDropped(img: DroppedImage) {\n        keyboard.notifyEvent(UiEventPool.obtain(0f, 0f, FILE_DROPPED, 0, 0, droppedImage = img))\n    }\n}","package kmptemplate.gloo\n\nactual fun createScreenFramebufferHandle(): FramebufferHandle {\n    return FramebufferHandle(null)\n}","package kmptemplate.gloo\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.browser.downloadData\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.gloo.Texture2D.Companion.POWERS_OF_TWO\nimport kmptemplate.toFloat32Array\nimport kotlinx.browser.document\nimport org.khronos.webgl.Uint8Array\nimport org.khronos.webgl.WebGLBuffer\nimport org.khronos.webgl.WebGLFramebuffer\nimport org.khronos.webgl.WebGLProgram\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.khronos.webgl.WebGLShader\nimport org.khronos.webgl.WebGLTexture\nimport org.khronos.webgl.WebGLUniformLocation\nimport org.w3c.dom.Image\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.suspendCoroutine\n\nclass WebGL(val gl: WebGLRenderingContext) : GL() {\n\n    private var viewportX = 0\n    private var viewportY = 0\n    private var viewportW = 32\n    private var viewportH = 32\n    override fun clear() {\n//        println(\"WebGL.clear\")\n        gl.clear(WebGLRenderingContext.COLOR_BUFFER_BIT or WebGLRenderingContext.DEPTH_BUFFER_BIT)\n    }\n\n    override fun clearColor(r: Float, g: Float, b: Float, a: Float) {\n//        println(\"WebGL.clearColor\")\n        gl.clearColor(r, g, b, a)\n    }\n\n    override fun viewPort(x: Int, y: Int, width: Int, height: Int) {\n//        println(\"WebGL.viewPort\")\n        gl.viewport(x, y, width, height)\n        viewportX = x\n        viewportY = y\n        viewportW = width\n        viewportH = height\n    }\n\n    override fun createShader(type: ShaderType): ShaderHandle {\n//        println(\"WebGL.createShader\")\n        return ShaderHandle(gl.createShader(type.value)!!)\n    }\n\n    override fun shaderSource(shader: ShaderHandle, code: String) {\n//        println(\"WebGL.shaderSource\")\n        gl.shaderSource(shader.value as WebGLShader, code)\n    }\n\n    override fun compileShader(shader: ShaderHandle) {\n//        println(\"WebGL.compileShader\")\n        gl.compileShader(shader.value as WebGLShader)\n    }\n\n    override fun createProgram(): ProgramHandle {\n//        println(\"WebGL.createProgram\")\n        return ProgramHandle(gl.createProgram()!!)\n    }\n\n    override fun attachShader(program: ProgramHandle, shader: ShaderHandle) {\n//        println(\"WebGL.attachShader\")\n        gl.attachShader(program.value as WebGLProgram, shader.value as WebGLShader)\n    }\n\n    override fun linkProgram(program: ProgramHandle) {\n//        println(\"WebGL.linkProgram\")\n        gl.linkProgram(program.value as WebGLProgram)\n    }\n\n\n    override fun useProgram(program: ProgramHandle) {\n//        println(\"WebGL.useProgram\")\n        gl.useProgram(program.value as WebGLProgram)\n    }\n\n    override fun getUniformLocation(program: ProgramHandle, uniformName: String): UniformLocation {\n//        println(\"WebGL.getUniformLocation\")\n        val location = gl.getUniformLocation(program.value as WebGLProgram, uniformName) ?: throw RuntimeException(\"Uniform ${uniformName} not found (or not used in shader code and optimized by compiler)\")\n        return UniformLocation(location)\n    }\n\n    override fun glUniform1f(location: UniformLocation, x: Float) {\n//        println(\"WebGL.glUniform1f\")\n        gl.uniform1f(location.value as WebGLUniformLocation, x)\n    }\n\n    override fun glUniform2f(location: UniformLocation, x: Float, y: Float) {\n//        println(\"WebGL.glUniform2f\")\n        gl.uniform2f(location.value as WebGLUniformLocation, x, y)\n    }\n\n    override fun glUniform3f(location: UniformLocation, x: Float, y: Float, z: Float) {\n//        println(\"WebGL.glUniform3f\")\n        gl.uniform3f(location.value as WebGLUniformLocation, x, y, z)\n    }\n\n    override fun glUniform4f(location: UniformLocation, x: Float, y: Float, z: Float, w: Float) {\n//        println(\"WebGL.glUniform4f\")\n        gl.uniform4f(location.value as WebGLUniformLocation, x, y, z, w)\n    }\n\n    override fun glUniformMat2f(location: UniformLocation, data: FloatArray) {\n//        println(\"WebGL.glUniformMat2f\")\n        gl.uniformMatrix2fv(location.value as WebGLUniformLocation, false, data.toFloat32Array())\n    }\n\n    override fun glUniformMat3f(location: UniformLocation, data: FloatArray) {\n//        println(\"WebGL.glUniformMat3f\")\n        gl.uniformMatrix3fv(location.value as WebGLUniformLocation, false, data.toFloat32Array())\n    }\n\n    override fun glUniformMat4f(location: UniformLocation, data: FloatArray) {\n//        println(\"WebGL.glUniformMat4f\")\n        gl.uniformMatrix4fv(location.value as WebGLUniformLocation, false, data.toFloat32Array())\n    }\n\n    override fun glUniform1i(location: UniformLocation, v: Int) {\n//        println(\"WebGL.glUniform1i\")\n        gl.uniform1i(location.value as WebGLUniformLocation, v)\n    }\n\n    override fun getAttribLocation(program: ProgramHandle, attribName: String): AttribLocation {\n//        println(\"WebGL.getAttribLocation\")\n        return AttribLocation(gl.getAttribLocation(program.value as WebGLProgram, attribName))\n    }\n\n    override fun vertexAttribPointer(location: AttribLocation, coordsPerVertex: Int, type: DataType, normalized: Boolean, stride: Int, pointer: Int) {\n//        println(\"WebGL.vertexAttribPointer\")\n        gl.vertexAttribPointer(location.value, coordsPerVertex, type.value, normalized, stride, pointer)\n    }\n\n    override fun drawArrays(mode: DrawMode, first: Int, countVerts: Int) {\n//        println(\"WebGL.drawArrays\")\n        PERF_TRACKER.trackDrawCall(countVerts)\n        gl.drawArrays(mode.value, first, countVerts)\n    }\n\n    override fun createBuffer(): BufferHandle {\n//        println(\"WebGL.createBuffer\")\n        return BufferHandle(gl.createBuffer()!!)\n    }\n\n    override fun bufferData(target: BufferTarget, data: FloatBuffer, usage: BufferUsage) {\n//        println(\"WebGL.bufferData\")\n        gl.bufferData(target.value, data.typedArr.data, usage.value)\n    }\n\n    override fun bindBuffer(target: BufferTarget, buffer: BufferHandle) {\n//        println(\"WebGL.bindBuffer\")\n        gl.bindBuffer(target.value, buffer.value as WebGLBuffer)\n    }\n\n    override fun glEnableVertexAttribArray(location: AttribLocation) {\n//        println(\"WebGL.glEnableVertexAttribArray\")\n        gl.enableVertexAttribArray(location.value)\n    }\n\n    override fun glGetShaderInfoLog(shader: ShaderHandle): String {\n//        println(\"WebGL.glGetShaderInfoLog\")\n        return gl.getShaderInfoLog(shader.value as WebGLShader).orEmpty()\n    }\n\n    override fun glGetProgramInfoLog(program: ProgramHandle): String {\n//        println(\"WebGL.glGetProgramInfoLog\")\n        return gl.getProgramInfoLog(program.value as WebGLProgram).orEmpty()\n    }\n\n    override fun glGetError(): Int {\n//        println(\"WebGL.glGetError\")\n        return gl.getError()\n    }\n\n    override fun createTexture(): TextureHandle {\n//        println(\"WebGL.createTexture\")\n        return TextureHandle(gl.createTexture()!!)\n    }\n\n    override fun texParameteri(target: Int, param: Int, value: Int) {\n//        println(\"WebGL.texParameteri\")\n        gl.texParameteri(target, param, value)\n    }\n\n    override fun activeTexture(texture: Int) {\n//        println(\"WebGL.activeTexture\")\n        gl.activeTexture(texture)\n    }\n\n    override fun bindTexture(target: Int, handle: TextureHandle) {\n//        println(\"WebGL.bindTexture\")\n        gl.bindTexture(target, handle.value as WebGLTexture)\n    }\n\n    override suspend fun texImage2D(textureHandle: TextureHandle, path: String) = suspendCoroutine<Pair<Int, Int>> { cont ->\n        val img = Image()\n\n        img.onload = {\n            bindTexture(GL_TEXTURE_2D, textureHandle)\n            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, img)\n\n            // Poor filtering. Needed !\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n\n            if (POWERS_OF_TWO.contains(img.width) && POWERS_OF_TWO.contains(img.height)) {\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n            } else {\n                // Clamp to edge is only option for non power of 2  textures.\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n            }\n\n            checkErrors()\n            println(\"img.onload ${img.width}x${img.height}\")\n            cont.resume(Pair(img.width, img.height))\n        }\n\n        img.src = path\n    }\n\n    override fun texImage2D(textureHandle: TextureHandle, droppedImage: DroppedImage): Pair<Int, Int> {\n        val img = droppedImage.img\n\n        bindTexture(GL_TEXTURE_2D, textureHandle)\n        gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, img)\n\n        // Poor filtering. Needed !\n        texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n        texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n\n        if (POWERS_OF_TWO.contains(img.width) && POWERS_OF_TWO.contains(img.height)) {\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n        } else {\n            // Clamp to edge is only option for non power of 2  textures.\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        }\n\n        checkErrors()\n        println(\"img.onload ${img.width}x${img.height}\")\n        return Pair(img.width, img.height)\n    }\n\n    override fun enable(capability: Int) {\n//        println(\"WebGL.enable\")\n        gl.enable(capability)\n    }\n\n    override fun disable(capability: Int) {\n//        println(\"WebGL.disable\")\n        gl.disable(capability)\n    }\n\n    override fun cullFace(mode: Int) {\n//        println(\"WebGL.cullFace\")\n        gl.cullFace(mode)\n    }\n\n    override fun frontFace(mode: Int) {\n//        println(\"WebGL.frontFace\")\n        gl.frontFace(mode)\n    }\n\n    override fun blendFunc(sfactor: Int, dfactor: Int) {\n//        println(\"WebGL.blendFunc\")\n        gl.blendFunc(sfactor, dfactor)\n    }\n\n    override fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, offset: Int) {\n        gl.texImage2D(target, level, internalformat, width, height, border, format, type, null)\n    }\n\n    override fun scissor(x: Int, y: Int, w: Int, h: Int) {\n        gl.scissor(x, y, w, h)\n    }\n\n    override fun genFramebuffer(): FramebufferHandle {\n        return FramebufferHandle(gl.createFramebuffer())\n    }\n\n    override fun bindFramebuffer(target: Int, handle: FramebufferHandle) {\n        gl.bindFramebuffer(target, handle.value as WebGLFramebuffer?)\n    }\n\n    override fun framebufferTexture2D(target: Int, attachment: Int, texTarget: Int, texture: TextureHandle, level: Int) {\n        gl.framebufferTexture2D(target, attachment, texTarget, texture.value as WebGLTexture, level)\n    }\n\n    override fun readPixels(x: Int, y: Int, w: Int, h: Int, format: Int, type: Int, data: FloatArray) {\n        //TODO(\"not implemented yet\")\n    }\n\n    override fun screenshot(path: String) {\n        //based on this solution: https://stackoverflow.com/a/18804083/1075978\n        println(\"screenshot: ${path}\")\n\n        val w = viewportW\n        val h = viewportH\n\n        val data = Uint8Array(w * h * 4)\n\n        gl.readPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, data)\n\n        val canvas = document.createElement(\"canvas\")\n        val dynCanvas = canvas.asDynamic()\n        dynCanvas.width = w\n        dynCanvas.height = h\n        val context = dynCanvas.getContext(\"2d\")\n\n        val imageData = context.createImageData(w, h)\n        imageData.data.set(data)\n        context.putImageData(imageData, 0, 0)\n\n        val flippedDataUrl = dynCanvas.toDataURL().toString()\n\n        val horScale = 1f\n        val verScale = -1f\n\n        val horTranslate = 0f\n        val verTranslate = h\n\n        val flippedImage = Image()\n        flippedImage.onload = {\n            context.transform(horScale, 0f, 0f, verScale, horTranslate, verTranslate)\n            context.drawImage(flippedImage, 0, 0)\n\n            val dataUrl = dynCanvas.toDataURL().toString()\n\n            downloadData(dataUrl, \"warper.png\")\n            canvas.remove()\n        }\n        flippedImage.src = flippedDataUrl\n    }\n\n    override fun checkFramebufferStatus(target: Int): Int {\n        return gl.checkFramebufferStatus(target)\n    }\n}\n","package kmptemplate.input\n\nimport kmptemplate.asteroids.hasHardwareKeyboard\nimport kmptemplate.ui.UiEvent\nimport kmptemplate.ui.UiEventPool\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.TouchEvent\nimport org.w3c.dom.events.KeyboardEvent\nimport org.w3c.dom.events.MouseEvent\nimport org.w3c.dom.events.WheelEvent\nimport org.w3c.dom.get\n\nactual typealias Key = String\n\nactual val KEY_Q = \"KeyQ\"\nactual val KEY_W = \"KeyW\"\nactual val KEY_E = \"KeyE\"\nactual val KEY_R = \"KeyR\"\nactual val KEY_T = \"KeyT\"\nactual val KEY_Y = \"KeyY\"\nactual val KEY_U = \"KeyU\"\nactual val KEY_I = \"KeyI\"\nactual val KEY_O = \"KeyO\"\nactual val KEY_P = \"KeyP\"\n\nactual val KEY_A = \"KeyA\"\nactual val KEY_S = \"KeyS\"\nactual val KEY_D = \"KeyD\"\nactual val KEY_F = \"KeyF\"\nactual val KEY_G = \"KeyG\"\nactual val KEY_H = \"KeyH\"\nactual val KEY_J = \"KeyJ\"\nactual val KEY_K = \"KeyK\"\nactual val KEY_L = \"KeyL\"\n\nactual val KEY_Z = \"KeyZ\"\nactual val KEY_X = \"KeyX\"\nactual val KEY_C = \"KeyC\"\nactual val KEY_V = \"KeyV\"\nactual val KEY_B = \"KeyB\"\nactual val KEY_N = \"KeyN\"\nactual val KEY_M = \"KeyM\"\n\nactual val KEY_ARROW_UP = \"ArrowUp\"\nactual val KEY_ARROW_DOWN = \"ArrowDown\"\nactual val KEY_ARROW_LEFT = \"ArrowLeft\"\nactual val KEY_ARROW_RIGHT = \"ArrowRight\"\n\nactual val KEY_ENTER = \"Enter\"\nactual val KEY_SPACE = \"Space\"\nactual val KEY_BACKSPACE = \"Backspace\"\n\nclass JsKeyboard(val element: HTMLElement) : Keyboard() {\n\n    private val keyBuf = HashSet<Key>()\n    private val curKeys = HashSet<Key>()\n    private val prevKeys = HashSet<Key>()\n\n    private var x = 0.0\n    private var y = 0.0\n\n    private val prevMouseBtns = BooleanArray(8)\n    private val curMouseBtns = BooleanArray(8)\n    private val eventMouseBtns = BooleanArray(8)\n\n\n    init {\n        document.addEventListener(\"keydown\", { event ->\n            event as KeyboardEvent\n            keyBuf.add(event.code)\n        }, true)\n\n        document.addEventListener(\"keyup\", { event ->\n            event as KeyboardEvent\n            keyBuf.remove(event.code)\n        }, true)\n\n        document.addEventListener(\"wheel\", { event ->\n            event as WheelEvent\n            println(event.deltaX)\n            println(event.deltaY)\n            println(event.deltaZ)\n            println(event.deltaMode)\n            val wheelSens = -1f / 64f\n            notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.SCROLL, -1, -1, dx = event.deltaX.toFloat() * wheelSens, dy = event.deltaY.toFloat() * wheelSens))\n        }, true)\n\n        if (hasHardwareKeyboard()) {\n            element.addEventListener(\"mousemove\", { event ->\n                event as MouseEvent\n                val dp = window.devicePixelRatio\n\n                x = event.offsetX * dp\n                y = event.offsetY * dp\n\n                val uiEvent = UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.MOUSE_MOVE, 0, 0)\n                notifyEvent(uiEvent)\n\n//                println(\"mousemove ${x} ${y}\")\n            })\n\n            element.addEventListener(\"mouseup\", { event ->\n                event as MouseEvent\n\n//                println(\"mouseup ${event.button}\")\n\n                val dp = window.devicePixelRatio\n\n                x = event.offsetX * dp\n                y = event.offsetY * dp\n\n                val mouseBtn = translateMouseButton(event)\n\n                eventMouseBtns[mouseBtn] = false\n                notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.MOUSE_UP, 0, mouseBtn))\n            })\n\n            element.addEventListener(\"mousedown\", { event ->\n                event as MouseEvent\n                //println(\"mousedown ${event.button}\")\n\n                val mouseBtn = translateMouseButton(event)\n\n                val dp = window.devicePixelRatio\n\n                x = event.offsetX * dp\n                y = event.offsetY * dp\n\n                eventMouseBtns[mouseBtn] = true\n                notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.MOUSE_DOWN, 0, mouseBtn))\n            })\n        } else {\n            element.addEventListener(\"touchstart\", { event ->\n                event as TouchEvent\n\n                val dp = window.devicePixelRatio\n\n                val touchList = event.changedTouches\n                for (i in 0 until touchList.length) {\n                    val touch = touchList[i]!!\n\n                    val x = (touch.pageX.toDouble() - element.offsetLeft) * dp\n                    val y = (touch.pageY.toDouble() - element.offsetTop) * dp\n//                    println(\"touch_down ${touch.identifier}\")\n\n                    notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.TOUCH_DOWN, touch.identifier, 0))\n                }\n            })\n\n            element.addEventListener(\"touchmove\", { event ->\n                event as TouchEvent\n\n                val dp = window.devicePixelRatio\n\n                val touchList = event.changedTouches\n                for (i in 0 until touchList.length) {\n                    val touch = touchList[i]!!\n                    val x = (touch.pageX.toDouble() - element.offsetLeft) * dp\n                    val y = (touch.pageY.toDouble() - element.offsetTop) * dp\n//                    println(\"touchmove ${touch.identifier}\")\n\n                    notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.POINTER_MOVE, touch.identifier, 0))\n                }\n            })\n\n            element.addEventListener(\"touchend\", { event ->\n                event as TouchEvent\n                val dp = window.devicePixelRatio\n\n\n                val touchList = event.changedTouches\n                for (i in 0 until touchList.length) {\n                    val touch = touchList[i]!!\n                    val x = (touch.pageX.toDouble() - element.offsetLeft) * dp\n                    val y = (touch.pageY.toDouble() - element.offsetTop) * dp\n\n//                    println(\"touchend ${touch.identifier}\")\n                    notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.TOUCH_UP, touch.identifier, 0))\n                }\n            })\n        }\n\n        //https://stackoverflow.com/a/3478759/1075978\n        window.addEventListener(\"focus\", {\n            notifyEvent(UiEventPool.obtain(0f, 0f, UiEvent.FOCUSED, 0, 0))\n        }, false)\n        window.addEventListener(\"blur\", {\n            notifyEvent(UiEventPool.obtain(0f, 0f, UiEvent.UNFOCUSED, 0, 0))\n        }, false)\n\n    }\n\n    override fun pressed(key: Key): Boolean {\n        return curKeys.contains(key)\n    }\n\n    override fun pollKeyboard() {\n        prevKeys.clear()\n        prevKeys.addAll(curKeys)\n\n        curKeys.clear()\n        curKeys.addAll(keyBuf)\n    }\n\n    override fun justPressed(key: Key): Boolean {\n        return curKeys.contains(key) && !prevKeys.contains(key)\n    }\n\n    override fun justReleased(key: Key): Boolean {\n        return !curKeys.contains(key) && prevKeys.contains(key)\n    }\n\n    override fun pollMouse() {\n//        println(\"before\")\n//        println(this)\n\n//        println(\"copy cur to prev\")\n        curMouseBtns.copyInto(prevMouseBtns)\n//        println(this)\n\n//        println(\"copy events to cur\")\n        eventMouseBtns.copyInto(curMouseBtns)\n//        println(this)\n    }\n\n    override fun mousePressed(btn: Int): Boolean {\n        return curMouseBtns[btn]\n    }\n\n    override fun mouseCoords(): Pair<Double, Double> {\n        return Pair(x, y)\n    }\n\n    override fun mouseJustPressed(btn: Int): Boolean {\n        return curMouseBtns[btn] && !prevMouseBtns[btn]\n    }\n\n    override fun mouseJustReleased(btn: Int): Boolean {\n        return !curMouseBtns[btn] && prevMouseBtns[btn]\n    }\n\n    override fun anyKeyJustPressed() = ALL_KEYS.any { justPressed(it) }\n\n    override fun toString(): String {\n        return \"evnt: ${eventMouseBtns.toList()}\\ncur:${curMouseBtns.toList()}\\nprev:${prevMouseBtns.toList()}\"\n    }\n\n    private fun translateMouseButton(event: MouseEvent) =\n        when (event.button.toInt()) {\n            0 -> UiEvent.MOUSE_BUTTON_LEFT\n            1 -> UiEvent.MOUSE_BUTTON_MIDDLE\n            2 -> UiEvent.MOUSE_BUTTON_RIGHT\n            else -> -1\n        }\n}\n","package kmptemplate.sound\n\nclass HowlerSoundBuffer(val howl: dynamic) : SoundBuffer()\n\nprivate external class Howl(cfg: dynamic)\n\nclass HowlerSoundManager : SoundManager() {\n\n    fun init() {\n    }\n\n    override fun play(sound: SoundBuffer): Playback {\n        sound as HowlerSoundBuffer\n        sound.howl.play()\n        return Playback(0, sound)\n    }\n\n    override fun stop(playback: Playback) {\n        println(\"HowlerSoundManager.stop not implemented yet\")\n    }\n\n    override suspend fun loadSoundBuf(path: String): SoundBuffer {\n        val cfg = Any().asDynamic()\n        cfg.src = arrayOf(path)\n\n        return HowlerSoundBuffer(Howl(cfg))\n    }\n\n}","package kmptemplate.storage\n\nimport kotlinx.browser.window\nimport org.w3c.dom.get\nimport org.w3c.dom.set\n\nclass JsLocalStorage : Storage() {\n\n    private val storage = window.localStorage\n\n    init {\n        println(\"using JsLocalStorage\")\n    }\n\n    override fun set(k: String, v: String) {\n        storage.setItem(k, v)\n    }\n\n    override fun get(k: String): String? {\n        return storage.getItem(k)\n    }\n\n    override fun remove(k: String) {\n        storage.removeItem(k)\n    }\n\n    override fun clear() {\n        storage.clear()\n    }\n}","package kmptemplate.storage\n\nimport kotlinx.browser.window\n\nclass YaGamesSafeStorage : Storage() {\n\n    private val storage = window.asDynamic().yaGamesSafeStorage\n\n    init {\n        println(\"using YaGamesSafeStorage\")\n    }\n\n    override fun set(k: String, v: String) {\n        storage.setItem(k, v)\n    }\n\n    override fun get(k: String): String? {\n        return storage.getItem(k) as? String\n    }\n\n    override fun remove(k: String) {\n        storage.removeItem(k)\n    }\n\n    override fun clear() {\n        storage.clear()\n    }\n}","package kmptemplate.tetris\n\nimport kotlinx.browser.window\n\n//https://yandex.ru/dev/games/doc/dg/sdk/sdk-adv.html#recommendations\nclass YaGamesAds : Ads() {\n\n    //    ,    5      -    \n    //     ,      \n    private var lastAdsTryTimeMillis = -1E30\n    private val MIN_ADS_TIME_MS = 10000\n\n    private val yaGamesSdk = window.asDynamic().ysdk\n\n    override fun showInterstitial() {\n        val now = window.performance.now()\n        if (now - lastAdsTryTimeMillis < MIN_ADS_TIME_MS) {\n            println(\"Showing interstitial too often (time left: ${(lastAdsTryTimeMillis + MIN_ADS_TIME_MS - now) / 1000.0}s)\")\n            return\n        }\n        lastAdsTryTimeMillis = now\n\n        val jsCode = \"\"\"\nysdk.adv.showFullscreenAdv({\n          callbacks: {\n          onClose: function(wasShown) {\n                console.log('on ads close. wasShown: ' + wasShown)\n          },\n          onError: function(error) {\n                console.log('on ads error' + error)\n        }\n    }\n})\n\"\"\"\n        try {\n            js(jsCode)\n        } catch (t: Throwable) {\n            println(\"YaGamesAds: failed to execute js code\")\n            t.printStackTrace()\n        }\n    }\n\n    override fun showRewarded(onReward: () -> Unit, onOpen: () -> Unit, onClose: () -> Unit, onError: (Any) -> Unit) {\n        val callbacks = object {\n            val callbacks = object {\n                val onRewarded = {\n                    val now = window.performance.now()\n                    lastAdsTryTimeMillis = now\n\n                    onReward()\n                }\n\n                val onOpen = {\n                    println(\"Rewarded ads opened\")\n                    onOpen()\n                }\n\n                val onClose = {\n                    println(\"Rewarded ads closed\")\n                    onClose()\n                }\n\n                val onError = { e: Any ->\n                    println(\"Rewarded ads error\")\n                    println(e)\n                    onError(e)\n                }\n            }\n        }\n\n        println(\"showing rewarded ads\")\n        yaGamesSdk.adv.showRewardedVideo(callbacks)\n    }\n}\n\n","package kmptemplate.time\n\nimport kotlinx.browser.window\n\nactual fun currentTimeSeconds(): Double {\n    return window.performance.now() / 1000.0\n}","package kmptemplate.yagames\n\nimport kmptemplate.games.leaderboard.LeaderBoard\nimport kotlinx.browser.window\nimport kotlinx.coroutines.await\nimport kotlin.js.Promise\n\n//https://yandex.ru/dev/games/doc/dg/sdk/sdk-leaderboard.html#sdk-leaderboard\n/*\n     .    .\n\n     ,\n    ysdk.isAvailableMethod('leaderboards.setLeaderboardScore'),\n  Promise<Boolean>,\n      .\n */\nclass YaGamesLeaderBoard(val id: String) : LeaderBoard {\n\n    private val yaGamesSdk = window.asDynamic().ysdk\n    private val yaGamesLeaderBoard = window.asDynamic().yaGamesLeaderBoard\n\n    override suspend fun isAvailable(): Boolean {\n        val availablePromise = yaGamesSdk.isAvailableMethod(\"leaderboards.setLeaderboardScore\").unsafeCast<Promise<Boolean>>()\n        return availablePromise.await()\n    }\n\n    override fun setScore(score: Long) {\n        yaGamesLeaderBoard.setLeaderboardScore(id, score.toDouble())\n    }\n}","package kmptemplate\n\nimport kmptemplate.asteroids.GridSampleRender\nimport kmptemplate.gloo.WebGL\nimport kmptemplate.input.JsKeyboard\nimport kmptemplate.sound.WebAudioSoundManager\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.w3c.dom.HTMLCanvasElement\n\n\ninline fun FloatArray.toFloat32Array(): Float32Array {\n    return this.asDynamic() as Float32Array\n}\n\nsuspend fun racingMain() {\n\n//    println(\"Asteroids 0.0.4\")\n\n//    document.writeln(\"Asteroids 0.0.4\")\n\n    console.log(\"log1\")\n    val arr1 = FloatArray(10)\n    console.log(\"log2\")\n    val arr2 = Float32Array(16)\n\n    console.log(\"log3: ${arr1.size}\")\n    console.log(\"log4: ${arr2.length}\")\n    console.log(\"log5: ${arr1.toFloat32Array().length}\")\n\n    val canvas = document.getElementById(\"glcanvas\") as HTMLCanvasElement\n    val webglContext = canvas.getContext(\"webgl\", mapOf(\"premultipliedAlpha\" to false)) as WebGLRenderingContext\n\n    val keyboard = JsKeyboard(canvas)\n\n    val gl = WebGL(webglContext)\n    gl.viewPort(0, 0, webglContext.canvas.width, webglContext.canvas.height)\n\n    webglContext.enable(WebGLRenderingContext.BLEND);\n    webglContext.blendFunc(WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA);\n    //gl.pixelStorei(WebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n\n    val soundman = WebAudioSoundManager()\n    soundman.init()\n\n    val renderer = GridSampleRender(gl, keyboard, soundman)\n\n    renderer.init()\n    renderer.onSizeChanged(canvas.width, canvas.height)\n\n    fun requestAnimation() {\n        window.requestAnimationFrame {\n            renderer.render()\n            requestAnimation()\n        }\n    }\n\n    requestAnimation()\n}\n","package kmptemplate.io\n\nimport kmptemplate.browser.downloadContent\n\nactual fun saveFile(content: String, path: String) {\n    val filename = path.substringAfterLast(\"/\")\n    downloadContent(content, filename)\n}","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (5) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 5));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 5) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js.internal\n\n@JsName(\"DoubleCompanionObject\")\ninternal object DoubleCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Double = 4.9E-324\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Double = 1.7976931348623157E308\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Double = 1.0 / 0.0\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Double = -1.0 / 0.0\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Double = -(0.0 / 0.0)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"FloatCompanionObject\")\ninternal  object FloatCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Float = 1.4E-45F\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Float = 3.4028235E38F\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Float = 1.0F / 0.0F\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Float = -1.0F / 0.0F\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Float = -(0.0F / 0.0F)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"IntCompanionObject\")\ninternal  object IntCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Int = -2147483647 - 1\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Int = 2147483647\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"LongCompanionObject\")\ninternal  object LongCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Long = js(\"Kotlin.Long.MIN_VALUE\")\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Long = js(\"Kotlin.Long.MAX_VALUE\")\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"ShortCompanionObject\")\ninternal  object ShortCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Short = -32768\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Short = 32767\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\n@JsName(\"ByteCompanionObject\")\ninternal  object ByteCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Byte = -128\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Byte = 127\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 1\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 8\n}\n\n@JsName(\"CharCompanionObject\")\ninternal  object CharCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    public const val MIN_VALUE: Char = '\\u0000'\n\n    @JsName(\"MAX_VALUE\")\n    public const val MAX_VALUE: Char = '\\uFFFF'\n\n    @JsName(\"MIN_HIGH_SURROGATE\")\n    public const val MIN_HIGH_SURROGATE: Char = '\\uD800'\n\n    @JsName(\"MAX_HIGH_SURROGATE\")\n    public const val MAX_HIGH_SURROGATE: Char = '\\uDBFF'\n\n    @JsName(\"MIN_LOW_SURROGATE\")\n    public const val MIN_LOW_SURROGATE: Char = '\\uDC00'\n\n    @JsName(\"MAX_LOW_SURROGATE\")\n    public const val MAX_LOW_SURROGATE: Char = '\\uDFFF'\n\n    @JsName(\"MIN_SURROGATE\")\n    public const val MIN_SURROGATE: Char = MIN_HIGH_SURROGATE\n\n    @JsName(\"MAX_SURROGATE\")\n    public const val MAX_SURROGATE: Char = MAX_LOW_SURROGATE\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\ninternal  object StringCompanionObject {}\n\ninternal  object BooleanCompanionObject {}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.firstOrNull(): Int? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.firstOrNull(): Long? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.firstOrNull(): Char? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.lastOrNull(): Int? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.lastOrNull(): Long? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.lastOrNull(): Char? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(value: Byte): Boolean {\n    return (this as ClosedRange<Int>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(value: Byte): Boolean {\n    return (this as ClosedRange<Long>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(value: Int): Boolean {\n    return (this as ClosedRange<Long>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(value: Long): Boolean {\n    return (this as ClosedRange<Int>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun OpenEndRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(value: Short): Boolean {\n    return (this as ClosedRange<Int>).contains(value)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(value: Short): Boolean {\n    return (this as ClosedRange<Long>).contains(value)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Byte): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Byte): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Byte): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Byte): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.rangeUntil(to: Char): CharRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Int): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Int): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Int): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Int): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Long): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.rangeUntil(to: Short): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Long.rangeUntil(to: Short): LongRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Byte.rangeUntil(to: Short): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun Short.rangeUntil(to: Short): IntRange {\n    return until(to)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * The returned set is serializable (JVM).\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * The returned set is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char>, OpenEndRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n    \n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with Char type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    override val endExclusive: Char get() {\n        if (last == Char.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1\n    }\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int>, OpenEndRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n    \n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with Int type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    override val endExclusive: Int get() {\n        if (last == Int.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1\n    }\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long>, OpenEndRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n    \n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with Long type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    override val endExclusive: Long get() {\n        if (last == Long.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1\n    }\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.*\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n *\n * The type can store duration values up to 146 years with nanosecond precision,\n * and up to 146 million years with millisecond precision.\n * If a duration-returning operation provided in `kotlin.time` produces a duration value that doesn't fit into the above range,\n * the returned `Duration` is infinite.\n *\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        if (durationAssertionsEnabled) {\n            if (isInNanos()) {\n                if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n            } else {\n                if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n                if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n            }\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        @ExperimentalTime\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        // Duration construction extension properties in Duration companion scope\n\n        /** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of nanoseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of microseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of milliseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of seconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] equal to this [Long] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of minutes.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] equal to this [Int] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] equal to this [Long] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of hours.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.days get() = toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] equal to this [Long] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.days get() = toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of days.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n        // deprecated static factory functions\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in any of the supported formats.\n         * @sample samples.time.Durations.parse\n         */\n        public fun parse(value: String): Duration = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration in a restricted ISO-8601 composite representation\n         * and returns the parsed [Duration] value.\n         * Composite representation is a relaxed version of ISO-8601 duration format that supports\n         * negative durations and negative values of individual components.\n         *\n         * The following restrictions are imposed:\n         *\n         * - The only allowed non-time designator is days (`D`). `Y` (years), `W` (weeks), and `M` (months) are not supported.\n         * - Day is considered to be exactly 24 hours (24-hour clock time scale).\n         * - Alternative week-based representation `[\"P\"][number][\"W\"]` is not supported.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in ISO-8601 format.\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoString(value: String): Duration = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid ISO duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in any of the supported formats.\n         *\n         * The following formats are accepted:\n         *\n         * - Restricted ISO-8601 duration composite representation, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *   @sample samples.time.Durations.parse\n         */\n        public fun parseOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n\n        /**\n         * Parses a string that represents a duration in restricted ISO-8601 composite representation\n         * and returns the parsed [Duration] value or `null` if the string doesn't represent a duration in the format\n         * acceptable by [parseIsoString].\n         *\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoStringOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] days, or [Long.MIN_VALUE] days (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (days: Long, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeDays, hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] hours, or [Long.MIN_VALUE] hours (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (hours: Long, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeHours, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] minutes, or [Long.MIN_VALUE] minutes (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (minutes: Long, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeMinutes, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] seconds, or [Long.MIN_VALUE] seconds (depending on the sign of infinity),\n     *   and zero nanoseconds.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately 292 years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately 292 million years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value\n     * expressed as a combination of numeric components, each in its own unit.\n     *\n     * Each component is a number followed by the unit abbreviated name: `d`, `h`, `m`, `s`:\n     * `5h`, `1d 12h`, `1h 0m 30.340s`.\n     * The last component, usually seconds, can be a number with a fractional part.\n     *\n     * If the duration is less than a second, it is represented as a single number\n     * with one of sub-second units: `ms` (milliseconds), `us` (microseconds), or `ns` (nanoseconds):\n     * `140.884ms`, `500us`, `24ns`.\n     *\n     * A negative duration is prefixed with `-` sign and, if it consists of multiple components, surrounded with parentheses:\n     * `-12m` and `-(1h 30m)`.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * It's recommended to use [toIsoString] that uses more strict ISO-8601 format instead of this `toString`\n     * when you want to convert a duration to a string in cases of serialization, interchange, etc.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val isNegative = isNegative()\n            buildString {\n                if (isNegative) append('-')\n                absoluteValue.toComponents { days, hours, minutes, seconds, nanoseconds ->\n                    val hasDays = days != 0L\n                    val hasHours = hours != 0\n                    val hasMinutes = minutes != 0\n                    val hasSeconds = seconds != 0 || nanoseconds != 0\n                    var components = 0\n                    if (hasDays) {\n                        append(days).append('d')\n                        components++\n                    }\n                    if (hasHours || (hasDays && (hasMinutes || hasSeconds))) {\n                        if (components++ > 0) append(' ')\n                        append(hours).append('h')\n                    }\n                    if (hasMinutes || (hasSeconds && (hasHours || hasDays))) {\n                        if (components++ > 0) append(' ')\n                        append(minutes).append('m')\n                    }\n                    if (hasSeconds) {\n                        if (components++ > 0) append(' ')\n                        when {\n                            seconds != 0 || hasDays || hasHours || hasMinutes ->\n                                appendFractional(seconds, nanoseconds, 9, \"s\", isoZeroes = false)\n                            nanoseconds >= 1_000_000 ->\n                                appendFractional(nanoseconds / 1_000_000, nanoseconds % 1_000_000, 6, \"ms\", isoZeroes = false)\n                            nanoseconds >= 1_000 ->\n                                appendFractional(nanoseconds / 1_000, nanoseconds % 1_000, 3, \"us\", isoZeroes = false)\n                            else ->\n                                append(nanoseconds).append(\"ns\")\n                        }\n                    }\n                    if (isNegative && components > 1) insert(1, '(').append(')')\n                }\n            }\n        }\n    }\n\n    private fun StringBuilder.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean) {\n        append(whole)\n        if (fractional != 0) {\n            append('.')\n            val fracString = fractional.toString().padStart(fractionalSize, '0')\n            val nonZeroDigits = fracString.indexOfLast { it != '0' } + 1\n            when {\n                !isoZeroes && nonZeroDigits < 3 -> appendRange(fracString, 0, nonZeroDigits)\n                else -> appendRange(fracString, 0, ((nonZeroDigits + 2) / 3) * 3)\n            }\n        }\n        append(unit)\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * @param decimals the number of digits after decimal point to show. The value must be non-negative.\n     * No more than 12 decimals will be shown, even if a larger number is requested.\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return formatToExactDecimals(number, decimals.coerceAtMost(12)) + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * The infinite duration is represented as `\"PT9999999999999H\"` which is larger than any possible finite duration in Kotlin.\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        this@Duration.absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            @Suppress(\"NAME_SHADOWING\")\n            var hours = hours\n            if (isInfinite()) {\n                // use large enough value instead of Long.MAX_VALUE\n                hours = 9_999_999_999_999\n            }\n            val hasHours = hours != 0L\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                appendFractional(seconds, nanoseconds, 9, \"S\", isoZeroes = true)\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.roundToLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).roundToLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// deprecated extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n\nprivate fun parseDuration(value: String, strictIso: Boolean): Duration {\n    var length = value.length\n    if (length == 0) throw IllegalArgumentException(\"The string is empty\")\n    var index = 0\n    var result = Duration.ZERO\n    val infinityString = \"Infinity\"\n    when (value[index]) {\n        '+', '-' -> index++\n    }\n    val hasSign = index > 0\n    val isNegative = hasSign && value.startsWith('-')\n    when {\n        length <= index ->\n            throw IllegalArgumentException(\"No components\")\n        value[index] == 'P' -> {\n            if (++index == length) throw IllegalArgumentException()\n            val nonDigitSymbols = \"+-.\"\n            var isTimeComponent = false\n            var prevUnit: DurationUnit? = null\n            while (index < length) {\n                if (value[index] == 'T') {\n                    if (isTimeComponent || ++index == length) throw IllegalArgumentException()\n                    isTimeComponent = true\n                    continue\n                }\n                val component = value.substringWhile(index) { it in '0'..'9' || it in nonDigitSymbols }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitChar = value.getOrElse(index) { throw IllegalArgumentException(\"Missing unit for value $component\") }\n                index++\n                val unit = durationUnitByIsoChar(unitChar, isTimeComponent)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (unit == DurationUnit.SECONDS && dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += parseOverLongIsoComponent(whole).toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                } else {\n                    result += parseOverLongIsoComponent(component).toDuration(unit)\n                }\n            }\n        }\n        strictIso ->\n            throw IllegalArgumentException()\n        value.regionMatches(index, infinityString, 0, length = maxOf(length - index, infinityString.length), ignoreCase = true) -> {\n            result = Duration.INFINITE\n        }\n        else -> {\n            // parse default string format\n            var prevUnit: DurationUnit? = null\n            var afterFirst = false\n            var allowSpaces = !hasSign\n            if (hasSign && value[index] == '(' && value.last() == ')') {\n                allowSpaces = true\n                if (++index == --length) throw IllegalArgumentException(\"No components\")\n            }\n            while (index < length) {\n                if (afterFirst && allowSpaces) {\n                    index = value.skipWhile(index) { it == ' ' }\n                }\n                afterFirst = true\n                val component = value.substringWhile(index) { it in '0'..'9' || it == '.' }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitName = value.substringWhile(index) { it in 'a'..'z' }\n                index += unitName.length\n                val unit = durationUnitByShortName(unitName)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += whole.toLong().toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                    if (index < length) throw IllegalArgumentException(\"Fractional component must be last\")\n                } else {\n                    result += component.toLong().toDuration(unit)\n                }\n            }\n        }\n    }\n    return if (isNegative) -result else result\n}\n\n\nprivate fun parseOverLongIsoComponent(value: String): Long {\n    val length = value.length\n    var startIndex = 0\n    if (length > 0 && value[0] in \"+-\") startIndex++\n    if ((length - startIndex) > 16 && (startIndex..value.lastIndex).all { value[it] in '0'..'9' }) {\n        // all chars are digits, but more than ceiling(log10(MAX_MILLIS / 1000)) of them\n        return if (value[0] == '-') Long.MIN_VALUE else Long.MAX_VALUE\n    }\n    // TODO: replace with just toLong after min JDK becomes 8\n    return if (value.startsWith(\"+\")) value.drop(1).toLong() else value.toLong()\n}\n\n\n\nprivate inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String =\n    substring(startIndex, skipWhile(startIndex, predicate))\n\nprivate inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int {\n    var i = startIndex\n    while (i < length && predicate(this[i])) i++\n    return i\n}\n\n\n\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\nprivate fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\nprivate fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\nprivate fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\nprivate fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\nprivate fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\ninternal expect val durationAssertionsEnabled: Boolean\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 10 mappings totally\ninternal fun Char.titlecaseImpl(): String {\n    val uppercase = uppercase()\n    if (uppercase.length > 1) {\n        return if (this == '\\u0149') uppercase else uppercase[0] + uppercase.substring(1).lowercase()\n    }\n    return titlecaseChar().toString()\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property `Other_Uppercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property `Other_Lowercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\n@kotlin.js.JsPolyfill(\"\"\"\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\n\"\"\")\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\n@kotlin.js.JsPolyfill(\"\"\"\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n\"\"\")\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@Deprecated(\"Use String.plus() instead\", ReplaceWith(\"this + str\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@Deprecated(\"Use Regex.findAll() instead or invoke matches() on String dynamically: this.asDynamic().match(regex)\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n/**\n * Compares two strings lexicographically, optionally ignoring case differences.\n *\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        for (index in 0 until min) {\n            var thisChar = this[index]\n            var otherChar = other[index]\n\n            if (thisChar != otherChar) {\n                thisChar = thisChar.uppercaseChar()\n                otherChar = otherChar.uppercaseChar()\n\n                if (thisChar != otherChar) {\n                    thisChar = thisChar.lowercaseChar()\n                    otherChar = otherChar.lowercaseChar()\n\n                    if (thisChar != otherChar) {\n                        return thisChar.compareTo(otherChar)\n                    }\n                }\n            }\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(): Int {\n    return digitOf(this, 10).also {\n        if (it < 0) throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n    }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(): Int? {\n    return digitOf(this, 10).takeIf { it >= 0 }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n    return digitOf(this, radix).takeIf { it >= 0 }\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercase(): String\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.titlecaseChar(): Char\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.titlecase()` returns `\"\\u0046\\u0066\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no title case mapping, the result of [uppercase] is returned instead.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic fun Char.titlecase(): String = titlecaseImpl()\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * Two characters are considered equal ignoring case if `Char.uppercaseChar().lowercaseChar()` on each character produces the same result.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    val thisUpper = this.uppercaseChar()\n    val otherUpper = other.uppercaseChar()\n\n    return thisUpper == otherUpper || thisUpper.lowercaseChar() == otherUpper.lowercaseChar()\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic expect val Char.category: CharCategory\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDefined(): Boolean\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetter(): Boolean\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetterOrDigit(): Boolean\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDigit(): Boolean\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property `Other_Uppercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isUpperCase(): Boolean\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property `Other_Lowercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLowerCase(): Boolean\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isTitleCase(): Boolean\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isISOControl(): Boolean\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic expect fun Char.isWhitespace(): Boolean\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Double>.max(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Float>.max(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Double>.min(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Float>.min(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\")\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array(arguments)\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\")\n@JsPolyfill(\"\"\"\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n[Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array].forEach(function (TypedArray) {\n    if (typeof TypedArray.prototype.fill === \"undefined\") {\n        Object.defineProperty(TypedArray.prototype, 'fill', {\n            value: Array.prototype.fill\n        });\n    }\n})\n\"\"\")\ninternal inline fun Any.nativeFill(element: Any?, fromIndex: Int, toIndex: Int): Unit {\n    asDynamic().fill(element, fromIndex, toIndex)\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 1343 ranges totally\nprivate object Category {\n    val decodedRangeStart: IntArray\n    val decodedRangeCategory: IntArray\n    \n    init {\n        val toBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        val fromBase64 = IntArray(128)\n        for (i in toBase64.indices) {\n            fromBase64[toBase64[i].code] = i\n        }\n        \n        // rangeStartDiff.length = 1482\n        val rangeStartDiff = \"gBCFEDCKCDCaDDaDBhBCEEDDDDDEDXBHYBH5BRwBGDCHDCIDFHDCHFDCDEIRTEE7BGHDDJlCBbSEMOFGERwDEDDDDECEFCRBJhBFDCYFFCCzBvBjBBFC3BOhDBmBDGpBDDCtBBJIbEECLGDFCLDCgBBKVKEDiDDHCFECECKCEODBebC5CLBOKhBJDDDDWEBHFCFCPBZDEL1BVBSLPBgBB2BDBDICFBHKCCKCPDBHEDWBHEDDDDEDEDIBDGDCKCCGDDDCGECCWBFMDDCDEDDCHDDHKDDBKDBHFCWBFGFDBDDFEDBPDDKCHBGDCHEDWBFGFDCEDEDBHDDGDCKCGJEGDBFDDFDDDDDMEFDBFDCGBOKDFDFDCGFCXBQDDDDDBEGEDFDDKHBHDDGFCXBKBFCEFCFCHCHECCKDNCCHFCoBEDECFDDDDHDCCKJBGDCSDYBJEHBFDDEBIGKDCMuBFHEBGBIBKCkBFBFBXEIFJDFDGCKCEgBBDPEDGKKGECIBkBEOBDFFLBkBBIBEFFEClBrBCEBEGDBKGGDDDDDCHDENDCFEKDDlBDDFrBCDpKBECGEECpBBEChBBECGEECPB5BBECjCCDJUDQKG2CCGDsTCRBaCDrCDDIHNBEDLSDCJSCMLFCCM0BDHGFLBFDDKGKGEFDDBKGjBB1BHFChBDFmCKfDDDDDDCGDCFDKeCFLsBEaGKBDiBXDDD1BDGDEIGJEKGKGHBGCMF/BEBvBCEDDFHEKHKJJDDeDDGDKsBFEDCIEkBIICCDFKDDKeGCJHrBCDIIDBNBHEBEFDBFsB/BNBiBlB6BBF1EIiDJIGCGCIIIIGCGCIIIIOCIIIIIIDFEDDBFEDDDDEBDIFDDFEDBLFGCEEICFBJCDEDCLDKBFBKCCGDDKDDNDgBQNEBDMPFFDEDEBFFHECEBEEDFBEDDQjBCEDEFFCCJHBeEEfsIIEUCHCxCBeZoBGlCZLV8BuCW3FBJB2BIvDB4HOesBFCfKQgIjEW/BEgBCiIwBVCGnBCgBBpDvBBuBEDBHEFGCCjDCGEDCFCFlBDDF4BHCOBXJHBHBHBHBHBHBHBHBgBCECGHGEDIFBKCEDMEtBaB5CM2GaMEDDCKCGFCJEDFDDDC2CDDDB6CDCFrBB+CDEKgBkBMQfBKeIBPgBKnBPgKguGgC9vUDVB3jBD3BJoBGCsIBDQKCUuBDDKCcCCmCKCGIXJCNC/BBHGKDECEVFBEMCEEBqBDDGDFDXDCEBDGEG0BEICyBQCICKGSGDEBKcICXLCLBdDDBvBDECCDNCKECFCJKFBpBFEDCJDBICCKCEQBGDDByBEDCEFBYDCLEDDCKGCGCGJHBHBrBBEJDEwCjBIDCKGk9KMXExBEggCgoGuLCqDmBHMFFCKBNBFBIsDQRrLCQgCC2BoBMCCQGEGQDCQDDDDFDGDECEEFBnEEBFEDCKCDCaDDaDBFCKBtBCfDGCGCFEDDDDCECKDC\"\n        val diff = decodeVarLenBase64(rangeStartDiff, fromBase64, 1342)\n        val start = IntArray(diff.size + 1)\n        for (i in diff.indices) {\n            start[i + 1] = start[i] + diff[i]\n        }\n        decodedRangeStart = start\n        \n        // rangeCategory.length = 2033\n        val rangeCategory = \"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\"\n        decodedRangeCategory = decodeVarLenBase64(rangeCategory, fromBase64, 1343)\n    }\n}\n\nprivate fun categoryValueFrom(code: Int, ch: Int): Int {\n    return when {\n        code < 0x20 -> code\n        code < 0x400 -> if ((ch and 1) == 1) code shr 5 else code and 0x1f\n        else ->\n            when (ch % 3) {\n                2 -> code shr 10\n                1 -> (code shr 5) and 0x1f\n                else -> code and 0x1f\n            }\n    }\n}\n\n/**\n * Returns the Unicode general category of this character as an Int.\n */\ninternal fun Char.getCategoryValue(): Int {\n    val ch = this.code\n\n    val index = binarySearchRange(Category.decodedRangeStart, ch)\n    val start = Category.decodedRangeStart[index]\n    val code = Category.decodedRangeCategory[index]\n    val value = categoryValueFrom(code, ch - start)\n\n    return if (value == 17) CharCategory.UNASSIGNED.value else value\n}\n\ninternal fun decodeVarLenBase64(base64: String, fromBase64: IntArray, resultLength: Int): IntArray {\n    val result = IntArray(resultLength)\n    var index = 0\n    var int = 0\n    var shift = 0\n    for (char in base64) {\n        val sixBit = fromBase64[char.code]\n        int = int or ((sixBit and 0x1f) shl shift)\n        if (sixBit < 0x20) {\n            result[index++] = int\n            int = 0\n            shift = 0\n        } else {\n            shift += 5\n        }\n    }\n    return result\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 37 ranges totally\nprivate object Digit {\n    internal val rangeStart = intArrayOf(\n        0x0030, 0x0660, 0x06f0, 0x07c0, 0x0966, 0x09e6, 0x0a66, 0x0ae6, 0x0b66, 0x0be6, 0x0c66, 0x0ce6, 0x0d66, 0x0de6, 0x0e50, 0x0ed0, 0x0f20, 0x1040, 0x1090, 0x17e0, \n        0x1810, 0x1946, 0x19d0, 0x1a80, 0x1a90, 0x1b50, 0x1bb0, 0x1c40, 0x1c50, 0xa620, 0xa8d0, 0xa900, 0xa9d0, 0xa9f0, 0xaa50, 0xabf0, 0xff10, \n    )\n}\n\n/**\n * Returns the index of the largest element in [array] smaller or equal to the specified [needle],\n * or -1 if [needle] is smaller than the smallest element in [array].\n */\ninternal fun binarySearchRange(array: IntArray, needle: Int): Int {\n    var bottom = 0\n    var top = array.size - 1\n    var middle = -1\n    var value = 0\n    while (bottom <= top) {\n        middle = (bottom + top) / 2\n        value = array[middle]\n        if (needle > value)\n            bottom = middle + 1\n        else if (needle == value)\n            return middle\n        else\n            top = middle - 1\n    }\n    return middle - (if (needle < value) 1 else 0)\n}\n\n/**\n * Returns an integer from 0..9 indicating the digit this character represents,\n * or -1 if this character is not a digit.\n */\ninternal fun Char.digitToIntImpl(): Int {\n    val ch = this.code\n    val index = binarySearchRange(Digit.rangeStart, ch)\n    val diff = ch - Digit.rangeStart[index]\n    return if (diff < 10) diff else -1\n}\n\n/**\n * Returns `true` if this character is a digit.\n */\ninternal fun Char.isDigitImpl(): Boolean {\n    return digitToIntImpl() >= 0\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 222 ranges totally\nprivate object Letter {\n    val decodedRangeStart: IntArray\n    val decodedRangeLength: IntArray\n    val decodedRangeCategory: IntArray\n    \n    init {\n        val toBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        val fromBase64 = IntArray(128)\n        for (i in toBase64.indices) {\n            fromBase64[toBase64[i].code] = i\n        }\n        \n        // rangeStartDiff.length = 356\n        val rangeStartDiff = \"hCgBpCQGYHZH5BRpBPPPPPPRMP5BPPlCPP6BkEPPPPcPXPzBvBrB3BOiDoBHwD+E3DauCnFmBmB2D6E1BlBTiBmBlBP5BhBiBrBvBjBqBnBPRtBiCmCtBlB0BmB5BiB7BmBgEmChBZgCoEoGVpBSfRhBPqKQ2BwBYoFgB4CJuTiEvBuCuDrF5DgEgFlJ1DgFmBQtBsBRGsB+BPiBlD1EIjDPRPPPQPPPPPGQSQS/DxENVNU+B9zCwBwBPPCkDPNnBPqDYY1R8B7FkFgTgwGgwUwmBgKwBuBScmEP/BPPPPPPrBP8B7F1B/ErBqC6B7BiBmBfQsBUwCw/KwqIwLwETPcPjQgJxFgBlBsD\"\n        val diff = decodeVarLenBase64(rangeStartDiff, fromBase64, 222)\n        val start = IntArray(diff.size)\n        for (i in diff.indices) {\n            if (i == 0) start[i] = diff[i]\n            else start[i] = start[i - 1] + diff[i]\n        }\n        decodedRangeStart = start\n        \n        // rangeLength.length = 328\n        val rangeLength = \"aaMBXHYH5BRpBPPPPPPRMP5BPPlCPPzBDOOPPcPXPzBvBjB3BOhDmBBpB7DoDYxB+EiBP1DoExBkBQhBekBPmBgBhBctBiBMWOOXhCsBpBkBUV3Ba4BkB0DlCgBXgBtD4FSdBfPhBPpKP0BvBXjEQ2CGsT8DhBtCqDpFvD1D3E0IrD2EkBJrBDOBsB+BPiBlB1EIjDPPPPPPPPPPPGPPMNLsBNPNPKCvBvBPPCkDPBmBPhDXXgD4B6FzEgDguG9vUtkB9JcuBSckEP/BPPPPPPBPf4FrBjEhBpC3B5BKaWPrBOwCk/KsCuLqDHPbPxPsFtEaaqDL\"\n        decodedRangeLength = decodeVarLenBase64(rangeLength, fromBase64, 222)\n        \n        // rangeCategory.length = 959\n        val rangeCategory = \"GFjgggUHGGFFZZZmzpz5qB6s6020B60ptltB6smt2sB60mz22B1+vv+8BZZ5s2850BW5q1ymtB506smzBF3q1q1qB1q1q1+Bgii4wDTm74g3KiggxqM60q1q1Bq1o1q1BF1qlrqrBZ2q5wprBGFZWWZGHFsjiooLowgmOowjkwCkgoiIk7ligGogiioBkwkiYkzj2oNoi+sbkwj04DghhkQ8wgiYkgoioDsgnkwC4gikQ//v+85BkwvoIsgoyI4yguI0whiwEowri4CoghsJowgqYowgm4DkwgsY/nwnzPowhmYkg6wI8yggZswikwHgxgmIoxgqYkwgk4DkxgmIkgoioBsgssoBgzgyI8g9gL8g9kI0wgwJoxgkoC0wgioFkw/wI0w53iF4gioYowjmgBHGq1qkgwBF1q1q8qBHwghuIwghyKk0goQkwgoQk3goQHGFHkyg0pBgxj6IoinkxDswno7Ikwhz9Bo0gioB8z48Rwli0xN0mpjoX8w78pDwltoqKHFGGwwgsIHFH3q1q16BFHWFZ1q10q1B2qlwq1B1q10q1B2q1yq1B6q1gq1Biq1qhxBir1qp1Bqt1q1qB1g1q1+B//3q16B///q1qBH/qlqq9Bholqq9B1i00a1q10qD1op1HkwmigEigiy6Cptogq1Bixo1kDq7/j00B2qgoBWGFm1lz50B6s5q1+BGWhggzhwBFFhgk4//Bo2jigE8wguI8wguI8wgugUog1qoB4qjmIwwi2KgkYHHH4lBgiFWkgIWoghssMmz5smrBZ3q1y50B5sm7gzBtz1smzB5smz50BqzqtmzB5sgzqzBF2/9//5BowgoIwmnkzPkwgk4C8ys65BkgoqI0wgy6FghquZo2giY0ghiIsgh24B4ghsQ8QF/v1q1OFs0O8iCHHF1qggz/B8wg6Iznv+//B08QgohsjK0QGFk7hsQ4gB\"\n        decodedRangeCategory = decodeVarLenBase64(rangeCategory, fromBase64, 222)\n    }\n}\n\n/**\n * Returns `true` if this character is a letter.\n */\ninternal fun Char.isLetterImpl(): Boolean {\n    return getLetterType() != 0\n}\n\n/**\n * Returns `true` if this character is a lower case letter, or it has contributory property `Other_Lowercase`.\n */\ninternal fun Char.isLowerCaseImpl(): Boolean {\n    return getLetterType() == 1 || code.isOtherLowercase()\n}\n\n/**\n * Returns `true` if this character is an upper case letter, or it has contributory property `Other_Uppercase`.\n */\ninternal fun Char.isUpperCaseImpl(): Boolean {\n    return getLetterType() == 2 || code.isOtherUppercase()\n}\n\n/**\n * Returns\n *   - `1` if the character is a lower case letter,\n *   - `2` if the character is an upper case letter,\n *   - `3` if the character is a letter but not a lower or upper case letter,\n *   - `0` otherwise.\n */\nprivate fun Char.getLetterType(): Int {\n    val ch = this.code\n    val index = binarySearchRange(Letter.decodedRangeStart, ch)\n\n    val rangeStart = Letter.decodedRangeStart[index]\n    val rangeEnd = rangeStart + Letter.decodedRangeLength[index] - 1\n    val code = Letter.decodedRangeCategory[index]\n\n    if (ch > rangeEnd) {\n        return 0\n    }\n\n    val lastTwoBits = code and 0x3\n\n    if (lastTwoBits == 0) { // gap pattern\n        var shift = 2\n        var threshold = rangeStart\n        for (i in 0..1) {\n            threshold += (code shr shift) and 0x7f\n            if (threshold > ch) {\n                return 3\n            }\n            shift += 7\n            threshold += (code shr shift) and 0x7f\n            if (threshold > ch) {\n                return 0\n            }\n            shift += 7\n        }\n        return 3\n    }\n\n    if (code <= 0x7) {\n        return lastTwoBits\n    }\n\n    val distance = (ch - rangeStart)\n    val shift = if (code <= 0x1F) distance % 2 else distance\n    return (code shr (2 * shift)) and 0x3\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nprivate object OtherLowercase {\n    internal val otherLowerStart = intArrayOf(\n        0x00aa, 0x00ba, 0x02b0, 0x02c0, 0x02e0, 0x0345, 0x037a, 0x1d2c, 0x1d78, 0x1d9b, 0x2071, 0x207f, 0x2090, 0x2170, 0x24d0, 0x2c7c, 0xa69c, 0xa770, 0xa7f8, 0xab5c, \n    )\n    internal val otherLowerLength = intArrayOf(\n        1, 1, 9, 2, 5, 1, 1, 63, 1, 37, 1, 1, 13, 16, 26, 2, 2, 1, 2, 4, \n    )\n}\n\ninternal fun Int.isOtherLowercase(): Boolean {\n    val index = binarySearchRange(OtherLowercase.otherLowerStart, this)\n    return index >= 0 && this < OtherLowercase.otherLowerStart[index] + OtherLowercase.otherLowerLength[index]\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 4 ranges totally\ninternal fun Char.titlecaseCharImpl(): Char {\n    val code = this.code\n    // Letters repeating <Lu, Lt, Ll> sequence and code of the Lt is a multiple of 3, e.g. <, , >\n    if (code in 0x01c4..0x01cc || code in 0x01f1..0x01f3) {\n        return (3 * ((code + 1) / 3)).toChar()\n    }\n    // Lower case letters whose title case mapping equivalent is equal to the original letter\n    if (code in 0x10d0..0x10fa || code in 0x10fd..0x10ff) {\n        return this\n    }\n    return uppercaseChar()\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 9 ranges totally\n/**\n * Returns `true` if this character is a whitespace.\n */\ninternal fun Char.isWhitespaceImpl(): Boolean {\n    val ch = this.code\n    return ch in 0x0009..0x000d\n            || ch in 0x001c..0x0020\n            || ch == 0x00a0\n            || ch > 0x1000 && (\n                ch == 0x1680\n                || ch in 0x2000..0x200a\n                || ch == 0x2028\n                || ch == 0x2029\n                || ch == 0x202f\n                || ch == 0x205f\n                || ch == 0x3000\n            )\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @Deprecated(\"Provided so that subclasses inherit this function\", level = DeprecationLevel.HIDDEN)\n    @JsName(\"toJSON\")\n    protected fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        AbstractList.checkPositionIndex(index, size)\n\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n        final override fun remove(element: E): Boolean = removeEntry(element)\n        abstract fun removeEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    public actual constructor(initialCapacity: Int) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        if (array.size < size) {\n            return toArray() as Array<T>\n        }\n\n        (this.array as Array<T>).copyInto(array)\n\n        if (array.size > size) {\n            array[size] = null as T // null-terminate\n        }\n\n        return array\n    }\n\n    override fun toArray(): Array<Any?> {\n        return js(\"[]\").slice.call(array)\n    }\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    internal open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    internal override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n\n@SinceKotlin(\"1.6\")\npublic actual fun readln(): String = throw UnsupportedOperationException(\"readln is not supported in Kotlin/JS\")\n\n@SinceKotlin(\"1.6\")\npublic actual fun readlnOrNull(): String? = throw UnsupportedOperationException(\"readlnOrNull is not supported in Kotlin/JS\")","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = nativeClz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal class KTypeImpl(\n    override val classifier: KClassifier,\n    override val arguments: List<KTypeProjection>,\n    override val isMarkedNullable: Boolean\n) : KType {\n    override fun equals(other: Any?): Boolean =\n        other is KTypeImpl &&\n                classifier == other.classifier && arguments == other.arguments && isMarkedNullable == other.isMarkedNullable\n\n    override fun hashCode(): Int =\n        (classifier.hashCode() * 31 + arguments.hashCode()) * 31 + isMarkedNullable.hashCode()\n\n    override fun toString(): String {\n        val kClass = (classifier as? KClass<*>)\n        val classifierName = when {\n            kClass == null -> classifier.toString()\n            kClass.simpleName != null -> kClass.simpleName\n            else -> \"(non-denotable type)\"\n        }\n\n        val args =\n            if (arguments.isEmpty()) \"\"\n            else arguments.joinToString(\", \", \"<\", \">\")\n        val nullable = if (isMarkedNullable) \"?\" else \"\"\n\n        return classifierName + args + nullable\n    }\n}\n\ninternal object DynamicKType : KType {\n    override val classifier: KClassifier? = null\n    override val arguments: List<KTypeProjection> = emptyList()\n    override val isMarkedNullable: Boolean = false\n    override fun toString(): String = \"dynamic\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n *\n * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull].\n */\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    char < '\\u0080' -> -1\n    char >= '\\uFF21' && char <= '\\uFF3A' -> char - '\\uFF21' + 10 // full-width latin capital letter\n    char >= '\\uFF41' && char <= '\\uFF5A' -> char - '\\uFF41' + 10 // full-width latin small letter\n    else -> char.digitToIntImpl()\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n@Deprecated(\"Use Regex.matches() instead\", ReplaceWith(\"regex.toRegex().matches(this)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun String.matches(regex: String): Boolean {\n    @Suppress(\"DEPRECATION\")\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\n/**\n * Returns `true` if this string is empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsBlank\n */\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || indices.all { this[it].isWhitespace() }\n\n/**\n * Returns `true` if this string is equal to [other], optionally ignoring character case.\n *\n * Two strings are considered to be equal if they have the same length and the same character at the same index.\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean {\n    if (this == null) return other == null\n    if (other == null) return false\n    if (!ignoreCase) return this == other\n\n    if (this.length != other.length) return false\n\n    for (index in 0 until this.length) {\n        val thisChar = this[index]\n        val otherChar = other[index]\n        if (!thisChar.equals(otherChar, ignoreCase)) {\n            return false\n        }\n    }\n\n    return true\n}\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).uppercase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).lowercase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n * @sample samples.text.Strings.repeat\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n/**\n * Returns a new string obtained by replacing all occurrences of the [oldValue] substring in this string\n * with the specified [newValue] string.\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gui\" else \"gu\"), Regex.nativeEscapeReplacement(newValue))\n\n/**\n * Returns a new string with all occurrences of [oldChar] replaced with [newChar].\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gui\" else \"gu\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"ui\" else \"u\"), Regex.nativeEscapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"ui\" else \"u\"), newChar.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns the detailed description of this throwable with its stack trace.\n *\n * The detailed description includes:\n * - the short description (see [Throwable.toString]) of this throwable;\n * - the complete stack trace;\n * - detailed descriptions of the exceptions that were [suppressed][suppressedExceptions] in order to deliver this exception;\n * - the detailed description of each throwable in the [Throwable.cause] chain.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.stackTraceToString(): String = ExceptionTraceBuilder().buildFor(this)\n\n/**\n * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to console error output.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.printStackTrace() {\n    console.error(this.stackTraceToString())\n}\n\n/**\n * Adds the specified exception to the list of exceptions that were\n * suppressed in order to deliver this exception.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.addSuppressed(exception: Throwable) {\n    if (this !== exception) {\n        val suppressed = this.asDynamic()._suppressed.unsafeCast<MutableList<Throwable>?>()\n        if (suppressed == null) {\n            this.asDynamic()._suppressed = mutableListOf(exception)\n        } else {\n            suppressed.add(exception)\n        }\n    }\n}\n\n/**\n * Returns a list of all exceptions that were suppressed in order to deliver this exception.\n */\n@SinceKotlin(\"1.4\")\npublic actual val Throwable.suppressedExceptions: List<Throwable>\n    get() {\n        return this.asDynamic()._suppressed?.unsafeCast<List<Throwable>>() ?: emptyList()\n    }\n\n\nprivate class ExceptionTraceBuilder {\n    private val target = StringBuilder()\n    private val visited = arrayOf<Throwable>()\n    private var topStack: String = \"\"\n    private var topStackStart: Int = 0\n\n    fun buildFor(exception: Throwable): String {\n        exception.dumpFullTrace(\"\", \"\")\n        return target.toString()\n    }\n\n    private fun hasSeen(exception: Throwable): Boolean = visited.any { it === exception }\n\n    private fun Throwable.dumpFullTrace(indent: String, qualifier: String) {\n        this.dumpSelfTrace(indent, qualifier) || return\n\n        var cause = this.cause\n        while (cause != null) {\n            cause.dumpSelfTrace(indent, \"Caused by: \") || return\n            cause = cause.cause\n        }\n    }\n\n    private fun Throwable.dumpSelfTrace(indent: String, qualifier: String): Boolean {\n        target.append(indent).append(qualifier)\n        val shortInfo = this.toString()\n        if (hasSeen(this)) {\n            target.append(\"[CIRCULAR REFERENCE, SEE ABOVE: \").append(shortInfo).append(\"]\\n\")\n            return false\n        }\n        visited.asDynamic().push(this)\n\n        var stack = this.asDynamic().stack as String?\n        if (stack != null) {\n            val stackStart = stack.indexOf(shortInfo).let { if (it < 0) 0 else it + shortInfo.length }\n            if (stackStart == 0) target.append(shortInfo).append(\"\\n\")\n            if (topStack.isEmpty()) {\n                topStack = stack\n                topStackStart = stackStart\n            } else {\n                stack = dropCommonFrames(stack, stackStart)\n            }\n            if (indent.isNotEmpty()) {\n                // indent stack, but avoid indenting exception message lines\n                val messageLines = if (stackStart == 0) 0 else 1 + shortInfo.count { c -> c == '\\n' }\n                stack.lineSequence().forEachIndexed { index: Int, line: String ->\n                    if (index >= messageLines) target.append(indent)\n                    target.append(line).append(\"\\n\")\n                }\n            } else {\n                target.append(stack).append(\"\\n\")\n            }\n        } else {\n            target.append(shortInfo).append(\"\\n\")\n        }\n\n        val suppressed = suppressedExceptions\n        if (suppressed.isNotEmpty()) {\n            val suppressedIndent = indent + \"    \"\n            for (s in suppressed) {\n                s.dumpFullTrace(suppressedIndent, \"Suppressed: \")\n            }\n        }\n        return true\n    }\n\n    private fun dropCommonFrames(stack: String, stackStart: Int): String {\n        var commonFrames: Int = 0\n        var lastBreak: Int = 0\n        var preLastBreak: Int = 0\n        for (pos in 0 until minOf(topStack.length - topStackStart, stack.length - stackStart)) {\n            val c = stack[stack.lastIndex - pos]\n            if (c != topStack[topStack.lastIndex - pos]) break\n            if (c == '\\n') {\n                commonFrames += 1\n                preLastBreak = lastBreak\n                lastBreak = pos\n            }\n        }\n        if (commonFrames <= 1) return stack\n        while (preLastBreak > 0 && stack[stack.lastIndex - (preLastBreak - 1)] == ' ')\n            preLastBreak -= 1\n\n        // leave 1 common frame to ease matching with the top exception stack\n        return stack.dropLast(preLastBreak) + \"... and ${commonFrames - 1} more common stack frames skipped\"\n    }\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.js.json\nimport kotlin.math.*\n\ninternal actual inline val durationAssertionsEnabled: Boolean get() = true\n\ninternal actual fun formatToExactDecimals(value: Double, decimals: Int): String {\n    val rounded = if (decimals == 0) {\n        value\n    } else {\n        val pow = 10.0.pow(decimals)\n        JsMath.round(abs(value) * pow) / pow * sign(value)\n    }\n    return if (abs(rounded) < 1e21) {\n        // toFixed switches to scientific format after 1e21\n        rounded.asDynamic().toFixed(decimals).unsafeCast<String>()\n    } else {\n        // toPrecision outputs the specified number of digits, but only for positive numbers\n        val positive = abs(rounded)\n        val positiveString = positive.asDynamic().toPrecision(ceil(log10(positive)) + decimals).unsafeCast<String>()\n        if (rounded < 0) \"-$positiveString\" else positiveString\n    }\n}\n\ninternal actual fun formatUpToDecimals(value: Double, decimals: Int): String {\n    return value.asDynamic().toLocaleString(\"en-us\", json(\"maximumFractionDigits\" to decimals)).unsafeCast<String>()\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic actual enum class DurationUnit(internal val scale: Double) {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS(1e0),\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS(1e3),\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS(1e6),\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS(1e9),\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES(60e9),\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS(3600e9),\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS(86400e9);\n}\n\n@SinceKotlin(\"1.3\")\ninternal actual fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> value * (sourceUnit.scale / targetUnit.scale)\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale)\n        else -> value\n    }\n}\n\n@SinceKotlin(\"1.5\")\ninternal actual fun convertDurationUnitOverflow(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> value * (sourceUnit.scale / targetUnit.scale).toLong()\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale).toLong()\n        else -> value\n    }\n}\n\n@SinceKotlin(\"1.5\")\ninternal actual fun convertDurationUnit(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long {\n    val sourceCompareTarget = sourceUnit.scale.compareTo(targetUnit.scale)\n    return when {\n        sourceCompareTarget > 0 -> {\n            val scale = (sourceUnit.scale / targetUnit.scale).toLong()\n            val result = value * scale\n            when {\n                result / scale == value -> result\n                value > 0 -> Long.MAX_VALUE\n                else -> Long.MIN_VALUE\n            }\n        }\n        sourceCompareTarget < 0 -> value / (targetUnit.scale / sourceUnit.scale).toLong()\n        else -> value\n    }\n}\n\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Resizable-array implementation of the deque data structure.\n *\n * The name deque is short for \"double ended queue\" and is usually pronounced \"deck\".\n *\n * The collection provide methods for convenient access to the both ends.\n * It also implements [MutableList] interface and supports efficient get/set operations by index.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic class ArrayDeque<E> : AbstractMutableList<E> {\n    private var head: Int = 0\n    private var elementData: Array<Any?>\n\n    override var size: Int = 0\n        private set\n\n    /**\n     * Constructs an empty deque with specified [initialCapacity], or throws [IllegalArgumentException] if [initialCapacity] is negative.\n     */\n    public constructor(initialCapacity: Int) {\n        elementData = when {\n            initialCapacity == 0 -> emptyElementData\n            initialCapacity > 0 -> arrayOfNulls(initialCapacity)\n            else -> throw IllegalArgumentException(\"Illegal Capacity: $initialCapacity\")\n        }\n    }\n\n    /**\n     * Constructs an empty deque.\n     */\n    public constructor() {\n        elementData = emptyElementData\n    }\n\n    /**\n     * Constructs a deque that contains the same elements as the specified [elements] collection in the same order.\n     */\n    public constructor(elements: Collection<E>) {\n        elementData = elements.toTypedArray()\n        size = elementData.size\n        if (elementData.isEmpty()) elementData = emptyElementData\n    }\n\n    /**\n     * Ensures that the capacity of this deque is at least equal to the specified [minCapacity].\n     *\n     * If the current capacity is less than the [minCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    private fun ensureCapacity(minCapacity: Int) {\n        if (minCapacity < 0) throw IllegalStateException(\"Deque is too big.\")    // overflow\n        if (minCapacity <= elementData.size) return\n        if (elementData === emptyElementData) {\n            elementData = arrayOfNulls(minCapacity.coerceAtLeast(defaultMinCapacity))\n            return\n        }\n\n        val newCapacity = newCapacity(elementData.size, minCapacity)\n        copyElements(newCapacity)\n    }\n\n    /**\n     * Creates a new array with the specified [newCapacity] size and copies elements in the [elementData] array to it.\n     */\n    private fun copyElements(newCapacity: Int) {\n        val newElements = arrayOfNulls<Any?>(newCapacity)\n        elementData.copyInto(newElements, 0, head, elementData.size)\n        elementData.copyInto(newElements, elementData.size - head, 0, head)\n        head = 0\n        elementData = newElements\n    }\n\n    @kotlin.internal.InlineOnly\n    private inline fun internalGet(internalIndex: Int): E {\n        @Suppress(\"UNCHECKED_CAST\")\n        return elementData[internalIndex] as E\n    }\n\n    private fun positiveMod(index: Int): Int = if (index >= elementData.size) index - elementData.size else index\n\n    private fun negativeMod(index: Int): Int = if (index < 0) index + elementData.size else index\n\n    @kotlin.internal.InlineOnly\n    private inline fun internalIndex(index: Int): Int = positiveMod(head + index)\n\n    private fun incremented(index: Int): Int = if (index == elementData.lastIndex) 0 else index + 1\n\n    private fun decremented(index: Int): Int = if (index == 0) elementData.lastIndex else index - 1\n\n    override fun isEmpty(): Boolean = size == 0\n\n    /**\n     * Returns the first element, or throws [NoSuchElementException] if this deque is empty.\n     */\n    public fun first(): E = if (isEmpty()) throw NoSuchElementException(\"ArrayDeque is empty.\") else internalGet(head)\n\n    /**\n     * Returns the first element, or `null` if this deque is empty.\n     */\n    public fun firstOrNull(): E? = if (isEmpty()) null else internalGet(head)\n\n    /**\n     * Returns the last element, or throws [NoSuchElementException] if this deque is empty.\n     */\n    public fun last(): E = if (isEmpty()) throw NoSuchElementException(\"ArrayDeque is empty.\") else internalGet(internalIndex(lastIndex))\n\n    /**\n     * Returns the last element, or `null` if this deque is empty.\n     */\n    public fun lastOrNull(): E? = if (isEmpty()) null else internalGet(internalIndex(lastIndex))\n\n    /**\n     * Prepends the specified [element] to this deque.\n     */\n    public fun addFirst(element: E) {\n        ensureCapacity(size + 1)\n\n        head = decremented(head)\n        elementData[head] = element\n        size += 1\n    }\n\n    /**\n     * Appends the specified [element] to this deque.\n     */\n    public fun addLast(element: E) {\n        ensureCapacity(size + 1)\n\n        elementData[internalIndex(size)] = element\n        size += 1\n    }\n\n    /**\n     * Removes the first element from this deque and returns that removed element, or throws [NoSuchElementException] if this deque is empty.\n     */\n    public fun removeFirst(): E {\n        if (isEmpty()) throw NoSuchElementException(\"ArrayDeque is empty.\")\n\n        val element = internalGet(head)\n        elementData[head] = null\n        head = incremented(head)\n        size -= 1\n        return element\n    }\n\n    /**\n     * Removes the first element from this deque and returns that removed element, or returns `null` if this deque is empty.\n     */\n    public fun removeFirstOrNull(): E? = if (isEmpty()) null else removeFirst()\n\n    /**\n     * Removes the last element from this deque and returns that removed element, or throws [NoSuchElementException] if this deque is empty.\n     */\n    public fun removeLast(): E {\n        if (isEmpty()) throw NoSuchElementException(\"ArrayDeque is empty.\")\n\n        val internalLastIndex = internalIndex(lastIndex)\n        val element = internalGet(internalLastIndex)\n        elementData[internalLastIndex] = null\n        size -= 1\n        return element\n    }\n\n    /**\n     * Removes the last element from this deque and returns that removed element, or returns `null` if this deque is empty.\n     */\n    public fun removeLastOrNull(): E? = if (isEmpty()) null else removeLast()\n\n    // MutableList, MutableCollection\n    public override fun add(element: E): Boolean {\n        addLast(element)\n        return true\n    }\n\n    public override fun add(index: Int, element: E) {\n        AbstractList.checkPositionIndex(index, size)\n\n        if (index == size) {\n            addLast(element)\n            return\n        } else if (index == 0) {\n            addFirst(element)\n            return\n        }\n\n        ensureCapacity(size + 1)\n\n        // Elements in circular array lay in 2 ways:\n        //   1. `head` is less than `tail`:       [#, #, e1, e2, e3, #]\n        //   2. `head` is greater than `tail`:    [e3, #, #, #, e1, e2]\n        // where head is the index of the first element in the circular array,\n        // and tail is the index following the last element.\n        //\n        // At this point the insertion index is not equal to head or tail.\n        // Also the circular array can store at least one more element.\n        //\n        // Depending on where the given element must be inserted the preceding or the succeeding\n        // elements will be shifted to make room for the element to be inserted.\n        //\n        // In case the preceding elements are shifted:\n        //   * if the insertion index is greater than the head (regardless of circular array form)\n        //      -> shift the preceding elements\n        //   * otherwise, the circular array has (2) form and the insertion index is less than tail\n        //      -> shift all elements in the back of the array\n        //      -> shift preceding elements in the front of the array\n        // In case the succeeding elements are shifted:\n        //   * if the insertion index is less than the tail (regardless of circular array form)\n        //      -> shift the succeeding elements\n        //   * otherwise, the circular array has (2) form and the insertion index is greater than head\n        //      -> shift all elements in the front of the array\n        //      -> shift succeeding elements in the back of the array\n\n        val internalIndex = internalIndex(index)\n\n        if (index < (size + 1) shr 1) {\n            // closer to the first element -> shift preceding elements\n            val decrementedInternalIndex = decremented(internalIndex)\n            val decrementedHead = decremented(head)\n\n            if (decrementedInternalIndex >= head) {\n                elementData[decrementedHead] = elementData[head]  // head can be zero\n                elementData.copyInto(elementData, head, head + 1, decrementedInternalIndex + 1)\n            } else { // head > tail\n                elementData.copyInto(elementData, head - 1, head, elementData.size) // head can't be zero\n                elementData[elementData.size - 1] = elementData[0]\n                elementData.copyInto(elementData, 0, 1, decrementedInternalIndex + 1)\n            }\n\n            elementData[decrementedInternalIndex] = element\n            head = decrementedHead\n        } else {\n            // closer to the last element -> shift succeeding elements\n            val tail = internalIndex(size)\n\n            if (internalIndex < tail) {\n                elementData.copyInto(elementData, internalIndex + 1, internalIndex, tail)\n            } else { // head > tail\n                elementData.copyInto(elementData, 1, 0, tail)\n                elementData[0] = elementData[elementData.size - 1]\n                elementData.copyInto(elementData, internalIndex + 1, internalIndex, elementData.size - 1)\n            }\n\n            elementData[internalIndex] = element\n        }\n        size += 1\n    }\n\n    private fun copyCollectionElements(internalIndex: Int, elements: Collection<E>) {\n        val iterator = elements.iterator()\n\n        for (index in internalIndex until elementData.size) {\n            if (!iterator.hasNext()) break\n            elementData[index] = iterator.next()\n        }\n        for (index in 0 until head) {\n            if (!iterator.hasNext()) break\n            elementData[index] = iterator.next()\n        }\n\n        size += elements.size\n    }\n\n    public override fun addAll(elements: Collection<E>): Boolean {\n        if (elements.isEmpty()) return false\n        ensureCapacity(this.size + elements.size)\n        copyCollectionElements(internalIndex(size), elements)\n        return true\n    }\n\n    public override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        AbstractList.checkPositionIndex(index, size)\n\n        if (elements.isEmpty()) {\n            return false\n        } else if (index == size) {\n            return addAll(elements)\n        }\n\n        ensureCapacity(this.size + elements.size)\n\n        val tail = internalIndex(size)\n        val internalIndex = internalIndex(index)\n        val elementsSize = elements.size\n\n        if (index < (size + 1) shr 1) {\n            // closer to the first element -> shift preceding elements\n\n            var shiftedHead = head - elementsSize\n\n            if (internalIndex >= head) {\n                if (shiftedHead >= 0) {\n                    elementData.copyInto(elementData, shiftedHead, head, internalIndex)\n                } else { // head < tail, insertion leads to head >= tail\n                    shiftedHead += elementData.size\n                    val elementsToShift = internalIndex - head\n                    val shiftToBack = elementData.size - shiftedHead\n\n                    if (shiftToBack >= elementsToShift) {\n                        elementData.copyInto(elementData, shiftedHead, head, internalIndex)\n                    } else {\n                        elementData.copyInto(elementData, shiftedHead, head, head + shiftToBack)\n                        elementData.copyInto(elementData, 0, head + shiftToBack, internalIndex)\n                    }\n                }\n            } else { // head > tail, internalIndex < tail\n                elementData.copyInto(elementData, shiftedHead, head, elementData.size)\n                if (elementsSize >= internalIndex) {\n                    elementData.copyInto(elementData, elementData.size - elementsSize, 0, internalIndex)\n                } else {\n                    elementData.copyInto(elementData, elementData.size - elementsSize, 0, elementsSize)\n                    elementData.copyInto(elementData, 0, elementsSize, internalIndex)\n                }\n            }\n            head = shiftedHead\n            copyCollectionElements(negativeMod(internalIndex - elementsSize), elements)\n        } else {\n            // closer to the last element -> shift succeeding elements\n\n            val shiftedInternalIndex = internalIndex + elementsSize\n\n            if (internalIndex < tail) {\n                if (tail + elementsSize <= elementData.size) {\n                    elementData.copyInto(elementData, shiftedInternalIndex, internalIndex, tail)\n                } else { // head < tail, insertion leads to head >= tail\n                    if (shiftedInternalIndex >= elementData.size) {\n                        elementData.copyInto(elementData, shiftedInternalIndex - elementData.size, internalIndex, tail)\n                    } else {\n                        val shiftToFront = tail + elementsSize - elementData.size\n                        elementData.copyInto(elementData, 0, tail - shiftToFront, tail)\n                        elementData.copyInto(elementData, shiftedInternalIndex, internalIndex, tail - shiftToFront)\n                    }\n                }\n            } else { // head > tail, internalIndex > head\n                elementData.copyInto(elementData, elementsSize, 0, tail)\n                if (shiftedInternalIndex >= elementData.size) {\n                    elementData.copyInto(elementData, shiftedInternalIndex - elementData.size, internalIndex, elementData.size)\n                } else {\n                    elementData.copyInto(elementData, 0, elementData.size - elementsSize, elementData.size)\n                    elementData.copyInto(elementData, shiftedInternalIndex, internalIndex, elementData.size - elementsSize)\n                }\n            }\n            copyCollectionElements(internalIndex, elements)\n        }\n\n        return true\n    }\n\n    public override fun get(index: Int): E {\n        AbstractList.checkElementIndex(index, size)\n\n        return internalGet(internalIndex(index))\n    }\n\n    public override fun set(index: Int, element: E): E {\n        AbstractList.checkElementIndex(index, size)\n\n        val internalIndex = internalIndex(index)\n        val oldElement = internalGet(internalIndex)\n        elementData[internalIndex] = element\n\n        return oldElement\n    }\n\n    public override fun contains(element: E): Boolean = indexOf(element) != -1\n\n    public override fun indexOf(element: E): Int {\n        val tail = internalIndex(size)\n\n        if (head < tail) {\n            for (index in head until tail) {\n                if (element == elementData[index]) return index - head\n            }\n        } else if (head >= tail) {\n            for (index in head until elementData.size) {\n                if (element == elementData[index]) return index - head\n            }\n            for (index in 0 until tail) {\n                if (element == elementData[index]) return index + elementData.size - head\n            }\n        }\n\n        return -1\n    }\n\n    public override fun lastIndexOf(element: E): Int {\n        val tail = internalIndex(size)\n\n        if (head < tail) {\n            for (index in tail - 1 downTo head) {\n                if (element == elementData[index]) return index - head\n            }\n        } else if (head > tail) {\n            for (index in tail - 1 downTo 0) {\n                if (element == elementData[index]) return index + elementData.size - head\n            }\n            for (index in elementData.lastIndex downTo head) {\n                if (element == elementData[index]) return index - head\n            }\n        }\n\n        return -1\n    }\n\n    public override fun remove(element: E): Boolean {\n        val index = indexOf(element)\n        if (index == -1) return false\n        removeAt(index)\n        return true\n    }\n\n    public override fun removeAt(index: Int): E {\n        AbstractList.checkElementIndex(index, size)\n\n        if (index == lastIndex) {\n            return removeLast()\n        } else if (index == 0) {\n            return removeFirst()\n        }\n\n        val internalIndex = internalIndex(index)\n        val element = internalGet(internalIndex)\n\n        if (index < size shr 1) {\n            // closer to the first element -> shift preceding elements\n            if (internalIndex >= head) {\n                elementData.copyInto(elementData, head + 1, head, internalIndex)\n            } else { // head > tail, internalIndex < head\n                elementData.copyInto(elementData, 1, 0, internalIndex)\n                elementData[0] = elementData[elementData.size - 1]\n                elementData.copyInto(elementData, head + 1, head, elementData.size - 1)\n            }\n\n            elementData[head] = null\n            head = incremented(head)\n        } else {\n            // closer to the last element -> shift succeeding elements\n            val internalLastIndex = internalIndex(lastIndex)\n\n            if (internalIndex <= internalLastIndex) {\n                elementData.copyInto(elementData, internalIndex, internalIndex + 1, internalLastIndex + 1)\n            } else { // head > tail, internalIndex > head\n                elementData.copyInto(elementData, internalIndex, internalIndex + 1, elementData.size)\n                elementData[elementData.size - 1] = elementData[0]\n                elementData.copyInto(elementData, 0, 1, internalLastIndex + 1)\n            }\n\n            elementData[internalLastIndex] = null\n        }\n        size -= 1\n\n        return element\n    }\n\n    public override fun removeAll(elements: Collection<E>): Boolean = filterInPlace { !elements.contains(it) }\n\n    public override fun retainAll(elements: Collection<E>): Boolean = filterInPlace { elements.contains(it) }\n\n    private inline fun filterInPlace(predicate: (E) -> Boolean): Boolean {\n        if (this.isEmpty() || elementData.isEmpty())\n            return false\n\n        val tail = internalIndex(size)\n        var newTail = head\n        var modified = false\n\n        if (head < tail) {\n            for (index in head until tail) {\n                val element = elementData[index]\n\n                @Suppress(\"UNCHECKED_CAST\")\n                if (predicate(element as E))\n                    elementData[newTail++] = element\n                else\n                    modified = true\n            }\n\n            elementData.fill(null, newTail, tail)\n\n        } else {\n            for (index in head until elementData.size) {\n                val element = elementData[index]\n                elementData[index] = null\n\n                @Suppress(\"UNCHECKED_CAST\")\n                if (predicate(element as E))\n                    elementData[newTail++] = element\n                else\n                    modified = true\n            }\n\n            newTail = positiveMod(newTail)\n\n            for (index in 0 until tail) {\n                val element = elementData[index]\n                elementData[index] = null\n\n                @Suppress(\"UNCHECKED_CAST\")\n                if (predicate(element as E)) {\n                    elementData[newTail] = element\n                    newTail = incremented(newTail)\n                } else {\n                    modified = true\n                }\n            }\n        }\n        if (modified)\n            size = negativeMod(newTail - head)\n\n        return modified\n    }\n\n    public override fun clear() {\n        val tail = internalIndex(size)\n        if (head < tail) {\n            elementData.fill(null, head, tail)\n        } else if (isNotEmpty()) {\n            elementData.fill(null, head, elementData.size)\n            elementData.fill(null, 0, tail)\n        }\n        head = 0\n        size = 0\n    }\n\n    @Suppress(\"NOTHING_TO_OVERRIDE\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        @Suppress(\"UNCHECKED_CAST\")\n        val dest = (if (array.size >= size) array else arrayOfNulls(array, size)) as Array<Any?>\n\n        val tail = internalIndex(size)\n        if (head < tail) {\n            elementData.copyInto(dest, startIndex = head, endIndex = tail)\n        } else if (isNotEmpty()) {\n            elementData.copyInto(dest, destinationOffset = 0, startIndex = head, endIndex = elementData.size)\n            elementData.copyInto(dest, destinationOffset = elementData.size - head, startIndex = 0, endIndex = tail)\n        }\n        if (dest.size > size) {\n            dest[size] = null // null-terminate\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        return dest as Array<T>\n    }\n\n    @Suppress(\"NOTHING_TO_OVERRIDE\")\n    override fun toArray(): Array<Any?> {\n        return toArray(arrayOfNulls<Any?>(size))\n    }\n\n    // for testing\n    internal fun <T> testToArray(array: Array<T>): Array<T> = toArray(array)\n    internal fun testToArray(): Array<Any?> = toArray()\n\n    internal companion object {\n        private val emptyElementData = emptyArray<Any?>()\n        private const val maxArraySize = Int.MAX_VALUE - 8\n        private const val defaultMinCapacity = 10\n\n        internal fun newCapacity(oldCapacity: Int, minCapacity: Int): Int {\n            // overflow-conscious\n            var newCapacity = oldCapacity + (oldCapacity shr 1)\n            if (newCapacity - minCapacity < 0)\n                newCapacity = minCapacity\n            if (newCapacity - maxArraySize > 0)\n                newCapacity = if (minCapacity > maxArraySize) Int.MAX_VALUE else maxArraySize\n            return newCapacity\n        }\n    }\n\n    // For testing only\n    internal fun internalStructure(structure: (head: Int, elements: Array<Any?>) -> Unit) {\n        val tail = internalIndex(size)\n        val head = if (isEmpty() || head < tail) head else head - elementData.size\n        structure(head, toArray())\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Data class representing a value from a collection or sequence, along with its index in that collection or sequence.\n *\n * @property value the underlying value.\n * @property index the index of the value in the collection or sequence.\n */\npublic data class IndexedValue<out T>(public val index: Int, public val value: T)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n\n/**\n * Returns the given iterator itself. This allows to use an instance of iterator in a `for` loop.\n * @sample samples.collections.Iterators.iterator\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Iterator<T>.iterator(): Iterator<T> = this\n\n/**\n * Returns an [Iterator] that wraps each element produced by the original iterator\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * @sample samples.collections.Iterators.withIndexIterator\n */\npublic fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>> = IndexingIterator(this)\n\n/**\n * Performs the given [operation] on each element of this [Iterator].\n * @sample samples.collections.Iterators.forEachIterator\n */\npublic inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit): Unit {\n    for (element in this) operation(element)\n}\n\n/**\n * Iterator transforming original `iterator` into iterator of [IndexedValue], counting index from zero.\n */\ninternal class IndexingIterator<out T>(private val iterator: Iterator<T>) : Iterator<IndexedValue<T>> {\n    private var index = 0\n    final override fun hasNext(): Boolean = iterator.hasNext()\n    final override fun next(): IndexedValue<T> = IndexedValue(checkIndexOverflow(index++), iterator.next())\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.convertToSetForSetOperation()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.convertToSetForSetOperation())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.convertToSetForSetOperation())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.convertToSetForSetOperation()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence for the second time and the following times.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     *\n     * @sample samples.random.Randoms.nextBits\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextInt\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextLong\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + (nextInt().toLong() and 0xFFFF_FFFF)\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     *\n     * @sample samples.random.Randoms.nextBoolean\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextDouble\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextFloat\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random(), Serializable {\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        private object Serialized : Serializable {\n            private const val serialVersionUID = 0L\n\n            private fun readResolve(): Any = Random\n        }\n\n        private fun writeReplace(): Any = Serialized\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray =\n            defaultRandom.nextBytes(array, fromIndex, toIndex)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom internal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random(), Serializable {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n\n    private companion object {\n        private const val serialVersionUID: Long = 0L\n    }\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n/**\n * Represents a range of [Comparable] values.\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate open class ComparableOpenEndRange<T : Comparable<T>>(\n    override val start: T,\n    override val endExclusive: T\n) : OpenEndRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableOpenEndRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endExclusive == other.endExclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endExclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..<$endExclusive\"\n}\n\n/**\n * Creates an open-ended range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun <T : Comparable<T>> T.rangeUntil(that: T): OpenEndRange<T> = ComparableOpenEndRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n/**\n * An open-ended range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate class OpenEndDoubleRange(\n    start: Double,\n    endExclusive: Double\n) : OpenEndRange<Double> {\n    private val _start = start\n    private val _endExclusive = endExclusive\n    override val start: Double get() = _start\n    override val endExclusive: Double get() = _endExclusive\n\n    private fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value < _endExclusive\n    override fun isEmpty(): Boolean = !(_start < _endExclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is OpenEndDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endExclusive == other._endExclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endExclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..<$_endExclusive\"\n}\n\n/**\n * Creates an open-ended range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun Double.rangeUntil(that: Double): OpenEndRange<Double> = OpenEndDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * An open-ended range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate class OpenEndFloatRange(\n    start: Float,\n    endExclusive: Float\n) : OpenEndRange<Float> {\n    private val _start = start\n    private val _endExclusive = endExclusive\n    override val start: Float get() = _start\n    override val endExclusive: Float get() = _endExclusive\n\n    private fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value < _endExclusive\n    override fun isEmpty(): Boolean = !(_start < _endExclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is OpenEndFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endExclusive == other._endExclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endExclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..<$_endExclusive\"\n}\n\n/**\n * Creates an open-ended range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic operator fun Float.rangeUntil(that: Float): OpenEndRange<Float> = OpenEndFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : ClosedRange<T>, R : Iterable<T> =\n    element != null && contains(element)\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : OpenEndRange<T>, R : Iterable<T> =\n    element != null && contains(element)\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\n@kotlin.internal.IntrinsicConstEvaluation\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\n@kotlin.internal.IntrinsicConstEvaluation\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters) where both the lower and upper bounds are included in the range.\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T : Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     *\n     * A value belongs to the closed range if it is greater than or equal to the [start] bound and less than or equal to the [endInclusive] bound.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n\n/**\n * Represents a range of values (for example, numbers or characters) where the upper bound is not included in the range.\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\n@SinceKotlin(\"1.7\")\n@ExperimentalStdlibApi\npublic interface OpenEndRange<T : Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (exclusive).\n     *\n     * @throws IllegalStateException can be thrown if the exclusive end bound cannot be represented\n     * with a value of type [T].\n     */\n    public val endExclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     *\n     * A value belongs to the open-ended range if it is greater than or equal to the [start] bound and strictly less than the [endExclusive] bound.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value < endExclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The open-ended range is empty if its start value is greater than or equal to the end value.\n     */\n    public fun isEmpty(): Boolean = start >= endExclusive\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass()\n@file:kotlin.jvm.JvmName(\"DurationUnitKt\")\n\npackage kotlin.time\n\n\n/**\n * The list of possible time measurement units, in which a duration can be expressed.\n *\n * The smallest time unit is [NANOSECONDS] and the largest is [DAYS], which corresponds to exactly 24 [HOURS].\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic expect enum class DurationUnit {\n    /**\n     * Time unit representing one nanosecond, which is 1/1000 of a microsecond.\n     */\n    NANOSECONDS,\n    /**\n     * Time unit representing one microsecond, which is 1/1000 of a millisecond.\n     */\n    MICROSECONDS,\n    /**\n     * Time unit representing one millisecond, which is 1/1000 of a second.\n     */\n    MILLISECONDS,\n    /**\n     * Time unit representing one second.\n     */\n    SECONDS,\n    /**\n     * Time unit representing one minute.\n     */\n    MINUTES,\n    /**\n     * Time unit representing one hour.\n     */\n    HOURS,\n    /**\n     * Time unit representing one day, which is always equal to 24 hours.\n     */\n    DAYS;\n}\n\n/** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n@SinceKotlin(\"1.3\")\ninternal expect fun convertDurationUnit(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double\n\n// overflown result is unspecified\n@SinceKotlin(\"1.5\")\ninternal expect fun convertDurationUnitOverflow(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long\n\n// overflown result is coerced in the Long range boundaries\n@SinceKotlin(\"1.5\")\ninternal expect fun convertDurationUnit(value: Long, sourceUnit: DurationUnit, targetUnit: DurationUnit): Long\n\n\n@SinceKotlin(\"1.3\")\n@Suppress(\"REDUNDANT_ELSE_IN_WHEN\")\ninternal fun DurationUnit.shortName(): String = when (this) {\n    DurationUnit.NANOSECONDS -> \"ns\"\n    DurationUnit.MICROSECONDS -> \"us\"\n    DurationUnit.MILLISECONDS -> \"ms\"\n    DurationUnit.SECONDS -> \"s\"\n    DurationUnit.MINUTES -> \"m\"\n    DurationUnit.HOURS -> \"h\"\n    DurationUnit.DAYS -> \"d\"\n    else -> error(\"Unknown unit: $this\")\n}\n\n@SinceKotlin(\"1.5\")\ninternal fun durationUnitByShortName(shortName: String): DurationUnit = when (shortName) {\n    \"ns\" -> DurationUnit.NANOSECONDS\n    \"us\" -> DurationUnit.MICROSECONDS\n    \"ms\" -> DurationUnit.MILLISECONDS\n    \"s\" -> DurationUnit.SECONDS\n    \"m\" -> DurationUnit.MINUTES\n    \"h\" -> DurationUnit.HOURS\n    \"d\" -> DurationUnit.DAYS\n    else -> throw IllegalArgumentException(\"Unknown duration unit short name: $shortName\")\n}\n\n@SinceKotlin(\"1.5\")\ninternal fun durationUnitByIsoChar(isoChar: Char, isTimeComponent: Boolean): DurationUnit =\n    when {\n        !isTimeComponent -> {\n            when (isoChar) {\n                'D' -> DurationUnit.DAYS\n                else -> throw IllegalArgumentException(\"Invalid or unsupported duration ISO non-time unit: $isoChar\")\n            }\n        }\n        else -> {\n            when (isoChar) {\n                'H' -> DurationUnit.HOURS\n                'M' -> DurationUnit.MINUTES\n                'S' -> DurationUnit.SECONDS\n                else -> throw IllegalArgumentException(\"Invalid duration ISO time unit: $isoChar\")\n            }\n        }\n    }","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.native.concurrent.SharedImmutable\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces `StackOverflowError` because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.7\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.7\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.7\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\n@SharedImmutable\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@JvmInline\npublic value class UByteArray\n@PublishedApi\ninternal constructor(@PublishedApi internal val storage: ByteArray) : Collection<UByte> {\n\n    /** Creates a new array of the specified [size], with all elements initialized to zero. */\n    public constructor(size: Int) : this(ByteArray(size))\n\n    /**\n     * Returns the array element at the given [index]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun get(index: Int): UByte = storage[index].toUByte()\n\n    /**\n     * Sets the element at the given [index] to the given [value]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun set(index: Int, value: UByte) {\n        storage[index] = value.toByte()\n    }\n\n    /** Returns the number of elements in the array. */\n    public override val size: Int get() = storage.size\n\n    /** Creates an iterator over the elements of the array. */\n    public override operator fun iterator(): kotlin.collections.Iterator<UByte> = Iterator(storage)\n\n    private class Iterator(private val array: ByteArray) : kotlin.collections.Iterator<UByte> {\n        private var index = 0\n        override fun hasNext() = index < array.size\n        override fun next() = if (index < array.size) array[index++].toUByte() else throw NoSuchElementException(index.toString())\n    }\n\n    override fun contains(element: UByte): Boolean {\n        // TODO: Eliminate this check after KT-30016 gets fixed.\n        // Currently JS BE does not generate special bridge method for this method.\n        @Suppress(\"USELESS_CAST\")\n        if ((element as Any?) !is UByte) return false\n\n        return storage.contains(element.toByte())\n    }\n\n    override fun containsAll(elements: Collection<UByte>): Boolean {\n        return (elements as Collection<*>).all { it is UByte && storage.contains(it.toByte()) }\n    }\n\n    override fun isEmpty(): Boolean = this.storage.size == 0\n}\n\n/**\n * Creates a new array of the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each array element sequentially starting from the first one.\n * It should return the value for an array element given its index.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray(size: Int, init: (Int) -> UByte): UByteArray {\n    return UByteArray(ByteArray(size) { index -> init(index).toByte() })\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ubyteArrayOf(vararg elements: UByte): UByteArray = elements\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class ULong @kotlin.internal.IntrinsicConstEvaluation @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = div(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toULong()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toULong()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.mod(other.toULong()).toUInt()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = rem(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@JvmInline\npublic value class UIntArray\n@PublishedApi\ninternal constructor(@PublishedApi internal val storage: IntArray) : Collection<UInt> {\n\n    /** Creates a new array of the specified [size], with all elements initialized to zero. */\n    public constructor(size: Int) : this(IntArray(size))\n\n    /**\n     * Returns the array element at the given [index]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun get(index: Int): UInt = storage[index].toUInt()\n\n    /**\n     * Sets the element at the given [index] to the given [value]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun set(index: Int, value: UInt) {\n        storage[index] = value.toInt()\n    }\n\n    /** Returns the number of elements in the array. */\n    public override val size: Int get() = storage.size\n\n    /** Creates an iterator over the elements of the array. */\n    public override operator fun iterator(): kotlin.collections.Iterator<UInt> = Iterator(storage)\n\n    private class Iterator(private val array: IntArray) : kotlin.collections.Iterator<UInt> {\n        private var index = 0\n        override fun hasNext() = index < array.size\n        override fun next() = if (index < array.size) array[index++].toUInt() else throw NoSuchElementException(index.toString())\n    }\n\n    override fun contains(element: UInt): Boolean {\n        // TODO: Eliminate this check after KT-30016 gets fixed.\n        // Currently JS BE does not generate special bridge method for this method.\n        @Suppress(\"USELESS_CAST\")\n        if ((element as Any?) !is UInt) return false\n\n        return storage.contains(element.toInt())\n    }\n\n    override fun containsAll(elements: Collection<UInt>): Boolean {\n        return (elements as Collection<*>).all { it is UInt && storage.contains(it.toInt()) }\n    }\n\n    override fun isEmpty(): Boolean = this.storage.size == 0\n}\n\n/**\n * Creates a new array of the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each array element sequentially starting from the first one.\n * It should return the value for an array element given its index.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray(size: Int, init: (Int) -> UInt): UIntArray {\n    return UIntArray(IntArray(size) { index -> init(index).toInt() })\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun uintArrayOf(vararg elements: UInt): UIntArray = elements\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@OptIn(ExperimentalStdlibApi::class)\npublic class UIntRange(start: UInt, endInclusive: UInt) : UIntProgression(start, endInclusive, 1), ClosedRange<UInt>, OpenEndRange<UInt> {\n    override val start: UInt get() = first\n    override val endInclusive: UInt get() = last\n    \n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with UInt type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    override val endExclusive: UInt get() {\n        if (last == UInt.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1u\n    }\n\n    override fun contains(value: UInt): Boolean = first <= value && value <= last\n\n    /** \n     * Checks if the range is empty.\n     \n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type UInt. */\n        public val EMPTY: UIntRange = UIntRange(UInt.MAX_VALUE, UInt.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class UIntProgression\ninternal constructor(\n    start: UInt,\n    endInclusive: UInt,\n    step: Int\n) : Iterable<UInt> {\n    init {\n        if (step == 0.toInt()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: UInt = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: UInt = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    final override fun iterator(): Iterator<UInt> = UIntProgressionIterator(first, last, step)\n\n    /** \n     * Checks if the progression is empty.\n     \n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step.toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates UIntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression = UIntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `UInt`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\nprivate class UIntProgressionIterator(first: UInt, last: UInt, step: Int) : Iterator<UInt> {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toUInt() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun next(): UInt {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@JvmInline\npublic value class ULongArray\n@PublishedApi\ninternal constructor(@PublishedApi internal val storage: LongArray) : Collection<ULong> {\n\n    /** Creates a new array of the specified [size], with all elements initialized to zero. */\n    public constructor(size: Int) : this(LongArray(size))\n\n    /**\n     * Returns the array element at the given [index]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun get(index: Int): ULong = storage[index].toULong()\n\n    /**\n     * Sets the element at the given [index] to the given [value]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun set(index: Int, value: ULong) {\n        storage[index] = value.toLong()\n    }\n\n    /** Returns the number of elements in the array. */\n    public override val size: Int get() = storage.size\n\n    /** Creates an iterator over the elements of the array. */\n    public override operator fun iterator(): kotlin.collections.Iterator<ULong> = Iterator(storage)\n\n    private class Iterator(private val array: LongArray) : kotlin.collections.Iterator<ULong> {\n        private var index = 0\n        override fun hasNext() = index < array.size\n        override fun next() = if (index < array.size) array[index++].toULong() else throw NoSuchElementException(index.toString())\n    }\n\n    override fun contains(element: ULong): Boolean {\n        // TODO: Eliminate this check after KT-30016 gets fixed.\n        // Currently JS BE does not generate special bridge method for this method.\n        @Suppress(\"USELESS_CAST\")\n        if ((element as Any?) !is ULong) return false\n\n        return storage.contains(element.toLong())\n    }\n\n    override fun containsAll(elements: Collection<ULong>): Boolean {\n        return (elements as Collection<*>).all { it is ULong && storage.contains(it.toLong()) }\n    }\n\n    override fun isEmpty(): Boolean = this.storage.size == 0\n}\n\n/**\n * Creates a new array of the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each array element sequentially starting from the first one.\n * It should return the value for an array element given its index.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray(size: Int, init: (Int) -> ULong): ULongArray {\n    return ULongArray(LongArray(size) { index -> init(index).toLong() })\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ulongArrayOf(vararg elements: ULong): ULongArray = elements\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@OptIn(ExperimentalStdlibApi::class)\npublic class ULongRange(start: ULong, endInclusive: ULong) : ULongProgression(start, endInclusive, 1), ClosedRange<ULong>, OpenEndRange<ULong> {\n    override val start: ULong get() = first\n    override val endInclusive: ULong get() = last\n    \n    @SinceKotlin(\"1.7\")\n    @ExperimentalStdlibApi\n    @Deprecated(\"Can throw an exception when it's impossible to represent the value with ULong type, for example, when the range includes MAX_VALUE. It's recommended to use 'endInclusive' property that doesn't throw.\")\n    override val endExclusive: ULong get() {\n        if (last == ULong.MAX_VALUE) error(\"Cannot return the exclusive upper bound of a range that includes MAX_VALUE.\")\n        return last + 1u\n    }\n\n    override fun contains(value: ULong): Boolean = first <= value && value <= last\n\n    /** \n     * Checks if the range is empty.\n     \n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type ULong. */\n        public val EMPTY: ULongRange = ULongRange(ULong.MAX_VALUE, ULong.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class ULongProgression\ninternal constructor(\n    start: ULong,\n    endInclusive: ULong,\n    step: Long\n) : Iterable<ULong> {\n    init {\n        if (step == 0.toLong()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: ULong = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: ULong = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    final override fun iterator(): Iterator<ULong> = ULongProgressionIterator(first, last, step)\n\n    /** \n     * Checks if the progression is empty.\n     \n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt()) + (step xor (step ushr 32)).toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates ULongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression = ULongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `ULong`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\nprivate class ULongProgressionIterator(first: ULong, last: ULong, step: Long) : Iterator<ULong> {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toULong() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun next(): ULong {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// (a - b) mod c\nprivate fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\nprivate fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toUInt())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toUInt())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toULong())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toULong())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@JvmInline\npublic value class UShortArray\n@PublishedApi\ninternal constructor(@PublishedApi internal val storage: ShortArray) : Collection<UShort> {\n\n    /** Creates a new array of the specified [size], with all elements initialized to zero. */\n    public constructor(size: Int) : this(ShortArray(size))\n\n    /**\n     * Returns the array element at the given [index]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun get(index: Int): UShort = storage[index].toUShort()\n\n    /**\n     * Sets the element at the given [index] to the given [value]. This method can be called using the index operator.\n     *\n     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n     * where the behavior is unspecified.\n     */\n    public operator fun set(index: Int, value: UShort) {\n        storage[index] = value.toShort()\n    }\n\n    /** Returns the number of elements in the array. */\n    public override val size: Int get() = storage.size\n\n    /** Creates an iterator over the elements of the array. */\n    public override operator fun iterator(): kotlin.collections.Iterator<UShort> = Iterator(storage)\n\n    private class Iterator(private val array: ShortArray) : kotlin.collections.Iterator<UShort> {\n        private var index = 0\n        override fun hasNext() = index < array.size\n        override fun next() = if (index < array.size) array[index++].toUShort() else throw NoSuchElementException(index.toString())\n    }\n\n    override fun contains(element: UShort): Boolean {\n        // TODO: Eliminate this check after KT-30016 gets fixed.\n        // Currently JS BE does not generate special bridge method for this method.\n        @Suppress(\"USELESS_CAST\")\n        if ((element as Any?) !is UShort) return false\n\n        return storage.contains(element.toShort())\n    }\n\n    override fun containsAll(elements: Collection<UShort>): Boolean {\n        return (elements as Collection<*>).all { it is UShort && storage.contains(it.toShort()) }\n    }\n\n    override fun isEmpty(): Boolean = this.storage.size == 0\n}\n\n/**\n * Creates a new array of the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each array element sequentially starting from the first one.\n * It should return the value for an array element given its index.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray(size: Int, init: (Int) -> UShort): UShortArray {\n    return UShortArray(ShortArray(size) { index -> init(index).toShort() })\n}\n\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ushortArrayOf(vararg elements: UShort): UShortArray = elements\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"UStringsKt\")  // string representation of unsigned numbers\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UByte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UShort.toString(radix: Int): String = this.toInt().toString(radix)\n\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n//@kotlin.internal.InlineOnly\npublic /*inline*/ fun UInt.toString(radix: Int): String = this.toLong().toString(radix)\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun ULong.toString(radix: Int): String = ulongToString(this.toLong(), checkRadix(radix))\n\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByte(): UByte = toUByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [UByte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByte(radix: Int): UByte = toUByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShort(): UShort = toUShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [UShort] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShort(radix: Int): UShort = toUShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUInt(): UInt = toUIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [UInt] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUInt(radix: Int): UInt = toUIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULong(): ULong = toULongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [ULong] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULong(radix: Int): ULong = toULongOrNull(radix) ?: numberFormatError(this)\n\n\n\n\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByteOrNull(): UByte? = toUByteOrNull(radix = 10)\n\n/**\n * Parses the string as an [UByte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUByteOrNull(radix: Int): UByte? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UByte.MAX_VALUE) return null\n    return int.toUByte()\n}\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShortOrNull(): UShort? = toUShortOrNull(radix = 10)\n\n/**\n * Parses the string as an [UShort] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUShortOrNull(radix: Int): UShort? {\n    val int = this.toUIntOrNull(radix) ?: return null\n    if (int > UShort.MAX_VALUE) return null\n    return int.toUShort()\n}\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUIntOrNull(): UInt? = toUIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [UInt] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toUIntOrNull(radix: Int): UInt? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: UInt = UInt.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n    val limitForMaxRadix = 119304647u  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toUInt()\n    var result = 0u\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULongOrNull(): ULong? = toULongOrNull(radix = 10)\n\n/**\n * Parses the string as an [ULong] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun String.toULongOrNull(radix: Int): ULong? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val limit: ULong = ULong.MAX_VALUE\n    val start: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {\n        if (length == 1 || firstChar != '+') return null\n        start = 1\n    } else {\n        start = 0\n    }\n\n\n    val limitForMaxRadix = 512409557603043100uL  //  limit / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    val uradix = radix.toULong()\n    var result = 0uL\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result > limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / uradix\n\n                if (result > limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= uradix\n\n        val beforeAdding = result\n        result += digit.toUInt()\n        if (result < beforeAdding) return null // overflow has happened\n    }\n\n    return result\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.minus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] array.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Set<T>.minus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] collection.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Set<T>.minus(elements: Iterable<T>): Set<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toSet()\n    if (other is Set)\n        return this.filterNotTo(LinkedHashSet<T>()) { it in other }\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(other)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] sequence.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Set<T>.minus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.minusElement(element: T): Set<T> {\n    return minus(element)\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size + 1))\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] array,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size + elements.size))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] collection,\n * which aren't already in this set.\n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Iterable<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(elements.collectionSizeOrNull()?.let { this.size + it } ?: this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] sequence,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.plusElement(element: T): Set<T> {\n    return plus(element)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.reflect.KClass\n\n@PublishedApi\ninternal fun <T : Annotation> KClass<*>.findAssociatedObject(@Suppress(\"UNUSED_PARAMETER\") annotationClass: KClass<T>): Any? {\n    // This API is not supported in js-v1. Return `null` to be source-compatible with js-ir.\n    return null\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.cancellation\n\n@SinceKotlin(\"1.4\")\npublic actual open class CancellationException : IllegalStateException {\n    actual constructor() : super()\n    actual constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * An interface for indexing access to a collection of key-value pairs, where type of key is [String] and type of value is [Any?][Any].\n */\npublic external interface Json {\n    /**\n     * Calls to the function will be translated to indexing operation (square brackets) on the receiver with [propertyName] as the argument.\n     *\n     * E.g. for next code:\n     * ```kotlin\n     * fun test(j: Json, p: String) = j[\"prop\"] + j.get(p)\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p) {\n     *     return j[\"prop\"] + j[p];\n     * }\n     * ```\n     */\n    operator fun get(propertyName: String): Any?\n\n    /**\n     * Calls of the function will be translated to an assignment of [value] to the receiver indexed (with square brackets/index operation) with [propertyName].\n     *\n     * E.g. for the following code:\n     * ```kotlin\n     * fun test(j: Json, p: String, newValue: Any) {\n     *     j[\"prop\"] = 1\n     *     j.set(p, newValue)\n     * }\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p, newValue) {\n     *     j[\"prop\"] = 1;\n     *     j[p] = newValue;\n     * }\n     * }\n     * ```\n     */\n    operator fun set(propertyName: String, value: Any?): Unit\n}\n\n/**\n * Returns a simple JavaScript object (as [Json]) using provided key-value pairs as names and values of its properties.\n */\npublic fun json(vararg pairs: Pair<String, Any?>): Json {\n    val res: dynamic = js(\"({})\")\n    for ((name, value) in pairs) {\n        res[name] = value\n    }\n    return res\n}\n\n/**\n * Adds key-value pairs from [other] to [this].\n * Returns the original receiver.\n */\npublic fun Json.add(other: Json): Json {\n    val keys: Array<String> = js(\"Object\").keys(other)\n    for (key in keys) {\n        if (other.asDynamic().hasOwnProperty(key)) {\n            this[key] = other[key];\n        }\n    }\n    return this\n}\n\n/**\n * Exposes the JavaScript [JSON object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external object JSON {\n    public fun stringify(o: Any?): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: Int): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: String): String\n    public fun stringify(o: Any?, replacer: Array<String>): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: Int): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: String): String\n\n    public fun <T> parse(text: String): T\n    public fun <T> parse(text: String, reviver: ((key: String, value: Any?) -> Any?)): T\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\nimport getKClass\nimport kotlin.reflect.KClass\nimport kotlin.reflect.js.internal.KClassImpl\n\n/**\n * Represents the constructor of a class. Instances of `JsClass` can be passed to JavaScript APIs that expect a constructor reference.\n */\nexternal interface JsClass<T : Any> {\n    /**\n     * Returns the unqualified name of the class represented by this instance.\n     */\n    val name: String\n}\n\n/**\n * Obtains a constructor reference for the given `KClass`.\n */\nval <T : Any> KClass<T>.js: JsClass<T>\n    get() = (this as KClassImpl<T>).jClass\n\n/**\n * Obtains a `KClass` instance for the given constructor reference.\n */\nval <T : Any> JsClass<T>.kotlin: KClass<T>\n    get() = getKClass(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n// TODO: Remove once JsReflectionAPICallChecker supports more reflection types\n@file:Suppress(\"Unsupported\")\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"createKType\")\ninternal fun createKType(\n    classifier: KClassifier,\n    arguments: Array<KTypeProjection>,\n    isMarkedNullable: Boolean\n) =\n    KTypeImpl(classifier, arguments.asList(), isMarkedNullable)\n\n@JsName(\"createDynamicKType\")\ninternal fun createDynamicKType(): KType = DynamicKType\n\n@JsName(\"markKTypeNullable\")\ninternal fun markKTypeNullable(kType: KType) = KTypeImpl(kType.classifier!!, kType.arguments, true)\n\n@JsName(\"createKTypeParameter\")\ninternal fun createKTypeParameter(\n    name: String,\n    upperBounds: Array<KType>,\n    variance: String\n): KTypeParameter {\n    val kVariance = when (variance) {\n        \"in\" -> KVariance.IN\n        \"out\" -> KVariance.OUT\n        else -> KVariance.INVARIANT\n    }\n\n    return KTypeParameterImpl(name, upperBounds.asList(), kVariance, false)\n}\n\n@JsName(\"getStarKTypeProjection\")\ninternal fun getStarKTypeProjection(): KTypeProjection =\n    KTypeProjection.STAR\n\n@JsName(\"createCovariantKTypeProjection\")\ninternal fun createCovariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.covariant(type)\n\n@JsName(\"createInvariantKTypeProjection\")\ninternal fun createInvariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.invariant(type)\n\n@JsName(\"createContravariantKTypeProjection\")\ninternal fun createContravariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.contravariant(type)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.randomOrNull(): UInt? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.randomOrNull(): ULong? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.randomOrNull(): UByte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.randomOrNull(): UShort? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UIntArray.randomOrNull(random: Random): UInt? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ULongArray.randomOrNull(random: Random): ULong? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UByteArray.randomOrNull(random: Random): UByte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UShortArray.randomOrNull(random: Random): UShort? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray?.contentEquals(other: UIntArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray?.contentEquals(other: ULongArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray?.contentEquals(other: UByteArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray?.contentEquals(other: UShortArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.fill(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toInt(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.fill(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toLong(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.fill(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toByte(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.fill(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toShort(), fromIndex, toIndex)\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.associateWith(valueSelector: (UInt) -> V): Map<UInt, V> {\n    val result = LinkedHashMap<UInt, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.associateWith(valueSelector: (ULong) -> V): Map<ULong, V> {\n    val result = LinkedHashMap<ULong, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.associateWith(valueSelector: (UByte) -> V): Map<UByte, V> {\n    val result = LinkedHashMap<UByte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.associateWith(valueSelector: (UShort) -> V): Map<UShort, V> {\n    val result = LinkedHashMap<UShort, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UInt, in V>> UIntArray.associateWithTo(destination: M, valueSelector: (UInt) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in ULong, in V>> ULongArray.associateWithTo(destination: M, valueSelector: (ULong) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UByte, in V>> UByteArray.associateWithTo(destination: M, valueSelector: (UByte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UShort, in V>> UShortArray.associateWithTo(destination: M, valueSelector: (UShort) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMapIndexed(transform: (index: Int, UInt) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMapIndexed(transform: (index: Int, ULong) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMapIndexed(transform: (index: Int, UByte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMapIndexed(transform: (index: Int, UShort) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapIndexedTo(destination: C, transform: (index: Int, UInt) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapIndexedTo(destination: C, transform: (index: Int, ULong) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, UByte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, UShort) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UIntArray.max(): UInt {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ULongArray.max(): ULong {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UByteArray.max(): UByte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UShortArray.max(): UShort {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxOrNull(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxOrNull(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxOrNull(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxOrNull(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UIntArray.min(): UInt {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ULongArray.min(): ULong {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UByteArray.min(): UByte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UShortArray.min(): UShort {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow-U\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minOrNull(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minOrNull(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minOrNull(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minOrNull(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow-U\")\n@ExperimentalUnsignedTypes\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEach(action: (UInt) -> Unit): UIntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEach(action: (ULong) -> Unit): ULongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEach(action: (UByte) -> Unit): UByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEach(action: (UShort) -> Unit): UShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEachIndexed(action: (index: Int, UInt) -> Unit): UIntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEachIndexed(action: (index: Int, ULong) -> Unit): ULongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEachIndexed(action: (index: Int, UByte) -> Unit): UByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEachIndexed(action: (index: Int, UShort) -> Unit): UShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexedOrNull(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexedOrNull(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexedOrNull(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexedOrNull(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceOrNull(operation: (acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceOrNull(operation: (acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceOrNull(operation: (acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceOrNull(operation: (acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexedOrNull(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexedOrNull(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexedOrNull(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexedOrNull(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightOrNull(operation: (UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightOrNull(operation: (ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightOrNull(operation: (UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightOrNull(operation: (UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFold(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFold(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFold(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFold(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scan(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scan(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scan(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scan(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumOf { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumOf { it.toUInt() }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect\n\nimport findAssociatedObject\n\n/**\n * The experimental marker for associated objects API.\n *\n * Any usage of a declaration annotated with `@ExperimentalAssociatedObjects` must be accepted either by\n * annotating that usage with the [OptIn] annotation, e.g. `@OptIn(ExperimentalAssociatedObjects::class)`,\n * or by using the compiler argument `-opt-in=kotlin.reflect.ExperimentalAssociatedObjects`.\n */\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Retention(value = AnnotationRetention.BINARY)\npublic annotation class ExperimentalAssociatedObjects\n\n/**\n * Makes the annotated annotation class an associated object key.\n *\n * An associated object key annotation should have single [KClass] parameter.\n * When applied to a class with reference to an object declaration as an argument, it binds\n * the object to the class, making this binding discoverable at runtime using [findAssociatedObject].\n */\n@ExperimentalAssociatedObjects\n@Retention(AnnotationRetention.BINARY)\n@Target(AnnotationTarget.ANNOTATION_CLASS)\npublic annotation class AssociatedObjectKey\n\n/**\n * If [T] is an @[AssociatedObjectKey]-annotated annotation class and [this] class is annotated with @[T] (`S::class`),\n * returns object `S`.\n *\n * Otherwise returns `null`.\n */\n@ExperimentalAssociatedObjects\npublic inline fun <reified T : Annotation> KClass<*>.findAssociatedObject(): Any? =\n    this.findAssociatedObject(T::class)",null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"GroupingKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.collections\n\n/**\n * Represents a source of elements with a [keyOf] function, which can be applied to each element to get its key.\n *\n * A [Grouping] structure serves as an intermediate step in group-and-fold operations:\n * they group elements by their keys and then fold each group with some aggregating operation.\n *\n * It is created by attaching `keySelector: (T) -> K` function to a source of elements.\n * To get an instance of [Grouping] use one of `groupingBy` extension functions:\n * - [Iterable.groupingBy]\n * - [Sequence.groupingBy]\n * - [Array.groupingBy]\n * - [CharSequence.groupingBy]\n *\n * For the list of group-and-fold operations available, see the [extension functions](#extension-functions) for `Grouping`.\n */\n@SinceKotlin(\"1.1\")\npublic interface Grouping<T, out K> {\n    /** Returns an [Iterator] over the elements of the source of this grouping. */\n    fun sourceIterator(): Iterator<T>\n    /** Extracts the key of an [element]. */\n    fun keyOf(element: T): K\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation function is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * @return a [Map] associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadix\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.aggregate(\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): Map<K, R> {\n    return aggregateTo(mutableMapOf<K, R>(), operation)\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n *\n * The key for each element is provided by the [Grouping.keyOf] function.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group, can be `null` if it's the first `element` encountered in the group;\n *  - `element`: the element from the source being aggregated;\n *  - `first`: indicates whether it's the first `element` encountered in the group.\n *\n * If the [destination] map already has a value corresponding to some key,\n * then the elements being aggregated for that key are never considered as `first`.\n *\n * @return the [destination] map associating the key of each group with the result of aggregation of the group elements.\n * @sample samples.collections.Grouping.aggregateByRadixTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(\n    destination: M,\n    operation: (key: K, accumulator: R?, element: T, first: Boolean) -> R\n): M {\n    for (e in this.sourceIterator()) {\n        val key = keyOf(e)\n        val accumulator = destination[key]\n        destination[key] = operation(key, accumulator, e, accumulator == null && !destination.containsKey(key))\n    }\n    return destination\n}\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is provided by [initialValueSelector] function.\n *\n * @param initialValueSelector a function that provides an initial value of accumulator for each group.\n *  It's invoked with parameters:\n *  - `key`: the key of the group;\n *  - `element`: the first element being encountered in that group.\n *\n * If the [destination] map already has a value corresponding to some key, that value is used as an initial value of\n * the accumulator for that group and the [initialValueSelector] function is not called for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithComputedInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValueSelector: (key: K, element: T) -> R,\n    operation: (key: K, accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { key, acc, e, first -> operation(key, if (first) initialValueSelector(key, e) else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments, and stores the results in a new map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValue\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R> Grouping<T, K>.fold(\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): Map<K, R> =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregate { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n/**\n * Groups elements from the [Grouping] source by key and applies [operation] to the elements of each group sequentially,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the same [initialValue] for each group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group.\n *\n * @param operation a function that is invoked on each element with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.foldByEvenLengthWithConstantInitialValueTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(\n    destination: M,\n    initialValue: R,\n    operation: (accumulator: R, element: T) -> R\n): M =\n    @Suppress(\"UNCHECKED_CAST\")\n    aggregateTo(destination) { _, acc, e, first -> operation(if (first) initialValue else acc as R, e) }\n\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in a new map.\n * An initial value of accumulator is the first element of the group.\n *\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `key`: the key of the group this element belongs to;\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being accumulated.\n *\n * @return a [Map] associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowels\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K> Grouping<T, K>.reduce(\n    operation: (key: K, accumulator: S, element: T) -> S\n): Map<K, S> =\n    aggregate { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n/**\n * Groups elements from the [Grouping] source by key and applies the reducing [operation] to the elements of each group\n * sequentially starting from the second element of the group,\n * passing the previously accumulated value and the current element as arguments,\n * and stores the results in the given [destination] map.\n * An initial value of accumulator is the first element of the group.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the accumulator for that group and the first element of that group is also\n * subjected to the [operation].\n\n * @param operation a function that is invoked on each subsequent element of the group with the following parameters:\n *  - `accumulator`: the current value of the accumulator of the group;\n *  - `element`: the element from the source being folded;\n *\n * @return the [destination] map associating the key of each group with the result of accumulating the group elements.\n * @sample samples.collections.Grouping.reduceByMaxVowelsTo\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T, K>.reduceTo(\n    destination: M,\n    operation: (key: K, accumulator: S, element: T) -> S\n): M =\n    aggregateTo(destination) { key, acc, e, first ->\n        @Suppress(\"UNCHECKED_CAST\")\n        if (first) e else operation(key, acc as S, e)\n    }\n\n\n/**\n * Groups elements from the [Grouping] source by key and counts elements in each group to the given [destination] map.\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the counter for that group.\n *\n * @return the [destination] map associating the key of each group with the count of elements in the group.\n *\n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M): M =\n    foldTo(destination, 0) { acc, _ -> acc + 1 }\n\n/*\n/**\n * Groups elements from the [Grouping] source by key and sums values provided by the [valueSelector] function for elements in each group\n * to the given [destination] map.\n *\n *\n * If the [destination] map already has a value corresponding to the key of some group,\n * that value is used as an initial value of the sum for that group.\n *\n * @return the [destination] map associating the key of each group with the sum of elements in the group.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachSumOfTo(destination: M, valueSelector: (T) -> Int): M =\n        foldTo(destination, 0) { acc, e -> acc + valueSelector(e)}\n*/\n\n\n/*\n// TODO: sum by long and by double overloads\n\npublic inline fun <T, K, M : MutableMap<in K, Long>> Grouping<T, K>.sumEachByLongTo(destination: M, valueSelector: (T) -> Long): M =\n        foldTo(destination, 0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByLong(valueSelector: (T) -> Long): Map<K, Long> =\n        fold(0L) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K, M : MutableMap<in K, Double>> Grouping<T, K>.sumEachByDoubleTo(destination: M, valueSelector: (T) -> Double): M =\n        foldTo(destination, 0.0) { acc, e -> acc + valueSelector(e)}\n\npublic inline fun <T, K> Grouping<T, K>.sumEachByDouble(valueSelector: (T) -> Double): Map<K, Double> =\n        fold(0.0) { acc, e -> acc + valueSelector(e)}\n*/\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.internal.InlineOnly\n\n\n/**\n * Returns a hash code value for the object or zero if the object is `null`.\n *\n * @see Any.hashCode\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun Any?.hashCode(): Int = this?.hashCode() ?: 0\n",null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOf(transform: (Map.Entry<K, V>) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the map was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOfOrNull(transform: (Map.Entry<K, V>) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the map is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V> {\n    return entries.maxBy(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V> {\n    return entries.maxWith(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the map is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V> {\n    return entries.minBy(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@kotlin.internal.InlineOnly\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V> {\n    return entries.minWith(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(544);\n"],"names":["root","factory","exports","module","define","amd","this","pow","array","i","points","size","IndexOutOfBoundsException","index","checkIndexOverflow","item","x","y","n","maxTriangles","triangles","halfedges","sqrt","ceil","list","minX","POSITIVE_INFINITY","minY","maxX","maxY","ids","minDist","i0","i1","i2","cx","cy","d","i0x","i0y","i1x","i1y","minRadius","r","i2x","i2y","center","dists","xp","yp","k","abs","start","key","j","e","q","t","next","s","clear","copyToArray","take","Point","other","floor","dx","dy","p","ar","a","a0","b","b0","al","bl","p0","pr","pl","p1","hbl","br","ax","px","ay","py","bx","by","ex","ey","fx","fy","cp","bp","cl","right","left","temp","tempDist","median","arr","tmp","qy","rx","qx","ry","c","collectionSizeOrDefault","destination","Edge","first","id","map","edges","VoronoiCell","toList","vertices","sequence","accumulatedArea","centerX","centerY","listOf","outgoing","Entity","editor","Ray","Sphere","COLOR_YELLOW","COLOR_CYAN","COLOR_GREEN","COLOR_GRAY","COLOR_MAGENTA","COLOR_LIGHT_RED","COLOR_LIGHT_BLUE","COLOR_LIGHT_GREEN","HistoryItem","OrthoCamera","Plane","Vec3","Mat4","setIdentity","History","UiEvent","MOUSE_BUTTON_MIDDLE","MOUSE_BUTTON_RIGHT","Viewport","Color","prettyPrint","gloo","ImmediateMode","COLORS","idx","input","pos","type","srcMat","destMat","event","MOUSE_DOWN","nearestDestControlPoint","nearestSrcControlPoint","cam","intersect","mat","isNotNaN","MOUSE_MOVE","inversed","invMat","plane","setMult","intersVecTransformed","MOUSE_UP","history","v","setMultFree","norm","color","COLOR_RED","scaledSz","println","joinToString","removeLastOrNull","Random","rnd","nextFloat","xDst","yDst","ControlPoint","newControlPoint","newDestPoint","delaunatorPoints","controlPoint","Delaunator","KEY_Z","undo","element","point","KEY_D","KEY_S","save","KEY_O","load","SCROLL","w","translateMat","z","scaleMat","button","FILE_DROPPED","srcTexture","droppedImage","width","height","destTexture","KEY_Q","coerceIn","KEY_W","viewport","h","gl","COLOR_BLACK","GL","GL_SCISSOR_TEST","v0","lineZ","v1","v2","COLOR_WHITE","aspect","destCursorPosTransformed","srcCursorPosTransformed","iterator","hasNext","minElem","minValue","sq","it","vertsCount","srcAspect","from1","tv0","x1","y1","tv1","x2","y2","tv2","x3","y3","p2","dstAspect","resCam","createFramebuffer","Texture2D","createTexture","frameTexture","createData","fb","bind","checkStatus","IDENT","filepath","unbind","toString","Json","WrpFormat","data","arrayCopy","dstMat","srcPoints","dstPoints","saveFile","json","YaGamesJsPlayer","WarperEditor","player","entity","launch","GlobalScope","value","Analytics","Vec4","red","green","blue","alpha","g","idCounter","parent","Cam","FloatArr","capacity","typedArr","buf","offset","length","createScreenFramebufferHandle","allocsCount","raytrace","drawCallsCount","drawVertsCount","glBufUploads","glBufUploadBytes","bytesCount","tagToCount","tag","MutableInt","answer","entries","values","emptyMap","analytics","analytic","printStackTrace","color1","color2","childs","active","dt","unused1","unused2","FAKE_VIEWPORT","recalc","newFov","newNear","newFar","newPos","newUp","newDir","dir","normalize","worldUp","up","viewMatrix","projMatrix","degToRad","fov","near","far","ray","origin","setZero","l","cz","sz","top","bottom","winY","m","verFov","horFov","menuViewport","viewPort","f","newarr","lengthField","GL_FRAMEBUFFER","handle","ScreenHandle","GL_COLOR_ATTACHMENT0","GL_TEXTURE_2D","texture","status","GL_FRAMEBUFFER_COMPLETE","ShaderType","BufferTarget","BufferUsage","DataType","DrawMode","ProgramQuery","ShaderQuery","shader","compilationLog","isBlank","program","linkLog","location","normalized","stride","pointer","errorChecking","glGetError","err","GL_NO_ERROR","GL_TEXTURE0","unit","checkErrors","GL_RGBA","GL_UNSIGNED_BYTE","usage","STATIC_DRAW","PERF_TRACKER","floatBuffer","ARRAY_BUFFER","texUnit","GL_FLOAT","name","Uniform1f","Uniform2f","Uniform3f","Uniform4f","UniformMat4f","UniformSampler2D","Attrib4f","Attrib3f","Attrib2f","Attrib1f","createBuffer","Buffer","VERTEX_SHADER","code","VertexShader","FRAGMENT_SHADER","FragmentShader","createProgram","vertexShaderCode","fragmentShaderCode","programHandle","vertesShader","fragmentShader","ShaderProgram","textureHandle","Framebuffer","genFramebuffer","horizontal","trimIndent","prog","compress","maxCountInLine","countInLine","btnText","max","count","linePosBuf","lineColorBuf","texCoordsBuf","use","cachedColoredShader","ColoredShader","cachedLightingShader","LightingShader","cachedCardShader","CardShader","cachedTableShader","TableShader","cachedTexturedShader","TexturedShader","cachedSdfFontShader","SdfFontShader","posFB","z1","z2","hsz","COLOR_BLUE","modelMat","prepareBuffers","uModel","uProj","uView","aPos","aColor","GL_LINES","GL_TRIANGLES","texShader","uTexture","aTexCoord","trackVec","NaN","KEY_E","KEY_R","KEY_T","KEY_Y","KEY_U","KEY_I","KEY_P","KEY_A","KEY_F","KEY_G","KEY_H","KEY_J","KEY_K","KEY_L","KEY_X","KEY_C","KEY_V","KEY_B","KEY_N","KEY_M","KEY_ARROW_UP","KEY_ARROW_DOWN","KEY_ARROW_LEFT","KEY_ARROW_RIGHT","KEY_ENTER","KEY_SPACE","KEY_BACKSPACE","horAlign","ALIGN_CENTER","verAlign","weight","edge","outlineColor","textVertsCount","calcWidth","text","calcHeight","textWidth","textHeight","x0","fixX","screenX","screenX0","screenY","y0","zz","ch","font","charmap","sdfChar","screenW","screenH","uFontTexture","uColor","uWeight","uThreshold","aCoord","renderNormals","mesh","posBuf","z0","normalsBuf","NORM_COEFF","nx0","ny0","nz0","nx1","ny1","nz1","nx2","ny2","nz2","meshColor","reset","uLightColor","uLightPos","aNormal","GL_DEPTH_TEST","shadowSz","rr","uOrigin","uSize","uShadowColor","uCornerR","uShadowSz","deg","F_PI","events","consumed","codeblock","countTouched","pointerId","TOUCH_DOWN","POINTER_DOWN","POINTER_MOVE","POINTER_UP","TOUCH_UP","print","scope","job","join","newX","newY","newZ","fill","col","row","tx","ty","tz","oc","sx","sy","A","B","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","c10","c11","c12","c13","c14","c15","fX","eye","fY","fZ","inv","sX","sY","sZ","uX","uY","uZ","fovY","tanHalfFovy","o","dist","invD","res","trackUiEvent","defValue","toInt","emptyList","onOpen","onClose","onError","dropped","mobilePlatforms","isEmpty","window","navigator","userAgent","hasTouchUi","document","createElement","pom","setAttribute","encodeURIComponent","content","filename","click","dataUrl","Float32Array","ParallelLoader","HowlerSoundManager","YaGamesAds","undefined","yaGamesSafeStorage","JsLocalStorage","YaGamesSafeStorage","CombinedAnalytics","JsYaMetricaAnalytics","yaMetricaId","PrintAnalytics","YaGamesLeaderBoard","leaderBoardName","stopPropagation","preventDefault","dataTransfer","endsWith","fileItem","imageFile","now","innerWidth","devicePixelRatio","innerHeight","pollKeyboard","pollMouse","translateEventsToState","currentTimeSeconds","clearEvents","requestAnimationFrame","Image","img","onload","DroppedImage","src","target","result","FramebufferHandle","intercepted","safe","getOrThrow","texImage2D","GL_TEXTURE_MAG_FILTER","GL_LINEAR","GL_TEXTURE_MIN_FILTER","POWERS_OF_TWO","GL_TEXTURE_WRAP_S","GL_REPEAT","GL_TEXTURE_WRAP_T","GL_CLAMP_TO_EDGE","Pair","Result","Keyboard","addEventListener","deltaX","deltaY","deltaZ","deltaMode","wheelSens","hasHardwareKeyboard","offsetX","dp","offsetY","uiEvent","mouseBtn","changedTouches","touchList","touch","offsetLeft","offsetTop","identifier","FOCUSED","UNFOCUSED","SoundBuffer","SoundManager","Storage","localStorage","Ads","ysdk","performance","yaGamesLeaderBoard","arrayOfPairs","ym","jsMap","getElementById","getContext","mapOf","JsKeyboard","WebGL","webglContext","canvas","clientWidth","clientHeight","init","GLOO","loader","frameFunc","focused","Camera","PlainCamera","GL_CULL_FACE","GL_BACK","GL_BLEND","GL_SRC_ALPHA","GL_ONE_MINUS_SRC_ALPHA","FileReader","imgReader","readAsDataURL","WebGLRenderingContext","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","clearColor","ShaderHandle","createShader","shaderSource","compileShader","ProgramHandle","attachShader","linkProgram","useProgram","getUniformLocation","uniformName","UniformLocation","uniform1f","uniform2f","uniform3f","uniform4f","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","uniform1i","AttribLocation","getAttribLocation","attribName","vertexAttribPointer","coordsPerVertex","countVerts","drawArrays","mode","BufferHandle","bufferData","bindBuffer","buffer","enableVertexAttribArray","getShaderInfoLog","getProgramInfoLog","getError","TextureHandle","texParameteri","param","activeTexture","bindTexture","enable","capability","disable","cullFace","frontFace","blendFunc","sfactor","dfactor","level","internalformat","border","format","scissor","bindFramebuffer","framebufferTexture2D","attachment","texTarget","path","Uint8Array","readPixels","dynCanvas","context","createImageData","imageData","set","putImageData","toDataURL","flippedImage","transform","drawImage","downloadData","remove","flippedDataUrl","checkFramebufferStatus","btn","ALL_KEYS","MOUSE_BUTTON_LEFT","sound","howl","play","Playback","cfg","HowlerSoundBuffer","Howl","setItem","getItem","removeItem","adv","showRewardedVideo","callbacks","isAvailableMethod","availablePromise","setLeaderboardScore","score","normSq","origin_pos_tmp_intersect2","r00","sphere","origin_pos","dot","setNaN","po","pa","pb","pbx","pay","roz","poz","paz","roy","poy","pax","pby","pbz","rox","pox","rdy","rdz","rdx","c00","c04","c08","c02","c06","c03","c07","c16","c18","c19","c20","c22","c23","i00","i10","i20","i30","oneOverDet","i01","i02","i03","i11","i12","i13","i21","i22","i23","i31","i32","i33","downloadContent","substringAfterLast","PerformanceTracker","Kotlin","_","isBooleanArray","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","String","fromCharCode","prototype","call","arrayEquals","equals","arrayHashCode","hashCode","getCallableRef","callableName","toShort","toByte","toChar","numberToInt","Long","doubleToInt","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","obj","objType","getObjectHashCode","numberHashCode","Number","str","hash","charCodeAt","getStringHashCode","bufFloat64","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","Math","random","Object","defineProperty","throwMarkerError","Error","imul","isInheritanceFromInterface","ctor","iface","metadata","$metadata$","interfaces","superPrototype","getPrototypeOf","superConstructor","constructor","identityHashCode","low_","low","high_","high","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","b00","approx","shiftRight","shiftLeft","log2","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","ensureNotNull","throwNPE","startsWith","searchString","position","lastIndexOf","subjectString","lastIndex","sign","trunc","taylor_2_bound","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","exp","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","TypeError","O","len","relativeStart","end","relativeEnd","finalValue","normalizeOffset","typedArraySlice","begin","subarray","arrays","TypedArray","slice","Function","self","callback","totalOrderComparator","sort","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","get","isType","object","proto","kind","OBJECT","klassMetadata","INTERFACE","isNumber","isChar","isCharSequence","CharSequence","ordinal","initValue","MIN_HIGH_SURROGATE","MAX_LOW_SURROGATE","fillArrayVal","NoSuchElementException","IntRange","toMutableList","asCollection","emptySet","setOf","toCollection","single","optimizeReadOnlyList","separator","prefix","postfix","limit","truncated","toUpperCase","uppercase","toLowerCase","titlecaseChar","to","last","step","EMPTY","minimumValue","maximumValue","range","endInclusive","TransformingSequence","NotImplementedError","BooleanIterator","ByteIterator","ShortIterator","CharIterator","IntIterator","FloatIterator","DoubleIterator","LongIterator","current","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","createFailure","CoroutineImpl","receiver","cause","message","Exception","RuntimeException","dst","srcLen","dstLen","source","newSize","defaultValue","checkRadix","ArrayList","fromIndex","toIndex","resultLength","int","shift","base64","fromBase64","sixBit","middle","needle","binarySearchRange","diff","toBase64","decodeVarLenBase64","decodedRangeStart","decodedRangeLength","decodedRangeCategory","rangeStart","rangeEnd","lastTwoBits","threshold","distance","getLetterType","isOtherLowercase","uppercaseChar","toArray","copyToArrayImpl","collection","push","pair","startIndex","endIndex","destinationOffset","rangeSize","arrayBufferIsView","subrange","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","elements","checkIsMutable","modified","_index","changed","times","hasPrevious","newValue","oldValue","from","iter","entry","modCount","splice","concat","pop","value1","value2","internalMap","equality","InternalHashCodeMap","initialCapacity","loadFactor","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","ClassCastException","bits","NEGATIVE_INFINITY","isInfinite","nativeClz32","hi26","INV_2_26","low27","INV_2_53","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","old","newEntry","build","outputStream","write","messageString","flush","console","cur","simpleName","jsClass","PrimitiveKClassImpl","classifier","isMarkedNullable","kClass","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","titlecaseCharImpl","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","isWhitespaceImpl","toLongOrNull","numberFormatError","char","digitToIntImpl","ignoreCase","JsMath","n1","n2","thisChar","otherChar","regionMatches","isWhitespace","regionMatchesImpl","thisOffset","otherOffset","ExceptionTraceBuilder","_suppressed","decimals","round","nativeSign","rounded","toFixed","toPrecision","nativeLog10","positive","positiveString","sourceUnit","targetUnit","sourceCompareTarget","scale","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","dstIndex","stringCsq","indent","qualifier","shortInfo","stack","stackStart","lineSequence","suppressed","suppressedIndent","commonFrames","lastBreak","preLastBreak","otherIterator","elem","elemOther","AbstractSet","ourValue","minCapacity","newCapacity","newElements","internalIndex","removeFirst","internalLastIndex","removeLast","decrementedInternalIndex","decrementedHead","tail","shiftedHead","elementsSize","shiftToBack","elementsToShift","shiftedInternalIndex","shiftToFront","oldElement","newTail","predicate","arrayOfNulls","dest","oldCapacity","structure","ArrayAsCollection","contains","isVarargs","IndexingIterator","IndexedValue","pairs","putAll","filterInPlace","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","block","SequenceScope","nextByte","nextChar","nextShort","nextInt","nextLong","nextDouble","nextBoolean","throwOnFailure","FlatteningSequence","itemIterator","nextItemIterator","acc","removed","interceptor","CombinedContext","baseKey","operation","initial","newLeft","mod","differenceModulo","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","doubleFromParts","r1","nextDown","steps","remainder","vr","seed","boundsErrorMessage","takeUpperBits","seed1","seed2","CharProgression","CharRange","IntProgression","LongProgression","getProgressionLastElement","CharProgressionIterator","IntProgressionIterator","LongProgressionIterator","thisUpper","otherUpper","newIndent","lines","line","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","digit","NumberFormatException","padChar","subSequence","sb","padStart","chars","indices","indexOfAny","charArrayOf","currentStartIndex","requireNonNegativeLimit","DelimitedRangesSequence","currentIndex","strings","findAnyOf","second","asList","delimiters","splitToSequence","MAX_NANOS","MAX_MILLIS","MAX_NANOS_IN_MILLIS","Duration","durationOfMillis","endExclusive","nextSearchIndex","nextState","nextItem","match","convertDurationUnit","toDuration","parseDuration","IllegalArgumentException","durationOfNanos","convertDurationUnitOverflow","maxNsInUnit","valueInNs","roundToLong","nanos","durationOfMillisNormalized","hasSign","isTimeComponent","prevUnit","component","durationUnitByIsoChar","dotIndex","parseOverLongIsoComponent","whole","toDouble","strictIso","infinityString","INFINITE","afterFirst","allowSpaces","unitName","durationUnitByShortName","toLong","millis","normalNanos","normalMillis","nanosToMillis","millisToNanos","shortName","isoChar","DeepRecursiveScope","UNDEFINED_RESULT","normalValue","unitDiscriminator","durationOfNanosNormalized","otherNanos","thisMillis","otherMillis","resultMillis","otherNanoRemainder","remNanos","totalMillis","roundToInt","intScale","isPositive","coarserUnit","compareBits","action","inWholeDays","hoursComponent","minutesComponent","secondsComponent","nanosecondsComponent","inWholeHours","inWholeMinutes","inWholeSeconds","inWholeNanoseconds","inWholeMilliseconds","absoluteValue","days","hours","minutes","seconds","nanoseconds","components","hasDays","hasHours","hasMinutes","hasSeconds","fractional","fractionalSize","fracString","isoZeroes","nonZeroDigits","number","formatToExactDecimals","cont","currentFunction","initializer","isInitialized","InitializedLazyImpl","that","UByte","third","UInt","uintCompare","ulongCompare","uintDivide","ulongDivide","uintRemainder","ulongRemainder","storage","UIntProgression","UIntRange","uintToDouble","UIntProgressionIterator","ULong","ULongProgression","ulongToDouble","ulongToString","ULongProgressionIterator","ac","bc","UShort","uradix","beforeAdding","divisor","dividend","quotient","base","IndexingIterable","toMutableSet","collectionSizeOrNull","addAll","fillFrom","arrayCopyResize","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","captureStackTrace","instance","UnsafeLazyImpl","original","output","delegate","NullPointerException","countTrailingZeroBits","KTypeImpl","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","isLowerCaseImpl","toIntOrNull","suffix","error","stackTraceToString","toSet","createCoroutineUnintercepted","titlecaseImpl","replaceIndent","missingDelimiterValue","delimiter","currentOffset","nextIndex","isLimited","rangesDelimitedBy","DeepRecursiveScopeImpl","runCallLoop","toUByteOrNull","toUShortOrNull","toUIntOrNull","toULongOrNull","isNode","NodeJsOutput","BufferedOutputToConsoleLog","Comparator","sourceIterator","copyOf","findAssociatedObject","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}