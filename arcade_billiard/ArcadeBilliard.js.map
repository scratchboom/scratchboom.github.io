{"version":3,"file":"ArcadeBilliard.js","mappings":"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AG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAC7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAE7C,EAAUA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,EAAA,YAAE,EAAG,GAAKA,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AvC,QAMG,oD,2EAAA,kD,0DAOzC,EAAN,EAAM,kB,GAAA,Q,MCAa,2M,8BACf,iC,MAAY,0BDDgC,cCElC,MAAO,EAAP,WAAO,aAAP,WACR,M,OAAqB,K,cDH3B,OCIA,W,ODJA,G,cAQM,OAAc,gB,0ECnCG,aACvB,sB,IGgDR,GAaA,GCrBI,G,yBLIiE,OAN7D,W,OAM6D,G,mLMkMA,gB,aAAA,O,WAAA,kB,mBADjD,uF,oDAAA,iB,mBAAA,e,wBAAA,uB,eCnMpB,uB,IAI8C,gB,SAJ9C,oB,gCA/D2E,mEH8EvE,cAHa,kD,2CANjB,c,8CCRI,iB,kMG6HoF,gBAA7D,iBAAI,aAAU,yBAAd,WnH5FsB,EAAM,iB,emH4F5B,EAA6D,6C,4FAJxF,oC,qCAAA,M,sDAAA,+C,4ECpBI,QpGpKJ,WDgDQ,GqGkIa,IADkC,wCAClB,8B,aAkB7B,SAAU,K,QACV,uC,QAII,wCApBA,wBAlER,e,0CtBNW,IAAP,E,esBiBuB,cAEf,kB,qBpGhIhB,aDgDQ,Q,IqGiI+C,6C,IAAA,eAClC,kE,gBAPb,EAAmB,KAAnB,kB,GACA,EAAI,uBACA,oC,CAEA,6BAAoB,G,4BAgF5B,8B,aAEiD,c,QAC1C,+BAAc,Q,QAQM,6BClHjB,KD4CI,S,KAGN,K,+EArBQ,qD,GAGR,2D,+CAqFmB,EALvB,cACU,oB,uFApFG,wB,wGAAD,mB,OAwFW,mBC7GJ,uB,2GA1JiB,eAExC,wB,yBA0GI,gBAAe,EACX,sBAAW,E,gCAEX,kB,sDAKJ,aAAO,Y,oCAWU,oCAHrB,QADY,gBACI,Y7BhJ0B,eAG1C,a,sGAIsB,kB,uDAGb,kBAAL,GMmHJ,oBACI,kBAAO,GNnHH,oBAAiB,gCACjB,mBAAK,wB,uD8BuFT,0F,8BAAA,qD,kDAAgB,aAAhB,gD,sFADJ,E,gICLY,WADE,K,OACW,gB,MACb,qB,QAEI,E,MACI,avHgByB,cAAM,YuHdzB,sB,8DvI9Gb,mB,OAAb,OwIgNQ,uDCrCkB,sC,wBAAA,oECtEO,uF,MAAA,mD,6GAAA,wC,0EAFxB,yB,kBAAA,uE,OAKT,gE,qPAHoB,E,sBAiBhB,iB,WAAA,c,iJACF,mC,EAFF,mC,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","sources":["webpack://ArcadeBilliard/webpack/universalModuleDefinition","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Ball.kt","webpack://ArcadeBilliard/./kotlin/js/src/kotlin/math.kt","webpack://ArcadeBilliard/./kotlin/common/src/generated/_Collections.kt","webpack://ArcadeBilliard/./kotlin/runtime/arrayUtils.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/AimDialog.kt","webpack://ArcadeBilliard/./kotlin/src/kotlin/util/Standard.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/math/Vec3.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BallPhysics.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BallShader.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BeatIndicator.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BilliardAnalytics.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BilliardGame.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BilliardResources.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/BilliardStorage.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Collider.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Finger.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/FpsEntity.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/GameOver.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Levels.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/arrays/IntArr.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/nodes/Node.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/LevelsMenu.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Localization.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/NotEnoughStarsDialog.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Palette.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Pocket.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Sling.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Table.kt","webpack://ArcadeBilliard/./kotlin/src/kotlin/collections/Collections.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/TopBar.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/Tutorial.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/WinScreen.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/commonMain/kotlin/kmptemplate/games/billiard/creatives/IconScene.kt","webpack://ArcadeBilliard/../../../../ArcadeBilliard/src/jsMain/kotlin/kmptemplate/games/billiard/BilliardJsMain.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/immediate/ImmediateMode.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/Performance.kt","webpack://ArcadeBilliard/src/kotlin/util/Preconditions.kt","webpack://ArcadeBilliard/js/src/kotlin/math.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/asteroids/GridSampleRender.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/asteroids/entities/RaceTimerEntity.kt","webpack://ArcadeBilliard/src/kotlin/util/Standard.kt","webpack://ArcadeBilliard/src/kotlin/text/Strings.kt","webpack://ArcadeBilliard/src/kotlin/collections/Maps.kt","webpack://ArcadeBilliard/common/src/generated/_Strings.kt","webpack://ArcadeBilliard/js/src/generated/_ArraysJs.kt","webpack://ArcadeBilliard/runtime/arrayUtils.kt","webpack://ArcadeBilliard/common/src/generated/_Collections.kt","webpack://ArcadeBilliard/js/src/kotlin/collections.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/tetris/CupEntity.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/tetris/DropEntity.kt","webpack://ArcadeBilliard/src/kotlin/coroutines/Continuation.kt","webpack://ArcadeBilliard/src/kotlin/util/Result.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/analytics/Analytics.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/color/Color.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/entities/Entity.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/Camera.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/FloatBuffer.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/Framebuffer.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/GL.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/GLOO.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/PlainCamera.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/Viewport.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/fonts/SdfFont.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/gloo/primitives/Intersection.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/input/Keyboard.kt","webpack://ArcadeBilliard/src/kotlin/CharCode.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/loading/Loader.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/math/Func.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/math/Mat.kt","webpack://ArcadeBilliard/common/src/generated/_Arrays.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/math/Quaternion.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/math/Ray.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/math/Vec4.kt","webpack://ArcadeBilliard/src/kotlin/collections/Collections.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/pool/VecPool.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/sound/SoundBuffer.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/storage/Storage.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/tetris/Ads.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/triangulator/Triangulator.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/ui/Widgets.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/analytics/JsYaMetricaAnalytics.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/asteroids/Platform.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/browser/Download.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/data/FloatArr.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/entities/DroppedImage.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/entities/YaGamesJsPlayer.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/gloo/FramebufferHandle.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/gloo/GL.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/input/Keyboard.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/sound/HowlerAudioImpl.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/storage/JsLocalStorage.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/storage/YaGamesSafeStorage.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/tetris/YaGamesAds.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/time/Timer.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/yagames/YaGamesLeaderBoard.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/AsteroidsJsMain.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/random/RandomExt.kt","webpack://ArcadeBilliard/../../../../src/commonMain/kotlin/kmptemplate/svg/SvgPath.kt","webpack://ArcadeBilliard/../../../../src/jsMain/kotlin/kmptemplate/tetris/YaGamesLoc.kt","webpack://ArcadeBilliard/./kotlin-dce/wrapper.js","webpack://ArcadeBilliard/./kotlin-dce/js/arrayUtils.js","webpack://ArcadeBilliard/./kotlin-dce/js/conversions.js","webpack://ArcadeBilliard/./kotlin-dce/js/core.js","webpack://ArcadeBilliard/./kotlin-dce/js/misc.js","webpack://ArcadeBilliard/./kotlin-dce/js/polyfills.js","webpack://ArcadeBilliard/./kotlin-dce/js/markerFunctions.js","webpack://ArcadeBilliard/./kotlin-dce/js/rtti.js","webpack://ArcadeBilliard/./kotlin-dce/js/long.js","webpack://ArcadeBilliard/./kotlin-dce/runtime/Enum.kt","webpack://ArcadeBilliard/./kotlin-dce/runtime/arrayUtils.kt","webpack://ArcadeBilliard/./kotlin-dce/primitiveCompanionObjects.kt","webpack://ArcadeBilliard/./kotlin-dce/common/src/generated/_Arrays.kt","webpack://ArcadeBilliard/./kotlin-dce/common/src/generated/_Ranges.kt","webpack://ArcadeBilliard/./kotlin-dce/unsigned/src/kotlin/UByte.kt","webpack://ArcadeBilliard/./kotlin-dce/unsigned/src/kotlin/UInt.kt","webpack://ArcadeBilliard/./kotlin-dce/unsigned/src/kotlin/UShort.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/Ranges.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/Collections.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/Maps.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/Sets.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/text/StringNumberConversions.kt","webpack://ArcadeBilliard/./kotlin-dce/common/src/generated/_Collections.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/Iterables.kt","webpack://ArcadeBilliard/./kotlin-dce/common/src/generated/_Sequences.kt","webpack://ArcadeBilliard/./kotlin-dce/common/src/generated/_Strings.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/util/Preconditions.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/text/string.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/Iterators.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/ProgressionIterators.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/CharCode.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/Progressions.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/time/Duration.kt","webpack://ArcadeBilliard/./kotlin-dce/unsigned/src/kotlin/UnsignedUtils.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/Collections.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/Range.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/Unit.kt","webpack://ArcadeBilliard/./kotlin-dce/builtin-sources/internal/progressionUtil.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/builtins.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/CoroutineImpl.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/util/Standard.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/util/Result.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/Continuation.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/exceptions.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/generated/_ArraysJs.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/generated/_DigitChars.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/generated/_WhitespaceChars.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/kotlin.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/AbstractMutableCollection.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/AbstractMutableList.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/AbstractMutableMap.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/AbstractMutableSet.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/ArrayList.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/ArraySorting.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/EqualityComparator.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/Comparator.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/HashMap.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/HashSet.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/InternalHashCodeMap.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/InternalStringMap.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/LinkedHashMap.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/console.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/coroutines/SafeContinuationJs.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/exceptionUtils.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/math.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/numbers_js-v1.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/numbers.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/random/PlatformRandom.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/reflect/KClassImpl.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/InternalMap.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/jsOperators.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/collections/LinkedHashSet.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/reflect/primitives.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/reflect/reflection.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/text/StringBuilderJs.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/text/char.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/text/numberConversions.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/generated/_ComparisonsJs.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/text/stringsCode.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/throwableExtensions.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/AbstractCollection.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/AbstractList.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/text/Strings.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/AbstractMap.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/AbstractSet.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/MapWithDefault.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/MutableCollections.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/Sequences.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/collections/SequenceBuilder.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/comparisons/Comparisons.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/ContinuationInterceptor.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/CoroutineContext.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/CoroutineContextImpl.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/coroutines/intrinsics/Intrinsics.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/random/Random.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/random/XorWowRandom.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/ranges/Ranges.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/text/Appendable.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/text/Char.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/text/Indent.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/util/Tuples.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/js.arrays/fill.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/coroutines/cancellation/CancellationException.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/json.kt","webpack://ArcadeBilliard/./kotlin-dce/common/src/kotlin/MathH.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://ArcadeBilliard/./kotlin-dce/js/src/kotlin/text/utf8Encoding.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/util/DeepRecursive.kt","webpack://ArcadeBilliard/../../../../../common/src/Delay.kt","webpack://ArcadeBilliard/../../../../../common/src/EventLoop.common.kt","webpack://ArcadeBilliard/./kotlin-dce/src/kotlin/text/StringBuilder.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/SharedFlow.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/LockFreeTaskQueue.kt","webpack://ArcadeBilliard/../../../../../js/src/JSDispatcher.kt","webpack://ArcadeBilliard/../../../../../common/src/AbstractCoroutine.kt","webpack://ArcadeBilliard/../../../../../common/src/Builders.common.kt","webpack://ArcadeBilliard/../../../../../common/src/CancellableContinuation.kt","webpack://ArcadeBilliard/../../../../../common/src/CancellableContinuationImpl.kt","webpack://ArcadeBilliard/../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://ArcadeBilliard/../../../../../common/src/CompletionState.kt","webpack://ArcadeBilliard/../../../../../common/src/CoroutineDispatcher.kt","webpack://ArcadeBilliard/../../../../../common/src/CoroutineExceptionHandler.kt","webpack://ArcadeBilliard/../../../../../common/src/CompletableDeferred.kt","webpack://ArcadeBilliard/../../../../../common/src/CoroutineName.kt","webpack://ArcadeBilliard/../../../../../common/src/CoroutineScope.kt","webpack://ArcadeBilliard/../../../../../common/src/CoroutineStart.kt","webpack://ArcadeBilliard/../../../../../common/src/Job.kt","webpack://ArcadeBilliard/../../../../../common/src/JobSupport.kt","webpack://ArcadeBilliard/../../../../../common/src/MainCoroutineDispatcher.kt","webpack://ArcadeBilliard/../../../../../common/src/NonCancellable.kt","webpack://ArcadeBilliard/../../../../../common/src/Supervisor.kt","webpack://ArcadeBilliard/../../../../../common/src/channels/AbstractChannel.kt","webpack://ArcadeBilliard/../../../../../js/src/internal/LinkedList.kt","webpack://ArcadeBilliard/../../../../../js/src/internal/StackTraceRecovery.kt","webpack://ArcadeBilliard/../../../../../common/src/Timeout.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/terminal/Reduce.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/Atomic.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/operators/Zip.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/terminal/Collect.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/ConcurrentLinkedList.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/DispatchedContinuation.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/DispatchedTask.kt","webpack://ArcadeBilliard/../../../../../common/src/channels/Channels.common.kt","webpack://ArcadeBilliard/../../../../../common/src/channels/ConflatedBroadcastChannel.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/Flow.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/operators/Merge.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/operators/Limit.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/internal/SafeCollector.common.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/internal/FlowExceptions.common.kt","webpack://ArcadeBilliard/../../../../../common/src/flow/terminal/Count.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/InlineList.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/LimitedDispatcher.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/LocalAtomics.common.kt","webpack://ArcadeBilliard/../../../../../common/src/intrinsics/Undispatched.kt","webpack://ArcadeBilliard/../../../../../common/src/selects/WhileSelect.kt","webpack://ArcadeBilliard/../../../../../common/src/sync/Semaphore.kt","webpack://ArcadeBilliard/../../../../../js/src/CompletionHandler.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/Scopes.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/Symbol.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/SystemProps.common.kt","webpack://ArcadeBilliard/../../../../../common/src/internal/ThreadSafeHeap.kt","webpack://ArcadeBilliard/../../../../../js/src/Runnable.kt","webpack://ArcadeBilliard/../../../../../common/src/selects/Select.kt","webpack://ArcadeBilliard/../../../../../js/src/CoroutineContext.kt","webpack://ArcadeBilliard/../../../../../common/src/intrinsics/Cancellable.kt","webpack://ArcadeBilliard/../../../../../common/src/selects/SelectUnbiased.kt","webpack://ArcadeBilliard/../../../../../common/src/sync/Mutex.kt","webpack://ArcadeBilliard/../../../../../js/src/Debug.kt","webpack://ArcadeBilliard/../../../../../js/src/Dispatchers.kt","webpack://ArcadeBilliard/../../../../../js/src/EventLoop.kt","webpack://ArcadeBilliard/../../../../../js/src/CoroutineExceptionHandlerImpl.kt","webpack://ArcadeBilliard/../../../../../js/src/Exceptions.kt","webpack://ArcadeBilliard/../../../../../js/src/Promise.kt","webpack://ArcadeBilliard/../../../../../js/src/SchedulerTask.kt","webpack://ArcadeBilliard/../../../../../js/src/internal/CopyOnWriteList.kt","webpack://ArcadeBilliard/../../../../../js/src/internal/LocalAtomics.kt","webpack://ArcadeBilliard/../../../../../js/src/internal/ThreadContext.kt","webpack://ArcadeBilliard/../../../../../js/src/internal/ThreadLocal.kt","webpack://ArcadeBilliard/webpack/bootstrap","webpack://ArcadeBilliard/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ArcadeBilliard\"] = factory();\n\telse\n\t\troot[\"ArcadeBilliard\"] = factory();\n})(this, () => {\nreturn ","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Buffer\nimport kmptemplate.gloo.Cam\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.FloatBuffer2\nimport kmptemplate.gloo.FloatBuffer3\nimport kmptemplate.gloo.GL.Companion.GL_DEPTH_TEST\nimport kmptemplate.gloo.GL.Companion.GL_TRIANGLES\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Quaternion\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.distSq\nimport kmptemplate.math.dot\nimport kmptemplate.math.inversed\nimport kmptemplate.math.setQuaternion\nimport kmptemplate.math.sq\nimport kmptemplate.pool.VecPool\nimport kmptemplate.random.nextFloat2\nimport kmptemplate.time.currentTimeSeconds\nimport kotlin.math.PI\nimport kotlin.math.cos\nimport kotlin.math.exp\nimport kotlin.random.Random\n\nclass Ball(val game: BilliardGame, val texture: Texture2D, val envTexture: Texture2D, x: Float, y: Float, parent: Entity? = game) : Entity(parent = parent) {\n\n    private lateinit var gloo: GLOO\n    lateinit var im: ImmediateMode\n\n    companion object {\n        val R = 0.75f\n        val K = 0.4f\n    }\n\n    val pos = Vec3(x, y, R)\n    val vel = Vec3(0f, 0f, 0f)\n\n    private var touchedWall = false\n    private var touchedBall = false\n\n    private val modelMat = Mat4()\n    private val rotateMat = Mat4()\n    private val translateMat = Mat4()\n    val orientation = Quaternion(0f, 1f, 0f, 0f).apply {\n        setAxisAndRotation(Vec3(0f, 1f, 0f), 0.0f)\n    }\n\n    private val coordsFloatBuf = FloatBuffer3().apply {\n        add(-R, -R, R)\n        add(+R, -R, R)\n        add(+R, +R, R)\n\n        add(-R, -R, R)\n        add(+R, +R, R)\n        add(-R, +R, R)\n    }\n    private val texCoordsFloatBuf = FloatBuffer2().apply {\n        add(-1f, -1f)\n        add(1f, -1f)\n        add(1f, 1f)\n\n        add(-1f, -1f)\n        add(1f, 1f)\n        add(-1f, 1f)\n    }\n    private lateinit var coordsBuf: Buffer\n    private lateinit var texCoordsBuf: Buffer\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n\n        coordsBuf = gloo.createBuffer()\n        coordsBuf.setData(coordsFloatBuf)\n\n        texCoordsBuf = gloo.createBuffer()\n        texCoordsBuf.setData(texCoordsFloatBuf)\n    }\n\n    private val wQuaternion = Quaternion(0f, 0f, 0f, 0f)\n    private val newOrient = Quaternion(0f, 0f, 0f, 0f)\n\n    private val v0 = Vec3()\n    private val dPos = Vec3()\n\n    private var blinkStartTime = -1e30\n    private var blinkPeriod = 0.3\n    private var blinkCount = 2\n\n    private val UP = Vec3(0f, 1f, 0f)\n\n    fun resetSlightRandomOrientation() {\n        orientation.setAxisAndRotation(UP, Random.nextFloat2() * 0.3f)\n\n        val amount = 0.2f\n\n        wQuaternion.set(amount * Random.nextFloat2(), amount * Random.nextFloat2(), amount * Random.nextFloat2(), 0f) //axis of rotation\n        newOrient.setMult(wQuaternion, orientation)\n        orientation.add(newOrient)\n        orientation.normalize()\n    }\n\n    private val BALL_WALL_DUMP = 0.8f\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        v0.set(vel)\n\n        val k = K * (1f + 50f * exp(-vel.norm() * 5f)) //   ,    \n        val q = exp(-k * dt).toFloat()\n        vel *= q\n        vel.z = 0f\n\n        val p = ((1f - exp(-dt * k)) / k).toFloat()\n        dPos.setMult(p, v0)\n\n        pos.add(dPos)\n        pos.z = R\n\n        // https://gamedev.stackexchange.com/questions/108920/applying-angular-velocity-to-quaternion\n        // angular velocity\n        wQuaternion.set(-dPos.y / R / 2.0f, dPos.x / R / 2.0f, 0f, 0f)\n        newOrient.setMult(wQuaternion, orientation)\n        orientation.add(newOrient)\n        orientation.normalize()\n\n        val touchAnyWall = game.table.walls.any { wall ->\n            ballTouchesWall(wall)\n        }\n\n        for (wall in game.table.walls) {\n\n            val np = VecPool.obtainVec3()\n            np.nearestPointOnSegment(pos, wall.p1, wall.p2)\n\n            val n = VecPool.obtainVec3()\n            n.setDiff(pos, np)\n\n            if (distSq(pos, np) < sq(R) && dot(n, vel) < 0.0f) {\n                val ref = VecPool.obtainVec3()\n                ref.reflect(vel, n)\n                vel.set(ref)\n                vel *= BALL_WALL_DUMP\n            }\n        }\n\n        if (!touchedWall && touchAnyWall) {\n            game.soundManager.play(game.resources.ballWallSound)\n            touchedWall = true\n\n            println(\"just touched wall\")\n//            println(\"game.ball.pos = ${game.ball.pos}\")\n//            println(\"game.table.walls[0] = ${game.table.walls[0].p1} ${game.table.walls[0].p2}\")\n        }\n\n        touchedWall = touchAnyWall\n    }\n\n    var frame = 0L\n\n    val tintColor = Color(1f, 1f, 1f, 1f)\n    val startTimeSeconds = currentTimeSeconds()\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        render(game.cam)\n    }\n\n    fun render(cam: Cam) {\n        gloo.gl.disable(GL_DEPTH_TEST)\n\n        val shadowSize = Ball.R * 1.7f\n\n        im.clear()\n        im.pos(pos.x - shadowSize, pos.y - shadowSize, 0.0f)\n        im.pos(pos.x + shadowSize, pos.y - shadowSize, 0.0f)\n        im.pos(pos.x + shadowSize, pos.y + shadowSize, 0.0f)\n\n        im.pos(pos.x - shadowSize, pos.y - shadowSize, 0.0f)\n        im.pos(pos.x + shadowSize, pos.y + shadowSize, 0.0f)\n        im.pos(pos.x - shadowSize, pos.y + shadowSize, 0.0f)\n\n        im.texCoord(0f, 0f)\n        im.texCoord(1f, 0f)\n        im.texCoord(1f, 1f)\n\n        im.texCoord(0f, 0f)\n        im.texCoord(1f, 1f)\n        im.texCoord(0f, 1f)\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.renderTex(game.resources.ballShadowTexture, cam)\n\n        rotateMat.setQuaternion(orientation)\n        inversed(rotateMat, rotateMat)\n\n        translateMat.setTranslate(pos)\n\n        modelMat.setIdentity()\n        modelMat.setMult(rotateMat, modelMat)\n        modelMat.setMult(translateMat, modelMat)\n\n        val t = currentTimeSeconds() - blinkStartTime\n\n        val ph: Float\n        if (t < blinkPeriod) {\n            ph = (cos(2.0 * PI * t * blinkCount.toDouble() / blinkPeriod) * 0.45 + 0.55).toFloat()\n        } else {\n            ph = 1.0f\n        }\n        tintColor.setMix(COLOR_RED, COLOR_WHITE, ph)\n\n\n        game.ballShader.use {\n            aCoord.set(coordsBuf)\n            aTexCoord.set(texCoordsBuf)\n            uPos.set(pos.x, pos.y)\n            uTexture.set(texture)\n            uEnvTexture.set(envTexture)\n            uTint.set(tintColor)\n            uTranslate.set(translateMat)\n            uRotate.set(rotateMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n        }\n\n        gloo.gl.drawArrays(GL_TRIANGLES, 0, 6)\n\n        gloo.gl.enable(GL_DEPTH_TEST)\n\n        frame++\n    }\n\n    fun ballTouchesWall(wall: Wall): Boolean {\n        val dsq = distToSegmentSq(pos, wall.p1, wall.p2)\n        return dsq < sq(R)\n    }\n\n    fun startBlink(time: Double = currentTimeSeconds()) {\n        blinkStartTime = time\n    }\n}\n\nfun Vec3.nearestPointOnSegment(p: Vec3, l1: Vec3, l2: Vec3) {\n    val segLengthSq = distSq(l1, l2)\n    if (segLengthSq < 0.000001f) {\n        this.set(if (distSq(p, l1) < distSq(p, l2)) l1 else l2)\n    }\n\n    val p_l1 = VecPool.obtainVec3()\n    p_l1.setDiff(p, l1)\n\n    val l2_l1 = VecPool.obtainVec3()\n    l2_l1.setDiff(l2, l1)\n\n    val t = (dot(p_l1, l2_l1) / segLengthSq).coerceIn(0f, 1f)\n\n    this.set(l1)\n    this.addMult(t, l2_l1)\n}\n\nfun distToSegmentSq(p: Vec3, l1: Vec3, l2: Vec3): Float {\n    val nearestPoint = VecPool.obtainVec3()\n    nearestPoint.nearestPointOnSegment(p, l1, l2)\n    return distSq(p, nearestPoint)\n}\n\nfun distSq(x1: Float, y1: Float, z1: Float, x2: Float, y2: Float, z2: Float): Float {\n    return sq(x1 - x2) + sq(y1 - y2) + sq(z1 - z2)\n}\n\nfun Vec3.proj(vec: Vec3, toVec: Vec3) {\n    this.setMult(dot(vec, toVec) / toVec.normSq(), toVec)\n}\n\nfun Vec3.reflect(vec: Vec3, normal: Vec3) {\n    this.set(vec)\n    val pj = VecPool.obtainVec3()\n    pj.proj(vec, normal)\n    this.addMult(-2f, pj)\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeSinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeCosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeTanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeAsinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeAcosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeAtanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeHypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeExpm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeLog10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeLog2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeLog1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeTrunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeSign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeSign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeSinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeCosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeTanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeAsinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeAcosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeAtanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeHypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeExpm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeLog10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeLog2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeLog1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeSign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeSign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.max(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.max(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.min(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.min(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.convertToSetForSetOperation()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.convertToSetForSetOperation()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.ui.Widget\nimport kmptemplate.ui.column\nimport kmptemplate.ui.padding\nimport kmptemplate.ui.text\n\n\nclass AimDialog(val game: kmptemplate.games.billiard.BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var textIm: ImmediateMode\n\n    private lateinit var widget: Widget\n\n    private var level = 0\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        textIm = ImmediateMode(gloo)\n\n        val bgCol = Color(COLOR_WHITE)\n        val fontCol = Color(COLOR_BLACK)\n\n\n        widget = column {\n            drawBg = true\n            bgColor.value = bgCol\n\n            padding(0.25f) {\n                padding(0.25f) {\n                    drawBg = true\n\n                    renderBgColor1.value = kmptemplate.games.billiard.Palette.YELLOW1\n                    renderBgColor2.value = kmptemplate.games.billiard.Palette.YELLOW2\n\n                    column {\n                        text(game.loc.WITH_AIM_for_ads, fontSize = 2f, font = game.resources.font) {\n                            color.value = fontCol\n\n\n                        }\n\n                        text(game.loc.with_aim_FOR_ADS, fontSize = 2f, font = game.resources.font) {\n                            color.value = fontCol\n                        }\n                    }\n\n                    onMouseDown = {\n                        game.soundManager.play(game.resources.buttonSound)\n                        game.analytics.logPlayWithAimPressed()\n\n                        val REWARD = \"aim\"\n                        game.ads.showRewarded(onReward = {\n                            game.analytics.logRewarded(REWARD)\n                            println(\"reward: playing with aim\")\n                            game.gotoLevel(level, true)\n                            close()\n                        }, onOpen = {\n                            game.analytics.logRewardedOpened(REWARD)\n                        }, onClose = {\n                            game.analytics.logRewardedClosed(REWARD)\n                        }, onError = {\n                            game.analytics.logRewardedError(REWARD)\n                        })\n                    }\n                    onTouchDown = onMouseDown\n                }\n            }\n\n            padding(0.25f) {\n                padding(0.25f) {\n                    drawBg = true\n                    text(game.loc.without_aim, fontSize = 2f, font = game.resources.font) {\n                        color.value = fontCol\n\n\n                    }\n                    onMouseDown = {\n                        game.soundManager.play(game.resources.buttonSound)\n                        game.analytics.logPlayWithoutAimPressed()\n\n                        game.gotoLevel(level, false)\n                        close()\n                    }\n                    onTouchDown = onMouseDown\n                }\n            }\n        }\n    }\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        if (inputActive) {\n            input.forEvents { event ->\n                widget.handleEvent(event, game.uiCam)\n            }\n        }\n\n        widget.measureSelf()\n        widget.layoutChilds()\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        widget.render(textIm, game.uiCam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n\n    fun show(lvl: Int) {\n        level = lvl\n        active = true\n        game.menu.inputActive = false\n    }\n\n    fun close() {\n        active = false\n        game.menu.inputActive = true\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.gloo.FloatBuffer3\nimport kotlin.math.sqrt\n\nclass Vec3(x: Float, y: Float, z: Float) {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    constructor() : this(0f, 0f, 0f)\n\n    constructor(v: Vec3) : this(v.x, v.y, v.z)\n\n    val data = FloatArray(3)\n\n    var x: Float\n        get() = this.data[0]\n        set(v) {\n            this.data[0] = v\n        }\n\n    var y: Float\n        get() = this.data[1]\n        set(v) {\n            this.data[1] = v\n        }\n\n    var z: Float\n        get() = this.data[2]\n        set(v) {\n            this.data[2] = v\n        }\n\n    init {\n        this.x = x\n        this.y = y\n        this.z = z\n    }\n\n    fun norm(): Float = sqrt(x * x + y * y + z * z)\n\n    fun normSq(): Float = x * x + y * y + z * z\n\n    fun normalize() {\n        val norm = norm()\n        x /= norm\n        y /= norm\n        z /= norm\n    }\n\n    operator fun plusAssign(v: Vec3) {\n        x += v.x\n        y += v.y\n        z += v.z\n    }\n\n    operator fun minusAssign(v: Vec3) {\n        x -= v.x\n        y -= v.y\n        z -= v.z\n    }\n\n    operator fun timesAssign(a: Float) {\n        x *= a\n        y *= a\n        z *= a\n    }\n\n    inline fun setCross(a: Vec3, b: Vec3) {\n        //i  j k\n        //ax ay az\n        //bx by bz\n        require(this !== a)\n        require(this !== b)\n        x = a.y * b.z - a.z * b.y\n        y = a.z * b.x - a.x * b.z\n        z = a.x * b.y - a.y * b.x\n    }\n\n    override fun toString(): String {\n        return \"Vec3(${data[0]}, ${data[1]}, ${data[2]})\"\n    }\n\n    fun assign(v: Vec3) {\n        x = v.x\n        y = v.y\n        z = v.z\n    }\n\n    fun toVec4(): Vec4 {\n        return Vec4(x, y, z, 1.0f)\n    }\n\n    fun toVec4Free(): Vec4 {\n        return Vec4(x, y, z, 0.0f)\n    }\n\n    operator fun get(i: Int): Float {\n        return data[i]\n    }\n\n    fun set(v: Vec3) {\n        set(v.x, v.y, v.z)\n    }\n\n    fun set(x: Float, y: Float, z: Float) {\n        this.x = x\n        this.y = y\n        this.z = z\n    }\n\n    operator fun set(i: Int, value: Float) {\n        data[i] = value\n    }\n\n    fun setZero() {\n        set(0f, 0f, 0f)\n    }\n\n    fun setNormalizedDiff(a: Vec3, b: Vec3) {\n        val invD = 1f / dist(a, b)\n        this[0] = (a[0] - b[0]) * invD\n        this[1] = (a[1] - b[1]) * invD\n        this[2] = (a[2] - b[2]) * invD\n    }\n\n    inline fun setDiff(a: Vec3, b: Vec3) {\n        this[0] = a[0] - b[0]\n        this[1] = a[1] - b[1]\n        this[2] = a[2] - b[2]\n    }\n\n    inline fun setSum(a: Vec3, b: Vec3) {\n        this[0] = a[0] + b[0]\n        this[1] = a[1] + b[1]\n        this[2] = a[2] + b[2]\n    }\n\n    fun add(v: Vec3) {\n        this[0] += v[0]\n        this[1] += v[1]\n        this[2] += v[2]\n    }\n\n    fun addMult(a: Float, v: Vec3) {\n        this[0] += a * v[0]\n        this[1] += a * v[1]\n        this[2] += a * v[2]\n    }\n\n    fun setMult(a: Float, v: Vec3) {\n        this[0] = a * v[0]\n        this[1] = a * v[1]\n        this[2] = a * v[2]\n    }\n}\n\nfun dot(a: Vec3, b: Vec3) = a.x * b.x + a.y * b.y + a.z * b.z\n\nfun cos(a: Vec3, b: Vec3) = dot(a, b) / (a.norm() * b.norm())\n\n\nfun distSq(a: Vec3, b: Vec3): Float {\n    return sq(a[0] - b[0]) + sq(a[1] - b[1]) + sq(a[2] - b[2])\n}\n\nfun dist(a: Vec3, b: Vec3): Float {\n    return sqrt(sq(a[0] - b[0]) + sq(a[1] - b[1]) + sq(a[2] - b[2]))\n}\n\nfun Vec3.set(fb: FloatBuffer3, i: Int) {\n    set(fb[3 * i + 0], fb[3 * i + 1], fb[3 * i + 2])\n}\n\n\nfun Vec3.setNaN() {\n    set(Float.NaN, Float.NaN, Float.NaN)\n}\n\nfun Vec3.isNaN() = x.isNaN() || y.isNaN() || z.isNaN()\nfun Vec3.isNotNaN() = !isNaN()\n","package kmptemplate.games.billiard\n\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.dot\n\nclass BallPhysics {\n\n    val v1_ = Vec3()\n    val v2_ = Vec3()\n\n    private val v1_v2 = Vec3()\n    private val c1_c2 = Vec3()\n\n    val p1 = Vec3()\n    val p2 = Vec3()\n\n    fun calc(v1: Vec3, v2: Vec3, pos1: Vec3, pos2: Vec3) {\n        v1_.set(v1)\n\n        v2_.set(v2)\n\n        v1_v2.setDiff(v1, v2)\n        c1_c2.setDiff(pos1, pos2)\n\n        v1_.set(v1)\n        v1_.addMult(-dot(v1_v2, c1_c2) / c1_c2.normSq(), c1_c2)\n\n        v2_.set(v2)\n        v2_.addMult(+dot(v1_v2, c1_c2) / c1_c2.normSq(), c1_c2)\n\n        p1.set(pos1)\n        p2.set(pos2)\n    }\n}","package kmptemplate.games.billiard;\n\nimport kmptemplate.gloo.GLOO\n\nclass BallShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aCoord;\n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n        uniform mat4 uTranslate;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        #define uModel uTranslate\n        \n        void main(void)\n        {\n            vTexCoord = aTexCoord;\n            gl_Position =  uProj * uView * uModel * vec4(aCoord, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uTexture;\n        uniform sampler2D uEnvTexture;\n        varying vec2 vTexCoord;\n        uniform mat4 uRotate;\n        uniform vec2 uPos;\n        uniform vec4 uTint;\n\n        #define EDGE 0.04\n        \n        float sn(float t) {\n            return sin(t)*0.5 + 0.5;\n        }\n        \n        float sq(float x) {\n            return x*x;\n        }\n        \n        #define M_2_DIV_PI 0.63661977236\n        #define M_PI_DIV_2 1.57079632679\n        #define M_PI 3.14159265359\n        #define ENV_SCALE 0.15\n        #define SZ 16.0\n      \n        void main(void)\n        {\n            float u = vTexCoord.x;\n            float v = vTexCoord.y;\n            float rsq = u*u+v*v;\n            float r = sqrt(rsq);\n            \n            vec3 n = vec3(u, v, sqrt(1.0-rsq));\n            vec3 rf = reflect(vec3(0.0, 0.0, -1.0), n);\n            \n            float beta = asin(r);\n            float gamma = 2.0 * beta;\n            \n            float sinPsi = length(uPos) * cos(beta)/ SZ;\n            float psi = asin(sinPsi);\n            float fi = M_PI - M_PI_DIV_2 - psi;\n            \n            vec4 tableColor = vec4(0.0, 0.7, 0.0, 1.0);\n            \n            vec4 xyz = uRotate * vec4(n, 0.0);\n//            \n//            float sinAlpha = r;\n//            float alpha = asin(sinAlpha);\n//            \n//            float A = 0.95;\n//            float refl = 0.3 + 1.0*rsq;\n\n            float reflCoef = 0.3 + 0.7*rsq;\n            float lambertCoef = cos(beta);\n\n//            \n            vec2 tx = vec2(0.5,0.5)-0.5*xyz.xy;\n            tx.x *= sign(-xyz.z);\n//            vec4 color = (texture2D(uTexture, tx)*A + refl*texture2D(uEnvTexture, 0.2*vec2(u,v) + vec2(0.5,0.5) + uPos*rsq/32.0))    *    (1.0 - rsq*0.65) ;\n//            color.a = 1.0 - smoothstep(1.0-2.0*EDGE,1.0-EDGE,rsq);\n            \n            vec4 ballTex = texture2D(uTexture, tx);\n//            vec4 lightTex = texture2D(uEnvTexture, vec2(0.5,0.5) + 0.5 * (M_PI_DIV_2-psi) * normalize(vec2(u,v))*M_2_DIV_PI);\n            vec4 lightTex = texture2D(uEnvTexture, 0.2*vec2(u,v) + vec2(0.5,0.5) + uPos*rsq/32.0);\n            \n            float frenel = sin(psi);\n            \n            float mask = 1.0 - smoothstep(1.0-2.0*EDGE,1.0-EDGE,rsq);\n            \n            float tableCoef = 0.25*smoothstep(M_PI_DIV_2,M_PI_DIV_2*2.0, gamma);\n//            vec4 color = lambertCoef * mix( 0.4*lightTex * reflCoef + 0.95*ballTex   , tableColor, tableCoef);\n            \n            vec4 color = lambertCoef * ballTex * uTint; //good lambert\n            color = color + lightTex*0.7*frenel;\n            color = mix(color, tableColor, tableCoef);\n            \n            color.a = mask;\n\n            gl_FragColor = color; \n        }\n        \"\"\".trimIndent()\n    )\n\n    val aCoord = prog.getAttrib3f(\"aCoord\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uPos = prog.getUniform2f(\"uPos\")\n    val uTexture = prog.getUniformSampler2D(\"uTexture\")\n    val uEnvTexture = prog.getUniformSampler2D(\"uEnvTexture\")\n    val uTint = prog.getUniform4f(\"uTint\")\n    val uTranslate = prog.getUniformMat4f(\"uTranslate\")\n    val uRotate = prog.getUniformMat4f(\"uRotate\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: BallShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Cam\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL.Companion.GL_DEPTH_TEST\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Vec3\nimport kmptemplate.time.currentTimeSeconds\n\nclass BeatIndicator(val game: BilliardGame, val texture: Texture2D, parent: Entity? = game) : Entity(parent = parent) {\n\n    private lateinit var gloo: GLOO\n    lateinit var im: ImmediateMode\n\n    val pos = Vec3()\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        pos.set(game.beatBall.pos)\n    }\n\n    val startTimeSeconds = currentTimeSeconds()\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        render(game.cam)\n    }\n\n    private val modelMat = Mat4()\n    private val translateMat = Mat4()\n\n    fun render(cam: Cam) {\n        val allBallsStopped = game.allBalls.all { !it.active || it.vel.norm() < 0.0001f }\n\n        val visible = game.beatBall.active && allBallsStopped && !game.sling.started && !game.winScreen.active\n\n        if (!visible) return\n\n\n        gloo.gl.disable(GL_DEPTH_TEST)\n\n\n        val t = currentTimeSeconds() - startTimeSeconds\n\n        val speedScale = 0.75f\n\n        val indicatorSize = Ball.R * 1.0f // * (1.0f + 0.1f * sin(speedScale * 10.0 * t)).toFloat()\n\n        translateMat.setTranslate(pos)\n        modelMat.setRotate(speedScale * 27f * t.toFloat(), 0f, 0f, 1f)\n\n        modelMat.setMult(translateMat, modelMat)\n\n        im.clear()\n        im.pos(-indicatorSize, -indicatorSize, 0.0f)\n        im.pos(+indicatorSize, -indicatorSize, 0.0f)\n        im.pos(+indicatorSize, +indicatorSize, 0.0f)\n\n        im.pos(-indicatorSize, -indicatorSize, 0.0f)\n        im.pos(+indicatorSize, +indicatorSize, 0.0f)\n        im.pos(-indicatorSize, +indicatorSize, 0.0f)\n\n        im.texCoord(0f, 0f)\n        im.texCoord(1f, 0f)\n        im.texCoord(1f, 1f)\n\n        im.texCoord(0f, 0f)\n        im.texCoord(1f, 1f)\n        im.texCoord(0f, 1f)\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.renderTex(texture, cam, modelMat)\n\n        gloo.gl.enable(GL_DEPTH_TEST)\n    }\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.analytics.Analytics\n\nclass BilliardAnalytics(private val analytics: Analytics) {\n\n    fun logGameOver(level: Int, shots: Int) {\n        analytics.sendEvent(\"GAME_OVER\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    fun logLevelStart(level: Int) {\n        analytics.sendEvent(\"LEVEL_START\", mapOf(\"level\" to level))\n    }\n\n    //starting from levels menu, when level was already completed before\n    fun logLevelStartAgain(level: Int) {\n        analytics.sendEvent(\"LEVEL_START_AGAIN\", mapOf(\"level\" to level))\n    }\n\n    //retry after game over\n    fun logLevelRetry(level: Int, shots: Int) {\n        analytics.sendEvent(\"LEVEL_RETRY\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    //replay after game over\n    fun logLevelPlayAgain(level: Int, shots: Int) {\n        analytics.sendEvent(\"LEVEL_PLAY_AGAIN\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    fun logLevelComplete(level: Int, shots: Int) {\n        analytics.sendEvent(\"LEVEL_COMPLETE\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    //also add total shots from the start of the game (store into local storage)\n    fun shot(level: Int, shots: Int) {\n        analytics.sendEvent(\"SHOT\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    fun logBeatInPocket(level: Int, shots: Int) {\n        analytics.sendEvent(\"BEAT_IN_POCKET\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    fun logBallInPocket(level: Int, shots: Int) {\n        analytics.sendEvent(\"BALL_IN_POCKET\", mapOf(\"level\" to level, \"shots\" to shots))\n    }\n\n    fun logRewardedOpened(reward: String) {\n        analytics.sendEvent(\"REWARDED_OPENED\", mapOf(\"reward\" to reward))\n    }\n\n    fun logRewardedClosed(reward: String) {\n        analytics.sendEvent(\"REWARDED_CLOSED\", mapOf(\"reward\" to reward))\n    }\n\n    fun logRewarded(reward: String) {\n        analytics.sendEvent(\"REWARDED\", mapOf(\"reward\" to reward))\n    }\n\n    fun logRewardedError(reward: String) {\n        analytics.sendEvent(\"REWARDED_ERROR\", mapOf(\"reward\" to reward))\n    }\n\n    fun logPlayWithAimPressed() {\n        analytics.sendEvent(\"PLAY_WITH_AIM_PRESSED\")\n    }\n\n    fun logPlayWithoutAimPressed() {\n        analytics.sendEvent(\"PLAY_WITHOUT_AIM_PRESSED\")\n    }\n}\n","package kmptemplate.games.billiard\n\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.games.billiard.Ball.Companion.R\nimport kmptemplate.games.billiard.creatives.IconScene\nimport kmptemplate.games.leaderboard.LeaderBoard\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.OrthoCamera\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.loading.Loader\nimport kmptemplate.random.nextFloat\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.tetris.Ads\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.Job\nimport kotlin.random.Random\n\nclass BilliardGame(val soundManager: SoundManager, val ads: Ads, val storage: BilliardStorage, val resources: BilliardResources, val analytics: BilliardAnalytics, val leaderBoard: LeaderBoard, val loc: Localization, val loader: Loader) : Entity() {\n\n    private lateinit var gloo: GLOO\n    lateinit var textIm: ImmediateMode\n\n    val cam = OrthoCamera()\n    val topBarCam = OrthoCamera()\n    val uiCam = OrthoCamera()\n\n    lateinit var beatBall: Ball\n    val allBalls = ArrayList<Ball>()\n    val freeBalls = ArrayList<Ball>()\n    lateinit var beatIndicator: BeatIndicator\n\n    lateinit var sling: Sling\n    lateinit var table: Table\n    lateinit var collider: Collider\n    lateinit var menu: LevelsMenu\n    lateinit var topBar: TopBar\n    lateinit var gameOver: GameOver\n    lateinit var winScreen: WinScreen\n    lateinit var aimDialog: kmptemplate.games.billiard.AimDialog\n    lateinit var notEnoughStarsDialog: NotEnoughStarsDialog\n    lateinit var tutorial: Tutorial\n    lateinit var fps: FpsEntity\n    lateinit var iconScene: IconScene\n    lateinit var finger: Finger\n\n    val viewport = Viewport(100, 100)\n    val topBarViewport = Viewport(100, 100)\n\n    var left = 0f\n    var right = 0f\n    var top = 0f\n    var bottom = 0f\n\n    var centerX = 0f\n    var centerY = 0f\n\n    lateinit var ballShader: BallShader\n\n    val scope = CoroutineScope(Job() + Dispatchers.Default)\n\n    companion object {\n        val TOTAL_BALLS_COUNT = 16 // balls count including white ball\n    }\n\n    override suspend fun loadResources(gloo: GLOO) {\n        resources.requestResources(loader, gloo, soundManager)\n    }\n\n    override fun init(gloo: GLOO) {\n        val game = this\n        this.gloo = gloo\n\n        textIm = ImmediateMode(gloo)\n        ballShader = BallShader(gloo)\n\n        left = -11f\n        right = 11f\n        bottom = -14f\n        top = 14f\n        centerX = (left + right) / 2f\n        centerY = (bottom + top) / 2f\n\n        table = Table(game)\n        table.active = false\n\n        sling = Sling(game)\n        sling.active = false\n\n        beatBall = Ball(game, game.resources.beatTexture, game.resources.envTexture, centerX, centerY)\n        allBalls.add(beatBall)\n        for (i in 1 until TOTAL_BALLS_COUNT) {\n            val newBall = Ball(game, resources.ballTextures[i]!!, game.resources.envTexture, Random.nextFloat(left + R, right - R), Random.nextFloat(bottom + R, top - R))\n            allBalls.add(newBall);\n            freeBalls.add(newBall)\n        }\n        for (ball in allBalls) {\n            ball.active = false\n        }\n        collider = Collider(game)\n\n        beatIndicator = BeatIndicator(game, game.resources.indicatorTexture, this)\n\n        menu = LevelsMenu(game)\n\n        gameOver = GameOver(game)\n        gameOver.active = false\n\n        winScreen = WinScreen(game)\n        winScreen.active = false\n\n        aimDialog = kmptemplate.games.billiard.AimDialog(game)\n        aimDialog.active = false\n\n        notEnoughStarsDialog = NotEnoughStarsDialog(game)\n        notEnoughStarsDialog.active = false\n\n        tutorial = Tutorial(game)\n        tutorial.active = true\n\n        topBar = TopBar(game)\n        topBar.active = false\n\n        iconScene = IconScene(game)\n        iconScene.active = false\n\n        finger = Finger(game)\n        finger.active = false\n\n        //fps entity should be the last to track frames properly\n        fps = FpsEntity(game, game.resources.font)\n        fps.active = false\n    }\n\n\n    val BILLIARD_GREEN = Color(0.09f, 0.5f, 0.2f, 1.0f)\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        cam.setScreenSize(viewport.w, viewport.h)\n        val portrait = viewport.h > viewport.w\n\n        if (portrait) {\n            cam.fit(left, right, bottom, top + topBar.menuHeight, centerX + topBar.menuHeight / 2f, centerY, 5f)\n        } else {\n            cam.fit(left, right + topBar.menuHeight, bottom, top, centerX, centerY + topBar.menuHeight / 2f, 5f)\n        }\n\n        if (portrait) {\n            cam.worldUp.set(1f, 0f, 0f)\n        } else {\n            cam.worldUp.set(0f, 1f, 0f)\n        }\n\n        topBarCam.setScreenSize(viewport.w, viewport.h)\n        topBarCam.fit(left, right, bottom, top, centerX, centerY, 5f)\n\n        uiCam.setScreenSize(viewport.w, viewport.h)\n        uiCam.fit(left, right, bottom, top, centerX, centerY, 5f)\n\n        gloo.gl.viewPort(0, 0, viewport.w, viewport.h)\n\n        gloo.gl.clearColor(BILLIARD_GREEN)\n        gloo.gl.clear()\n    }\n\n    fun gotoMenu() {\n        table.active = false\n        winScreen.active = false\n        gameOver.active = false\n        sling.active = false\n        menu.show()\n        allBalls.forEach { ball -> ball.active = false }\n        topBar.active = false\n    }\n\n    fun gotoLevel(lvl: Int, aim: Boolean) {\n        analytics.logLevelStart(lvl)\n\n        table.setTable(lvl)\n        table.withAim = aim\n\n        sling.active = true\n        menu.active = false\n        table.active = true\n        winScreen.active = false\n        gameOver.active = false\n        topBar.active = true\n    }\n\n    fun stopAllBalls() {\n        for (ball in allBalls) {\n            ball.vel.setZero()\n        }\n    }\n\n    fun gotoGameOver() {\n        stopAllBalls()\n        gameOver.active = true\n    }\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.loading.Loader\nimport kmptemplate.sound.SoundBuffer\nimport kmptemplate.sound.SoundManager\n\nclass BilliardResources {\n\n    lateinit var font: SdfFont\n    lateinit var envTexture: Texture2D\n    lateinit var beatTexture: Texture2D\n    val ballTextures: Array<Texture2D?> = arrayOfNulls(16)\n    lateinit var clothTexture: Texture2D\n    lateinit var starTexture: Texture2D\n    lateinit var emptyStarTexture: Texture2D\n    lateinit var lockTexture: Texture2D\n    lateinit var indicatorTexture: Texture2D\n    lateinit var ballShadowTexture: Texture2D\n    lateinit var pocketTexture: Texture2D\n    lateinit var woodTexture: Texture2D\n    lateinit var handTexture: Texture2D\n    lateinit var menuIcon: Texture2D\n    lateinit var retryIcon: Texture2D\n\n\n    lateinit var buttonSound: SoundBuffer\n    lateinit var gameOverSound: SoundBuffer\n    lateinit var winSound: SoundBuffer\n    lateinit var ballInPocketSound: SoundBuffer\n    lateinit var ballWallSound: SoundBuffer\n    lateinit var ballBallSound: SoundBuffer\n    lateinit var ballCueSound: SoundBuffer\n\n    suspend fun requestResources(loader: Loader, gloo: GLOO, soundMan: SoundManager) {\n        loader.add { font = SdfFont(gloo, gloo.createTexture2D(\"billiard/fonts/roboto.fnt.png\")) }\n\n        loader.add { beatTexture = gloo.createTexture2D(\"billiard/textures/beat.png\") }\n\n        loader.add { envTexture = gloo.createTexture2D(\"billiard/textures/env2g.jpg\") }\n\n        loader.add { ballTextures[0] = gloo.createTexture2D(\"billiard/textures/beat.png\") }\n\n        for (i in 1..15) {\n            loader.add { ballTextures[i] = gloo.createTexture2D(\"billiard/textures/ball${i}.png\") }\n        }\n\n        loader.add { clothTexture = gloo.createTexture2D(\"billiard/textures/jeans1.jpg\") }\n        loader.add { starTexture = gloo.createTexture2D(\"billiard/textures/win_star.png\") }\n        loader.add { emptyStarTexture = gloo.createTexture2D(\"billiard/textures/empty_star.png\") }\n        loader.add { lockTexture = gloo.createTexture2D(\"billiard/textures/lock.png\") }\n        loader.add { indicatorTexture = gloo.createTexture2D(\"billiard/textures/indicator.png\") }\n        loader.add { ballShadowTexture = gloo.createTexture2D(\"billiard/textures/ball_shadow.png\") }\n        loader.add { pocketTexture = gloo.createTexture2D(\"billiard/textures/pocket.png\") }\n        loader.add { woodTexture = gloo.createTexture2D(\"billiard/textures/wood.jpg\") }\n        loader.add { handTexture = gloo.createTexture2D(\"billiard/textures/hand.png\") }\n        loader.add { retryIcon = gloo.createTexture2D(\"billiard/textures/icon_retry.png\") }\n        loader.add { menuIcon = gloo.createTexture2D(\"billiard/textures/icon_menu.png\") }\n\n        loader.add { buttonSound = soundMan.loadSoundBuf(\"billiard/sounds/button.mp3\") }\n        loader.add { gameOverSound = soundMan.loadSoundBuf(\"billiard/sounds/game_over.mp3\") }\n        loader.add { winSound = soundMan.loadSoundBuf(\"billiard/sounds/win.mp3\") }\n        loader.add { ballInPocketSound = soundMan.loadSoundBuf(\"billiard/sounds/ball_in_pocket.mp3\") }\n        loader.add { ballWallSound = soundMan.loadSoundBuf(\"billiard/sounds/ball_wall.mp3\") }\n        loader.add { ballBallSound = soundMan.loadSoundBuf(\"billiard/sounds/ball_ball.mp3\") }\n        loader.add { ballCueSound = soundMan.loadSoundBuf(\"billiard/sounds/ball_cue.mp3\") }\n    }\n\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.storage.Storage\n\nclass BilliardStorage(val storage: Storage) {\n\n    fun addResult(level: Int, shots: Int) {\n        val k = \"shots[${level}]\"\n\n        val records = storage.getIntList(k)\n        val newRecords = ArrayList(records)\n        newRecords.add(shots)\n\n        newRecords.sort()\n\n        storage.setIntList(k, newRecords)\n    }\n\n    fun getBestShot(level: Int): Int {\n        val bestShots = storage.getIntList(\"shots[${level}]\")\n\n        return if (bestShots.isEmpty()) 0\n        else bestShots.first()\n    }\n\n    fun addScore(level: Int, score: Int) {\n        val k = \"score[${level}]\"\n\n        val records = storage.getIntList(k)\n        val newRecords = ArrayList(records)\n        newRecords.add(score)\n\n        newRecords.sortDescending()\n\n        storage.setIntList(k, newRecords)\n    }\n\n    fun getBestScore(level: Int): Int {\n        val bestShots = storage.getIntList(\"score[${level}]\")\n\n        return if (bestShots.isEmpty()) 0\n        else bestShots.first()\n    }\n\n    fun setTutorialFinished(finished: Boolean) {\n        storage.setBoolean(\"tutorial_finished\", finished)\n    }\n\n    fun isTutorialFinished(): Boolean {\n        return storage.getBoolean(\"tutorial_finished\", false)\n    }\n\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.arrays.IntArr2D\nimport kmptemplate.entities.Entity\nimport kmptemplate.games.billiard.BilliardGame.Companion.TOTAL_BALLS_COUNT\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.distSq\nimport kmptemplate.math.dot\nimport kmptemplate.math.sq\n\nclass Collider(val game: BilliardGame) : Entity(parent = game) {\n\n    private var prevCollides = IntArr2D(TOTAL_BALLS_COUNT, TOTAL_BALLS_COUNT)\n    private var collides = IntArr2D(TOTAL_BALLS_COUNT, TOTAL_BALLS_COUNT)\n    private lateinit var tmp: IntArr2D\n\n    private val v1 = Vec3()\n    private val v1_ = Vec3()\n\n    private val v2 = Vec3()\n    private val v2_ = Vec3()\n    private val v1_v2 = Vec3()\n    private val c1_c2 = Vec3()\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        tmp = prevCollides\n        prevCollides = collides\n        collides = tmp\n\n\n        for ((i1, b1) in game.allBalls.withIndex()) {\n            for ((i2, b2) in game.allBalls.withIndex()) {\n                collides[i1, i2] = if (b1.active && b2.active && distSq(b1.pos, b2.pos) < sq(2f * Ball.R)) 1 else 0\n            }\n        }\n\n\n        //https://youtu.be/eED4bSkYCB8?t=766\n        collides.iter { i1, i2 ->\n\n            if (i2 <= i1) return@iter\n\n            val b1 = game.allBalls[i1]\n            val b2 = game.allBalls[i2]\n\n            val justCollided = prevCollides[i1, i2] == 0 && collides[i1, i2] == 1\n            if (justCollided) {\n\n                v1.set(b1.vel)\n                v1_.set(b1.vel)\n\n                v2.set(b2.vel)\n                v2_.set(b2.vel)\n\n                v1_v2.setDiff(v1, v2)\n                c1_c2.setDiff(b1.pos, b2.pos)\n\n                v1_.set(v1)\n                v1_.addMult(-dot(v1_v2, c1_c2) / c1_c2.normSq(), c1_c2)\n\n                v2_.set(v2)\n                v2_.addMult(+dot(v1_v2, c1_c2) / c1_c2.normSq(), c1_c2)\n\n                b1.vel.set(v1_)\n                b2.vel.set(v2_)\n\n                game.soundManager.play(game.resources.ballBallSound)\n            }\n        }\n    }\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.primitives.intersect\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.time.currentTimeSeconds\nimport kmptemplate.ui.UiEvent\n\nclass Finger(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var im: ImmediateMode\n\n    private val handSize = 4f\n\n    private var startTime = 0.0\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n        startTime = currentTimeSeconds()\n    }\n\n    private var handX = 0.0f\n    private var handY = 0.0f\n\n    private val ray = Ray()\n    private val intersVec = Vec3()\n\n    private var down = true\n\n    private var show = true\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        input.forEvents { event ->\n            if (event.type == UiEvent.MOUSE_MOVE || event.type == UiEvent.MOUSE_UP || event.type == UiEvent.MOUSE_DOWN) {\n                game.cam.rayThrough(ray, event.x, event.y)\n                intersVec.intersect(ray, game.table.plane)\n                if (intersVec.isNotNaN()) {\n                    handX = intersVec.x\n                    handY = intersVec.y\n                }\n            }\n\n            if (event.type == UiEvent.MOUSE_DOWN) {\n                down = true\n            }\n\n            if (event.type == UiEvent.MOUSE_UP) {\n                down = false\n            }\n\n            if (event.type == UiEvent.MOUSE_ENTER) {\n                show = true\n            }\n\n            if (event.type == UiEvent.MOUSE_LEAVE) {\n                show = false\n            }\n        }\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        if (!show) return\n\n        val allBallsStopped = game.allBalls.all { !it.active || it.vel.norm() < 0.0001f }\n        if (!allBallsStopped) return\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        im.clear()\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        val handOffsetX: Float\n        val handOffsetY: Float\n\n        if (viewport.horizontal()) {\n            im.texCoord(1f, 1f)\n            im.texCoord(1f, 0f)\n            im.texCoord(0f, 0f)\n\n            im.texCoord(1f, 1f)\n            im.texCoord(0f, 0f)\n            im.texCoord(0f, 1f)\n\n            handOffsetX = -1.67f\n            handOffsetY = -0.13f\n        } else {\n            im.texCoord(1f, 1f)\n            im.texCoord(0f, 1f)\n            im.texCoord(0f, 0f)\n\n            im.texCoord(1f, 1f)\n            im.texCoord(0f, 0f)\n            im.texCoord(1f, 0f)\n\n            handOffsetX = -0.11f\n            handOffsetY = -1.7f\n        }\n\n        val x = handX + handOffsetX\n        val y = handY + handOffsetY\n\n        val halfHandSize = 0.5f * handSize * if (down) 1.0f else 1.15f\n\n        im.pos(x - halfHandSize, y - halfHandSize, 0f)\n        im.pos(x + halfHandSize, y - halfHandSize, 0f)\n        im.pos(x + halfHandSize, y + halfHandSize, 0f)\n\n        im.pos(x - halfHandSize, y - halfHandSize, 0f)\n        im.pos(x + halfHandSize, y + halfHandSize, 0f)\n        im.pos(x - halfHandSize, y + halfHandSize, 0f)\n\n        im.renderTex(game.resources.handTexture, game.cam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.color.COLOR_DARK_RED\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\n\nclass FpsEntity(val game: BilliardGame, val font: SdfFont) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var textIm: ImmediateMode\n\n    private var prevUpdateTime = 0.0\n    private var time = 0.0\n\n    private val UPDATE_TIME = 0.250\n    private var frames = 0\n    private var fps = 0\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        textIm = ImmediateMode(gloo)\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        time = t\n        frames++\n\n//        if (time - prevUpdateTime > UPDATE_TIME) {\n        if (frames % 16 == 0) {\n            fps = (frames / (time - prevUpdateTime)).toInt()\n            prevUpdateTime = time\n            frames = 0\n        }\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        textIm.clear()\n        textIm.renderText(\n            \"\"\"\n                fps: ${fps}\n                alocs: ${PERF_TRACKER.allocsCount}\n                drawCalls: ${PERF_TRACKER.drawCallsCount} (${PERF_TRACKER.drawVertsCount} verts)\n                glBufUploads: ${PERF_TRACKER.glBufUploads} (${PERF_TRACKER.glBufUploadBytes} bytes)\n                ${PERF_TRACKER.tagsInfo()}\n                \"\"\".trimIndent(), font, game.left, game.top - 6f, 1f, COLOR_DARK_RED, game.uiCam, horAlign = ImmediateMode.ALIGN_RIGHT, verAlign = ImmediateMode.ALIGN_TOP, compress = 0.6f\n        )\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n        PERF_TRACKER.clear()\n    }\n\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.color.COLOR_GRAY\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.ui.Widget\nimport kmptemplate.ui.column\nimport kmptemplate.ui.padding\nimport kmptemplate.ui.text\n\nclass GameOver(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var im: ImmediateMode\n    private lateinit var widget: Widget\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n\n        widget = column {\n\n            drawBg = true\n\n            text(game.loc.game_over, game.resources.font, 3f) {\n                color.value = COLOR_RED\n            }\n\n            padding(0.5f) {\n                text(game.loc.beat_ball_should_not_get_in_pocket, game.resources.font, 1f) {\n                    color.value = COLOR_GRAY\n                }\n            }\n\n            padding(0.5f) {\n\n                column {\n                    drawBg = true\n\n                    renderBgColor1.value = Palette.YELLOW1\n                    renderBgColor2.value = Palette.YELLOW2\n\n                    text(game.loc.gameover_SAVE_THE_BALL_for_ads, game.resources.font, 2f) {\n                        color.value = COLOR_BLACK\n                    }\n\n                    text(game.loc.gameover_save_the_ball_FOR_ADS, game.resources.font, 2f) {\n                        color.value = COLOR_BLACK\n                    }\n\n\n                    val REWARD = \"save_the_ball\"\n                    onMouseDown = {\n                        game.ads.showRewarded(onReward = {\n                            game.analytics.logRewarded(REWARD)\n                            println(\"reward: saving the beat ball\")\n                            game.sling.restorePrevState()\n                            this@GameOver.active = false\n                        }, onOpen = {\n                            game.analytics.logRewardedOpened(REWARD)\n                        }, onClose = {\n                            game.analytics.logRewardedClosed(REWARD)\n                        }, onError = {\n                            game.analytics.logRewardedError(REWARD)\n                        })\n                    }\n                    onTouchDown = onMouseDown\n                }\n\n            }\n\n            padding(0.5f) {\n                text(game.loc.try_again, game.resources.font, 2f) {\n                    drawBg = true\n\n//                    renderBgColor1.value = Color(0.19f, 0.81f, 0.81f, 1.0f)\n//                    renderBgColor2.value = Color(0.25f, 0.92f, 0.96f, 1.0f)\n\n                    color.value = COLOR_BLACK\n\n                    onMouseDown = {\n                        game.ads.showInterstitial()\n                        game.gotoLevel(game.table.level.value, game.table.withAim)\n                    }\n                    onTouchDown = onMouseDown\n                }\n            }\n\n            padding(0.5f) {\n                text(game.loc.goto_menu, game.resources.font, 2f) {\n                    drawBg = true\n\n//                    renderBgColor1.value = Color(0.19f, 0.81f, 0.81f, 1.0f)\n//                    renderBgColor2.value = Color(0.25f, 0.92f, 0.96f, 1.0f)\n\n                    color.value = COLOR_BLACK\n\n                    onMouseDown = {\n                        game.ads.showInterstitial()\n                        game.gotoMenu()\n                    }\n                    onTouchDown = onMouseDown\n                }\n            }\n        }\n    }\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        if (inputActive) {\n            input.forEvents { event ->\n                widget.handleEvent(event, game.uiCam)\n            }\n        }\n        widget.measureSelf()\n        widget.layoutChilds()\n    }\n\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        widget.render(im, game.uiCam)\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n}","package kmptemplate.games.billiard\n\n\nclass LevelDescriptor(ballsCount: Int, val best: Int = ballsCount + 1, val mid: Int = ballsCount + 3, val setup: Table.() -> Unit) {\n\n    fun shotsToStars(shots: Int): Int {\n        if (shots == 0) return 0\n\n        return if (shots <= best) 3\n        else if (shots <= mid) 2\n        else 1\n    }\n\n    fun shotsToScore(shots: Int): Int {\n        if (shots == 0) return 0 //no scores for level yet\n\n        val stars = shotsToStars(shots)\n        var score = stars * 100\n        if (shots < best) score += 50 * (best - shots)\n        return score\n    }\n}\n\nobject Levels {\n\n    val LEVELS_COUNT = 30\n\n    private val originalLevels = Array<LevelDescriptor?>(60 + 1) { null }.apply {\n\n        val originalLevel = this //just an alias\n\n        originalLevel[1] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            svgWalls(\"m 12,-8.5 h -2 l -1,1 H 1 v -1 h -2 v 1 h -8 l -1,-1 h -2 v 2 l 1,1 v 11 l -1,1 v 2 h 2 l 1,-1 h 8 v 1 h 2 v -1 h 8 l 1,1 h 2 v -2 l -1,-1 v -11 l 1,-1 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 l -1,1 v 11 l 1,1 v 2 H 10 L 9,7.5 H 1 v 1 h -2 v -1 h -8 l -1,1 h -2 v -2 l 1,-1 v -11 l -1,-1 v -2 h 2 l 1,1 h 8 v -1 h 2 v 1 h 8 l 1,-1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"M -6,0 H 4 L 5.5,-1 V 1 L 7,-2 v 2 2\")\n\n            svgPockets(\"m -11,-7.5 11,-1 11,1 v 15 l -11,1 -11,-1\")\n        }\n\n        originalLevel[2] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            svgWalls(\"m 12,-8.5 h -2 l -1,1 H -8 l -1,1 -1,-1 v -1 h -2 v 2 l 1,1 v 10 l 1,1 -1,1 h -1 v 2 h 2 l 1,-1 H 8 l 1,-1 1,1 v 1 h 2 v -2 l -1,-1 v -10 l -1,-1 1,-1 h 1 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 h -1 l -1,1 1,1 v 10 l 1,1 v 2 h -2 v -1 l -1,-1 -1,1 H -9 l -1,1 h -2 v -2 h 1 l 1,-1 -1,-1 v -10 l -1,-1 v -2 h 2 v 1 l 1,1 1,-1 H 9 l 1,-1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"m 0,0 -9,-5.5 v 11 h 3 15 v -11 H 6\")\n\n            svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n        }\n\n        originalLevel[3] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            svgWalls(\"M 12,-8.5 H 5 v 4 H -5 v -4 h -7 v 6 h 5 v 5 h -5 v 6 h 7 v -4 H 5 v 4 h 7 v -6 H 7 v -5 h 5 z\")\n            textureTable()\n\n            svgWood(\"M 13,-9.5 H 4 v 4 h -8 v -4 h -9 v 8 h 5 v 3 h -5 v 8 h 9 v -4 h 8 v 4 h 9 v -8 H 8 v -3 h 5 v -8 l -1,1 v 6 H 7 v 5 h 5 v 6 H 5 v -4 H -5 v 4 h -7 v -6 h 5 v -5 h -5 v -6 h 7 v 4 H 5 v -4 h 7 z\")\n            textureWood()\n\n            svgBalls(\"m 0,0 -11,-3.5 h 5 12 l -12,7 h 12 5\")\n\n            svgPockets(\"m -6,-7.5 17,4 -5,11 -17,-4\")\n        }\n\n        originalLevel[4] = LevelDescriptor(ballsCount = 7) {\n            reset()\n\n            startContour()\n            svgWalls(\"m 12,-8.5 h -2 l -1,1 H 5 l -5,5 -5,-5 h -4 l -1,-1 h -2 v 2 l 1,1 v 11 l -1,1 v 2 h 2 l 1,-1 h 4 l 5,-5 5,5 h 4 l 1,1 h 2 v -2 l -1,-1 v -11 l 1,-1 z\")\n            textureTable()\n\n            svgWood(\"M 13,-9.5 H 4 l -4,4 -4,-4 h -9 v 19 h 9 l 4,-4 4,4 h 9 v -19 l -1,1 v 2 l -1,1 v 11 l 1,1 v 2 H 10 L 9,7.5 H 5 l -5,-5 -5,5 h -4 l -1,1 h -2 v -2 l 1,-1 v -11 l -1,-1 v -2 h 2 l 1,1 h 4 l 5,5 5,-5 h 4 l 1,-1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"m 1,0 2,-2.5 v 5 l -8,-7 v 9 l 2,-7 v 5 L -1,0\")\n            svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n        }\n\n        //this is custom level\n        originalLevel[5] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            svgWalls(\"m 0,-6 -2,-2 -6,6 V 2 L -2,8 0,6 2,8 8,2 V -2 L 2,-8 Z\")\n            textureTable()\n\n            svgWood(\"m 2,-10 -2,2 -2,-2 -8,8 v 4 l 8,8 2,-2 2,2 8,-8 v -4 l -8,-8 v 2 l 6,6 V 2 L 2,8 0,6 -2,8 -8,2 v -4 l 6,-6 2,2 2,-2 z\")\n            textureWood()\n\n            svgBalls(\"M 0,-3 2,-6.5 -2,6.5 -5,0 H 5 l -9,-4 8,8\")\n            svgPockets(\"M -2,-6.5 2,6.5 8,0 H -8\")\n        }\n\n        originalLevel[6] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            wallTo(-8f, 7.5f)\n            wallTo(-3f, 7.5f)\n            wallTo(-3f, 8.5f)\n            wallTo(3f, 8.5f)\n            wallTo(3f, 7.5f)\n            wallTo(8f, 7.5f)\n            wallTo(11f, 4.5f)\n            wallTo(11f, -4.5f)\n            wallTo(8f, -7.5f)\n            wallTo(4f, -7.5f)\n            wallTo(4f, -8.5f)\n            wallTo(-4f, -8.5f)\n            wallTo(-4f, -7.5f)\n            wallTo(-8f, -7.5f)\n            wallTo(-11f, -4.5f)\n            wallTo(-11f, 4.5f)\n            wallTo(-8f, 7.5f)\n\n            textureTable()\n\n            svgWood(\"m 9,-9.5 -1,2 3,3 v 9 l -3,3 H 4 v 1 h -8 v -1 h -4 l -3,-3 v -9 l 3,-3 h 5 v -1 h 6 v 1 h 5 l 1,-2 H -9 l -4,4 v 11 l 4,4 H 9 l 4,-4 v -11 z\")\n            textureWood()\n\n            ball(0, 0f, 1.5f)\n            ball(1, 0f, -5.5f)\n            ball(2, -3f, -5.5f)\n            ball(3, 3f, -5.5f)\n            ball(4, -2f, 5.5f)\n            ball(5, 2f, 5.5f)\n            ball(6, 0f, 3.5f)\n\n            pocket(-2f, 8.5f)\n            pocket(2f, 8.5f)\n            pocket(-3f, -8.5f)\n            pocket(0f, -8.5f)\n            pocket(3f, -8.5f)\n        }\n\n        originalLevel[7] = LevelDescriptor(ballsCount = 7) {\n            reset()\n\n            startContour()\n            wallTo(0f, 3.5f)\n            wallTo(4f, 7.5f)\n            wallTo(11f, 7.5f)\n            wallTo(11f, -1.5f)\n            wallTo(5f, -7.5f)\n            wallTo(-5f, -7.5f)\n            wallTo(-11f, -1.5f)\n            wallTo(-11f, 7.5f)\n            wallTo(-4f, 7.5f)\n            wallTo(0f, 3.5f)\n\n            textureTable()\n\n            svgWood(\"M 13,-9.5 H 4 l -4,4 -4,-4 h -9 v 12 l 7,7 H 6 l 7,-7 v -12 l -2,2 v 9 l -6,6 H -5 l -6,-6 v -9 h 7 l 4,4 4,-4 h 7 z\")\n            textureWood()\n\n            ball(0, 0f, 0.5f)\n            ball(1, -3f, 3.5f)\n            ball(2, 3f, 3.5f)\n            ball(3, -5f, 0.5f)\n            ball(4, 5f, 0.5f)\n            ball(5, -3f, -2.5f)\n            ball(6, 3f, -2.5f)\n            ball(7, 0f, -4.5f)\n\n            pocket(-7f, 3.5f)\n            pocket(7f, 3.5f)\n        }\n\n        originalLevel[8] = LevelDescriptor(ballsCount = 7) {\n            reset()\n\n            startContour()\n            wallTo(-4f, 7.5f)\n            wallTo(4f, 7.5f)\n            wallTo(5f, 8.5f)\n            wallTo(7f, 8.5f)\n            wallTo(7f, 6.5f)\n            wallTo(6f, 5.5f)\n            wallTo(6f, 2.5f)\n            wallTo(9f, 2.5f)\n            wallTo(10f, 3.5f)\n            wallTo(12f, 3.5f)\n            wallTo(12f, 1.5f)\n            wallTo(11f, 0.5f)\n            wallTo(11f, -0.5f)\n            wallTo(12f, -1.5f)\n            wallTo(12f, -3.5f)\n            wallTo(10f, -3.5f)\n            wallTo(9f, -2.5f)\n            wallTo(6f, -2.5f)\n            wallTo(6f, -5.5f)\n            wallTo(7f, -6.5f)\n            wallTo(7f, -8.5f)\n            wallTo(5f, -8.5f)\n            wallTo(4f, -7.5f)\n\n            wallTo(-4f, -7.5f)\n            wallTo(-5f, -8.5f)\n            wallTo(-7f, -8.5f)\n            wallTo(-7f, -6.5f)\n            wallTo(-6f, -5.5f)\n\n            wallTo(-6f, -2.5f)\n            wallTo(-9f, -2.5f)\n            wallTo(-10f, -3.5f)\n            wallTo(-12f, -3.5f)\n            wallTo(-12f, -1.5f)\n            wallTo(-11f, -0.5f)\n            wallTo(-11f, 0.5f)\n            wallTo(-12f, 1.5f)\n            wallTo(-12f, 3.5f)\n            wallTo(-10f, 3.5f)\n            wallTo(-9f, 2.5f)\n            wallTo(-6f, 2.5f)\n            wallTo(-6f, 5.5f)\n            wallTo(-7f, 6.5f)\n            wallTo(-7f, 8.5f)\n            wallTo(-5f, 8.5f)\n            wallTo(-4f, 7.5f)\n\n            textureTable()\n\n            svgWood(\"M 8,-9.5 H -8 v 5 h -5 v 9 h 5 v 5 H 8 v -5 h 5 v -9 H 8 v -5 l -1,1 v 2 l -1,1 v 3 h 3 l 1,-1 h 2 v 2 l -1,1 v 1 l 1,1 v 2 H 10 L 9,2.5 H 6 v 3 l 1,1 v 2 H 5 l -1,-1 h -8 l -1,1 h -2 v -2 l 1,-1 v -3 h -3 l -1,1 h -2 v -2 l 1,-1 v -1 l -1,-1 v -2 h 2 l 1,1 h 3 v -3 l -1,-1 v -2 h 2 l 1,1 h 8 l 1,-1 h 2 z\")\n            textureWood()\n\n            ball(0, 0f, 5.5f)\n            ball(1, -3f, 3.5f)\n            ball(2, 3f, 3.5f)\n            ball(3, -5f, 0.5f)\n            ball(4, 5f, 0.5f)\n            ball(5, -3f, -2.5f)\n            ball(6, 3f, -2.5f)\n            ball(7, 0f, -4.5f)\n\n            pocket(6f, 7.5f)\n            pocket(11f, 2.5f)\n            pocket(11f, -2.5f)\n            pocket(6f, -7.5f)\n            pocket(-6f, -7.5f)\n            pocket(-11f, -2.5f)\n            pocket(-11f, 2.5f)\n            pocket(-6f, 7.5f)\n        }\n\n        originalLevel[9] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            wallTo(-3f, 6.5f)\n            wallTo(3f, 6.5f)\n            wallTo(4f, 7.5f)\n            wallTo(10f, 7.5f)\n            wallTo(11f, 6.5f)\n            wallTo(11f, 2.5f)\n            wallTo(10f, 1.5f)\n            wallTo(10f, -1.5f)\n            wallTo(11f, -2.5f)\n            wallTo(11f, -6.5f)\n            wallTo(10f, -7.5f)\n            wallTo(4f, -7.5f)\n            wallTo(3f, -6.5f)\n            wallTo(-3f, -6.5f)\n            wallTo(-4f, -7.5f)\n            wallTo(-10f, -7.5f)\n            wallTo(-11f, -6.5f)\n            wallTo(-11f, -2.5f)\n            wallTo(-10f, -1.5f)\n            wallTo(-10f, 1.5f)\n            wallTo(-11f, 2.5f)\n            wallTo(-11f, 6.5f)\n            wallTo(-10f, 7.5f)\n            wallTo(-4f, 7.5f)\n            wallTo(-3f, 6.5f)\n\n            textureTable()\n\n            svgWood(\"M 11,-9.5 H 4 l -1,1 h -6 l -1,-1 h -7 l -2,2 v 5 l 1,1 v 3 l -1,1 v 5 l 2,2 h 7 l 1,-1 h 6 l 1,1 h 7 l 2,-2 v -5 l -1,-1 v -3 l 1,-1 v -5 l -2,-2 -1,2 1,1 v 4 l -1,1 v 3 l 1,1 v 4 l -1,1 H 4 l -1,-1 h -6 l -1,1 h -6 l -1,-1 v -4 l 1,-1 v -3 l -1,-1 v -4 l 1,-1 h 6 l 1,1 h 6 l 1,-1 h 6 z\")\n            textureWood()\n\n            svgWood(\"m 3,-3.5 h -6 l -2,2 v 3 l 2,2 h 6 l 2,-2 v -3 z\")\n            textureWood(clear = false)\n\n            ball(0, -9f, 5.5f)\n            ball(1, -9f, 1.5f)\n            ball(2, -7f, -1.5f)\n            ball(3, -9f, -4.5f)\n            ball(4, -2f, 4.5f)\n            ball(5, 1f, 5.5f)\n            ball(6, 4f, 4.5f)\n\n            pocket(-7f, -4.5f)\n            pocket(7f, 4.5f)\n\n\n            startContour()\n            wallTo(-3f, 3.5f)\n            wallTo(3f, 3.5f)\n            wallTo(5f, 1.5f)\n            wallTo(5f, -1.5f)\n            wallTo(3f, -3.5f)\n            wallTo(-3f, -3.5f)\n            wallTo(-5f, -1.5f)\n            wallTo(-5f, 1.5f)\n            wallTo(-3f, 3.5f)\n        }\n\n        originalLevel[10] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            wallTo(-3f, 7.5f)\n            wallTo(9f, 7.5f)\n            wallTo(10f, 8.5f)\n            wallTo(12f, 8.5f)\n            wallTo(12f, 6.5f)\n            wallTo(11f, 5.5f)\n            wallTo(11f, -0.5f)\n            wallTo(12f, -1.5f)\n            wallTo(12f, -3.5f)\n            wallTo(10f, -3.5f)\n            wallTo(9f, -2.5f)\n            wallTo(5f, -2.5f)\n            wallTo(5f, -5.5f)\n            wallTo(6f, -6.5f)\n            wallTo(6f, -8.5f)\n            wallTo(4f, -8.5f)\n            wallTo(3f, -7.5f)\n            wallTo(-9f, -7.5f)\n            wallTo(-10f, -8.5f)\n            wallTo(-12f, -8.5f)\n            wallTo(-12f, -6.5f)\n            wallTo(-11f, -5.5f)\n            wallTo(-11f, 0.5f)\n            wallTo(-12f, 1.5f)\n            wallTo(-12f, 3.5f)\n            wallTo(-10f, 3.5f)\n            wallTo(-9f, 2.5f)\n            wallTo(-5f, 2.5f)\n            wallTo(-5f, 5.5f)\n            wallTo(-6f, 6.5f)\n            wallTo(-6f, 8.5f)\n            wallTo(-4f, 8.5f)\n            wallTo(-3f, 7.5f)\n\n            textureTable()\n\n            svgWood(\"M 13,-9.5 H -7 v 5 h -6 v 14 H 7 v -5 h 6 v -14 l -1,1 v 2 l -1,1 v 6 l 1,1 v 2 H 10 L 9,2.5 H 5 v 3 l 1,1 v 2 H 4 L 3,7.5 H -9 l -1,1 h -2 v -2 l 1,-1 v -6 l -1,-1 v -2 h 2 l 1,1 h 4 v -3 l -1,-1 v -2 h 2 l 1,1 H 9 l 1,-1 h 2 z\")\n            textureWood()\n\n            ball(0, 0f, 0.0f)\n            ball(1, -3f, 4.5f)\n            ball(2, 8f, 4.5f)\n            ball(3, 8f, -1.5f)\n            ball(4, 3f, -4.5f)\n            ball(5, -8f, -4.5f)\n            ball(6, -8f, 1.5f)\n\n            pocket(-5f, 7.5f)\n            pocket(11f, 7.5f)\n            pocket(11f, -2.5f)\n            pocket(5f, -7.5f)\n            pocket(-11f, -7.5f)\n            pocket(-11f, 2.5f)\n            pocket(-5f, 7.5f)\n        }\n\n        originalLevel[11] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            svgWalls(\"M 12,-8 H 4 l -3,3 v 1 h -2 v -1 l -3,-3 h -8 v 3 l 4,4 h 1 v 2 h -1 l -4,4 v 3 h 8 L -1,5 V 4 h 2 v 1 l 3,3 h 8 V 5 L 8,1 H 7 v -2 h 1 l 4,-4 z\")\n            textureTable()\n\n            svgWood(\"M 13,-9 H 2 l -2,2 -2,-2 h -11 v 6 l 3,3 -3,3 V 9 H -2 L 0,7 2,9 H 13 V 3 l -3,-3 3,-3 v -6 l -1,1 v 3 L 8,-1 H 7 v 2 h 1 l 4,4 V 8 H 4 L 1,5 V 4 h -2 v 1 l -3,3 h -8 V 5 l 4,-4 h 1 v -2 h -1 l -4,-4 v -3 h 8 l 3,3 v 1 h 2 v -1 l 3,-3 h 8 z\")\n            textureWood()\n\n            ball(0, 0f, 0f)\n            ball(1, -5f, 0f)\n            ball(2, 5f, 0f)\n            ball(3, -1f, 2f)\n            ball(4, 1f, 2f)\n            ball(5, -1f, -2f)\n            ball(6, 1f, -2f)\n\n            pocket(-1f, 4f)\n            pocket(-5f, 8f)\n            pocket(-12f, 8f)\n            pocket(7f, 1f)\n            pocket(7f, -1f)\n            pocket(12f, -8f)\n            pocket(5f, -8f)\n            pocket(1f, -4f)\n            pocket(-1f, -4f)\n            pocket(-5f, -8f)\n            pocket(-12f, -8f)\n            pocket(-7f, -1f)\n            pocket(-7f, 1f)\n            pocket(-12f, 8f)\n            pocket(1f, 4f)\n            pocket(5f, 8f)\n            pocket(12f, 8f)\n        }\n\n        originalLevel[12] = LevelDescriptor(ballsCount = 7) {\n            reset()\n\n            startContour()\n            svgWalls(\"m 4,-7 3,3 V 5 L 4,8 H -4 L -7,5 v -9 l 3,-3 z\")\n            textureTable()\n\n            svgWood(\"M 5,-9 H -5 l -4,4 V 6 l 4,4 H 5 L 9,6 V -5 L 5,-9 4,-7 7,-4 V 5 L 4,8 H -4 L -7,5 v -9 l 3,-3 h 8 z\")\n            textureWood()\n\n            svgBalls(\"m 0,-4.5 -3,2 h 6 l -8,3 H 5 l -8,3 h 6 l -3,2\")\n\n            svgPockets(\"m 0,-1.5 1,1 1,1 -1,1 -1,1 -1,-1 -1,-1 1,-1\")\n        }\n\n        originalLevel[13] = LevelDescriptor(ballsCount = 7) {\n            reset()\n\n            startContour()\n            wallTo(-9f, 8f)\n            wallTo(3f, 8f)\n            wallTo(11f, 0f)\n            wallTo(3f, -8f)\n            wallTo(-9f, -8f)\n            wallTo(-1f, 0f)\n            wallTo(-9f, 8f)\n\n            textureTable()\n\n            svgWood(\"m 4,-9 h -17 l 9,9 -9,9 H 4 L 13,0 4,-9 3,-8 11,0 3,8 H -9 L -1,0 -9,-8 H 3 Z\")\n            textureWood()\n\n            ball(0, 0f, -7f)\n            ball(1, 4f, -3f)\n            ball(2, 4f, -1f)\n            ball(3, 4f, 1f)\n            ball(4, 6f, 1f)\n            ball(5, 6f, -1f)\n            ball(6, 6f, -3f)\n            ball(7, 2f, -5f)\n\n            pocket(9f, 0f)\n        }\n\n        originalLevel[14] = LevelDescriptor(ballsCount = 7) {\n            reset()\n\n            svgWalls(\"m -1,-8.5 h 13 v 7 l -1,1 v 2 l -1,1 v 1 l -3,3 H 6 l -1,1 H 2 l -1,1 h -13 v -7 l 1,-1 v -2 l 1,-1 v -1 l 3,-3 h 1 l 1,-1 h 3 z\")\n\n            svgWood(\"m 13,-9.5 v 19 h -26 v -19 h 26 l -1,1 H -1 l -1,1 h -3 l -1,1 h -1 l -3,3 v 1 l -1,1 v 2 l -1,1 v 7 H 1 l 1,-1 h 3 l 1,-1 h 1 l 3,-3 v -1 l 1,-1 v -2 l 1,-1 v -7 z\")\n\n            textureTable()\n\n            textureWood()\n\n            svgBalls(\"m 0,-5.5 -1,3 h 2 l 5,-4 -16,6 4,7 10,-3 6,-3\")\n\n            pocket(0f, 0f)\n        }\n\n        originalLevel[15] = LevelDescriptor(ballsCount = 5) {\n            reset()\n            svgWalls(\"m 0,-8.5 4,4 h 8 v 9 H 4 l -4,4 -4,-4 h -8 v -9 h 8 z\")\n            textureTable()\n\n            svgWood(\"m 12,-4.5 1,-1 v 11 H 6 l -4,4 h -4 l -4,-4 h -7 v -11 h 7 l 4,-4 h 4 l 4,4 h 7 l -1,1 H 4 l -4,-4 -4,4 h -8 v 9 h 8 l 4,4 4,-4 h 8 z\")\n            textureWood()\n\n            svgWalls(\"m -8,-0.5 h 1 v -1 h 1 v 1 h 1 v 1 h -1 v 1 h -1 v -1 h -1 z\")\n            svgWalls(\"m -2,-0.5 h 4 v 1 h -4 z\")\n            svgWalls(\"m 6,-0.5 h 1 v -1 h 1 v 1 h 1 v 1 H 8 v 1 H 7 v -1 H 6 Z\")\n\n            svgWood(\"m -8,-0.5 h 1 v -1 h 1 v 1 h 1 v 1 h -1 v 1 h -1 v -1 h -1 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m -2,-0.5 h 4 v 1 h -4 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 6,-0.5 h 1 v -1 h 1 v 1 h 1 v 1 H 8 v 1 H 7 v -1 H 6 Z\")\n            textureWood(clear = false)\n\n\n            svgBalls(\"m 0,-6.5 -4,4 h 2 2 2 2\")\n\n            svgPockets(\"m -7,-0.5 h 1 l -1,1 h 1 l 6,-1 v 1 l 7,-1 h 1 v 1 H 7\")\n        }\n\n        originalLevel[16] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m 10,-8.5 2,2 v 4 l -1,1 v 1 h 1 v 7 l -2,2 h -20 l -2,-2 v -4 l 1,-1 v -1 h -1 v -7 l 2,-2 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -3,1 2,2 v 4 l -1,1 v 1 h 1 v 7 l -2,2 h -20 l -2,-2 v -4 l 1,-1 v -1 h -1 v -7 l 2,-2 h 20 z\")\n            textureWood()\n\n            svgWood(\"m -6,-0.5 h 4 v 1 h -4 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 2,-0.5 h 4 v 1 H 2 Z\")\n            textureWood(clear = false)\n\n\n            svgWalls(\"m -6,-0.5 h 4 v 1 h -4 z\")\n            svgWalls(\"m 2,-0.5 h 4 v 1 H 2 Z\")\n\n            svgBalls(\"m 0,-5.5 -9,4 v -2 -2 l 18,7 v 2 2\")\n\n            svgPockets(\"m -11,-0.5 22,1\")\n        }\n\n        originalLevel[17] = LevelDescriptor(ballsCount = 5) {\n            reset()\n            svgWalls(\"m -12,-8.5 h 5 l 1,1 1,-1 H 5 l 1,1 1,-1 h 5 v 6 l -1,1 1,1 v 9 H 7 l -1,-1 -1,1 H -5 l -1,-1 -1,1 h -5 v -6 l 1,-1 -1,-1 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 6 l -1,1 1,1 v 9 H 7 l -1,-1 -1,1 H -5 l -1,-1 -1,1 h -5 v -6 l 1,-1 -1,-1 v -9 h 5 l 1,1 1,-1 H 5 l 1,1 1,-1 h 5 z\")\n            textureWood()\n\n            svgWood(\"m -9,4.5 h 1 v 1 h -1 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 8,-5.5 h 1 v 1 H 8 Z\")\n            textureWood(clear = false)\n\n            svgWalls(\"m -9,4.5 h 1 v 1 h -1 z\")\n            svgWalls(\"m 8,-5.5 h 1 v 1 H 8 Z\")\n\n            svgBalls(\"m 2,1.5 -4,-4 9,-4 3,3 -17,10 -3,-3\")\n\n            svgPockets(\"m -11,7.5 22,-15\")\n        }\n\n        //this is custom level\n        originalLevel[18] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"M -1.873768,-5.501028 -9.7545238,-6.9787165 -5.9028566,0.044536 -9.780109,7.097959 -1.873768,5.590101 3.636299,11.457214 4.645434,3.471884 11.928095,0.044537 4.645434,-3.382811 3.636299,-11.368142 Z\")\n            textureTable()\n\n            svgWood(\"m -2.191965,-6.5984955 -9.471005,-1.8062638 4.6445599,8.4492953 -4.6445609,8.449296 9.471006,-1.806264 6.600509,7.028216 1.208843,-9.565628 8.7239,-4.105619 -8.7239,-4.10562 -1.208842,-9.565628 -6.60051,7.0282155 0.318197,1.0974675 5.510067,-5.867114 1.009135,7.985331 7.282661,3.427348 -7.282661,3.427347 -1.009135,7.98533 -5.510067,-5.867113 -7.906341,1.507858 3.877252,-7.053423 -3.8516668,-7.0232525 7.8807558,1.4776885 z\")\n            textureWood()\n\n            svgBalls(\"M 1.4989936,-4.8729264 -4.2375148,-2.9096429 -4.183409,3.0064445 1.422223,4.8747718 4.9416018,0.04071578 2.4855285,-7.3913398 2.3781083,7.5860744\")\n\n            svgPockets(\"m -6.4964445,4.6800963 -0.06241,-9.198239 14.6998834,4.58931737 -8.24304055,0.03251996\")\n        }\n\n        originalLevel[19] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m -6,-5.5 v -2 H 6 v 2 l 3,-3 h 3 v 3 l -3,3 h 1 l 2,-2 v 9 l -2,-2 H 9 l 3,3 v 3 H 9 l -3,-3 v 2 H -6 v -2 l -3,3 h -3 v -3 l 3,-3 h -1 l -2,2 v -9 l 2,2 h 1 l -3,-3 v -3 h 3 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 3 l -3,3 h 1 l 2,-2 v 9 l -2,-2 H 9 l 3,3 v 3 H 9 l -3,-3 v 2 H -6 v -2 l -3,3 h -3 v -3 l 3,-3 h -1 l -2,2 v -9 l 2,2 h 1 l -3,-3 v -3 h 3 l 3,3 v -2 H 6 v 2 l 3,-3 h 3 z\")\n            textureWood()\n\n            svgWood(\"m -6,-1.5 1,1 v 1 l -1,1 -1,-1 v -1 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 0,3.5 1,1 -1,1 -1,-1 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 5,-0.5 1,-1 1,1 v 1 l -1,1 -1,-1 z\")\n            textureWood(clear = false)\n\n            svgWalls(\"m -6,-1.5 1,1 v 1 l -1,1 -1,-1 v -1 z\")\n            svgWalls(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n            svgWalls(\"m 0,3.5 1,1 -1,1 -1,-1 z\")\n            svgWalls(\"m 5,-0.5 1,-1 1,1 v 1 l -1,1 -1,-1 z\")\n\n            svgBalls(\"m 0,0 v -6.5 13 l -9,-12 H 9 v 11 H -9\")\n\n            svgPockets(\"m -11,-6.5 1,-1 h 20 l 1,1 v 13 l -1,1 h -20 l -1,-1\")\n        }\n\n        originalLevel[20] = LevelDescriptor(ballsCount = 6) {\n            reset()\n\n            startContour()\n            wallTo(-11f, 4f)\n            wallTo(-12f, 3f)\n            wallTo(-12f, -3f)\n            wallTo(-11f, -4f)\n            wallTo(11f, -4f)\n            wallTo(12f, -3f)\n            wallTo(12f, 3f)\n            wallTo(11f, 4f)\n            wallTo(-11f, 4f)\n\n            textureTable()\n\n            svgWood(\"M 13,-5 H -13 V 5 H 13 V -5 l -2,1 1,1 v 6 l -1,1 h -22 l -1,-1 v -6 l 1,-1 h 22 z\")\n            textureWood()\n\n            rhombus(-9, 2)\n            rhombus(-1, -2)\n            rhombus(1, 2)\n            rhombus(9, -2)\n\n            pocket(-5, 3)\n            pocket(-3, -2)\n            pocket(3, 1)\n\n            pocket(-11, -2)\n            pocket(-11, -1)\n\n            svgBalls(\"M 8.5,-2.5 3.0,-3.0 5.0,-2.0 7.0,-1 1.0,1.0 -6.5,-0.5 -7.5,2.5\")\n        }\n\n        originalLevel[21] = LevelDescriptor(ballsCount = 7) {\n            reset()\n            svgWalls(\"m -1,-8 h 2 l 6,6 5,-5 V 6 L 10,8 H -10 L -12,6 V -7 l 5,5 z\")\n            textureTable()\n\n            svgWood(\"M 13,-9 H -13 V 9 H 13 V -9 l -1,2 V 6 L 10,8 H -10 L -12,6 V -7 l 5,5 6,-6 h 2 l 6,6 5,-5 z\")\n            textureWood()\n\n            svgWood(\"m -4,-3 3,-3 V 3 H -2 L -4,1 Z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 1,-6 3,3 V 1 L 2,3 H 1 Z\")\n            textureWood(clear = false)\n\n            svgWood(\"m -10,-1 1,-1 1,1 -1,1 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 8,-1 1,-1 1,1 -1,1 z\")\n            textureWood(clear = false)\n\n\n            svgWalls(\"m -4,-3 3,-3 V 3 H -2 L -4,1 Z\")\n            svgWalls(\"m 1,-6 3,3 V 1 L 2,3 H 1 Z\")\n            svgWalls(\"m -10,-1 1,-1 1,1 -1,1 z\")\n            svgWalls(\"m 8,-1 1,-1 1,1 -1,1 z\")\n\n            svgBalls(\"m -4,7 h 2 L -11,4 V 2 H 11 V 4 L 4,7 H 2\")\n\n            svgPockets(\"M -10,-3 H 10 L 0,7\")\n        }\n\n        originalLevel[22] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m -12,-8.5 h 24 v 17 h -24 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 17 h -24 v -17 h 24 z\")\n            textureWood()\n\n            svgWood(\"m -9,-2.5 7,7 v 1 l -7,-7 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 2,4.5 7,-7 v 1 l -7,7 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n            textureWood(clear = false)\n\n            svgWalls(\"m -9,-2.5 7,7 v 1 l -7,-7 z\")\n            svgWalls(\"m 2,4.5 7,-7 v 1 l -7,7 z\")\n            svgWalls(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n\n            svgBalls(\"m 2,-6.5 h -4 v 6 h 2 2 l -4,2 h 2 2\")\n\n            svgPockets(\"m 0,3.5 v 4\")\n        }\n\n        originalLevel[23] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m 2,-7.5 h 7 l 1,-1 h 2 v 2 l -1,1 v 2 L 0,7.5 v 1 h -2 v -1 h -7 l -1,1 h -2 v -2 l 1,-1 v -2 l 11,-11 v -1 h 2 z\")\n            textureTable()\n\n            svgWood(\"M 13,-9.5 H -1 l -12,12 v 7 H 1 l 12,-12 v -7 l -1,1 v 2 l -1,1 v 2 L 0,7.5 v 1 h -2 v -1 h -7 l -1,1 h -2 v -2 l 1,-1 v -2 l 11,-11 v -1 h 2 v 1 h 7 l 1,-1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"m -3,0.5 -1,2 -1,2 -1,2 9,-7 1,-2 1,-2 1,-2\")\n\n            svgPockets(\"m 1,-8.5 10,1 -12,16 -10,-1\")\n        }\n\n        originalLevel[24] = LevelDescriptor(ballsCount = 6) {}\n\n        originalLevel[25] = LevelDescriptor(ballsCount = 6) {}\n\n        originalLevel[26] = LevelDescriptor(ballsCount = 7) {\n            reset()\n            svgWalls(\"M 10,0 2,-8 h -6 l 4,4 H -12 V 4 H 0 l -4,4 h 6 z\")\n            textureTable()\n\n            svgWood(\"M 4,-9 H -8 l 4,4 h -9 V 5 h 9 L -8,9 H 4 L 13,0 4,-9 2,-8 10,0 2,8 H -4 L 0,4 H -12 V -4 H 0 l -4,-4 h 6 z\")\n            textureWood()\n\n            svgWood(\"M 5,0 4,-1 3,0 4,1 Z\")\n            textureWood(clear = false)\n\n            svgWalls(\"M 5,0 4,-1 3,0 4,1 Z\")\n\n            svgBalls(\"m -11,0 h 2 2 6 l -2,-2 h -2 l 2,4 h -2\")\n\n            svgPockets(\"M 1.5,-7 V 7\")\n        }\n\n        originalLevel[27] = LevelDescriptor(ballsCount = 6) {}\n\n        originalLevel[28] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m -2,-8.5 h 4 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 1,-1 h 2 v 2 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 1 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 2 h -2 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -4 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -2 v -2 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -1 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -2 h 2 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 z\")\n            textureTable()\n\n            svgWood(\"m 12,-9.5 h -24 l -1,1 v 17 l 1,1 h 24 l 1,-1 v -17 l -1,-1 v 1 2 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 1 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 2 h -2 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -4 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -2 v -2 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -1 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -2 h 2 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 1,-1 h 4 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 1,-1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"M -6,0 H 4 L 5.5,-1 V 1 L 7,-2 v 2 2\")\n\n            svgPockets(\"m -11,-7.5 11,-1 11,1 v 15 l -11,1 -11,-1\")\n        }\n\n        originalLevel[29] = LevelDescriptor(ballsCount = 6) {}\n\n        originalLevel[30] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"M -9,-7.5 H 9 l 1,-1 h 2 v 2 l -1,1 H 9 l -1,1 H 6 l -1,1 H 3 l -1,1 v 1 h 2 l 1,-1 h 2 l 1,-1 h 4 v 7 H 8 L 7,2.5 H 5 L 4,1.5 H 2 v 1 l 1,1 h 2 l 1,1 h 2 l 1,1 h 2 l 1,1 v 2 H 10 L 9,7.5 H -9 l -1,1 h -2 v -2 l 1,-1 h 2 l 1,-1 h 2 l 1,-1 h 2 l 2,-2 v -3 l -2,-2 h -2 l -1,-1 h -2 l -1,-1 h -2 l -1,-1 v -2 h 2 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 l -1,1 H 9 l -1,1 H 6 l -1,1 H 3 l -1,1 v 1 h 2 l 1,-1 h 2 l 1,-1 h 4 v 7 H 8 L 7,2.5 H 5 L 4,1.5 H 2 v 1 l 1,1 h 2 l 1,1 h 2 l 1,1 h 2 l 1,1 v 2 H 10 L 9,7.5 H -9 l -1,1 h -2 v -2 l 1,-1 h 2 l 1,-1 h 2 l 1,-1 h 2 l 2,-2 v -3 l -2,-2 h -2 l -1,-1 h -2 l -1,-1 h -2 l -1,-1 v -2 h 2 l 1,1 H 9 l 1,-1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"M 0.5,0 -8,-6.5 h 2 2 L 8,6.5 H 6 4\")\n\n            svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n        }\n\n        originalLevel[33] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m 1,-6.5 10,10 v 2 h 1 v 2 h -24 v -2 h 1 v -2 l 10,-10 v -1 h 2 z\")\n            textureTable()\n\n            svgWood(\"m 1,-8.5 h -2 l -12,12 v 5 h 26 v -5 L 1,-8.5 v 1 1 l 10,10 v 2 h 1 v 2 h -24 v -2 h 1 v -2 l 10,-10 v -1 h 2 z\")\n            textureWood()\n\n            svgBalls(\"m 0,2.5 -8,3 2,-1 2,-1 12,2 -2,-1 -2,-1\")\n\n            svgPockets(\"M -12,6.5 H 12 L 0,-7.5\")\n        }\n\n        originalLevel[36] = LevelDescriptor(ballsCount = 7) {\n            reset()\n            svgWalls(\"m -9,-7.5 v -1 H 8 l 1,1 1,-1 h 2 v 2 l -1,1 1,1 v 9 l -1,1 1,1 v 2 h -2 l -1,-1 -1,1 H -9 v -1 h -1 v 1 h -2 v -2 h 1 v -1 h -1 v -11 h 1 v -1 h -1 v -2 h 2 v 1 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 l -1,1 1,1 v 9 l -1,1 1,1 v 2 h -2 l -1,-1 -1,1 H -9 v -1 h -1 v 1 h -2 v -2 h 1 v -1 h -1 v -11 h 1 v -1 h -1 v -2 h 2 v 1 h 1 v -1 H 8 l 1,1 1,-1 h 2 z\")\n            textureWood()\n\n            svgWood(\"m 0,-5.5 h 6 v 1 H 0 Z\")\n            textureWood(clear = false)\n\n            svgWood(\"m -5,-0.5 h 4 v 1 h -4 z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 5,-0.5 h 4 v 1 H 5 Z\")\n            textureWood(clear = false)\n\n            svgWood(\"m 0,4.5 h 6 v 1 H 0 Z\")\n            textureWood(clear = false)\n\n\n            svgWalls(\"m 0,-5.5 h 6 v 1 H 0 Z\")\n            svgWalls(\"m -5,-0.5 h 4 v 1 h -4 z\")\n            svgWalls(\"m 5,-0.5 h 4 v 1 H 5 Z\")\n            svgWalls(\"m 0,4.5 h 6 v 1 H 0 Z\")\n\n            svgBalls(\"m 3,0 5,-6.5 1,2 -2,1 1,10 1,-2 -2,-1 3.5,-3.5\")\n\n            svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n        }\n\n        originalLevel[37] = LevelDescriptor(ballsCount = 6) {\n            reset()\n            svgWalls(\"m 3,-6.5 1,-1 h 6 l 1,1 v 4 l -1,1 v 3 l 1,1 v 4 l -1,1 H 4 l -1,-1 h -6 l -1,1 h -6 l -1,-1 v -4 l 1,-1 v -3 l -1,-1 v -4 l 1,-1 h 6 l 1,1 z\")\n            textureTable()\n\n            svgWood(\"M 11,-9.5 H 4 l -1,1 h -6 l -1,-1 h -7 l -2,2 v 5 l 1,1 v 3 l -1,1 v 5 l 2,2 h 7 l 1,-1 h 6 l 1,1 h 7 l 2,-2 v -5 l -1,-1 v -3 l 1,-1 v -5 l -2,-2 -1,2 1,1 v 4 l -1,1 v 3 l 1,1 v 4 l -1,1 H 4 l -1,-1 h -6 l -1,1 h -6 l -1,-1 v -4 l 1,-1 v -3 l -1,-1 v -4 l 1,-1 h 6 l 1,1 h 6 l 1,-1 h 6 z\")\n            textureWood()\n\n            svgWood(\"m -1,-1.5 h 2 v 1 h 1 v 2 H 0 v -1 h -1 z\")\n            textureWood(clear = false)\n\n            svgWalls(\"m -1,-1.5 h 2 v 1 h 1 v 2 H 0 v -1 h -1 z\")\n\n            svgBalls(\"M -6,0 H 4 L 5.5,-1 V 1 L 7,-2 v 2 2\")\n\n            svgPockets(\"m -7,-4.5 14,9\")\n        }\n\n        originalLevel[40] = LevelDescriptor(ballsCount = 7) {\n            reset()\n            svgWalls(\"m -12,-8.5 h 24 v 17 h -24 z\")\n            textureTable()\n\n            svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 17 h -24 v -17 h 24 z\")\n            textureWood()\n\n            svgSquares(\"m 6.5,-5 h -2 -2 -2 -2 -2 -2 l -2,2 v 6 l 2,2 h 2 2 2 2 2 2\")\n\n            svgBalls(\"m -7,-7.5 2,1 2,-1 2,1 2,-1 2,1 L 0,0 v 7\")\n\n            svgPockets(\"m 11,-7.5 v 15 l -19,-7 v -1\")\n        }\n    }\n\n    val levels = Array<LevelDescriptor?>(LEVELS_COUNT + 1) { null }.apply {\n        val level = this\n\n        level[1] = originalLevels[1]\n        level[2] = originalLevels[2]\n        level[3] = originalLevels[3]\n        level[4] = originalLevels[4]\n        level[5] = originalLevels[5]\n        level[6] = originalLevels[6]\n        level[7] = originalLevels[7]\n        level[8] = originalLevels[8]\n        level[9] = originalLevels[9]\n        level[10] = originalLevels[10]\n        level[11] = originalLevels[11]\n        level[12] = originalLevels[12]\n        level[13] = originalLevels[13]\n        level[14] = originalLevels[14]\n        level[15] = originalLevels[15]\n        level[16] = originalLevels[16]\n        level[17] = originalLevels[17]\n        level[18] = originalLevels[18]\n        level[19] = originalLevels[19]\n        level[20] = originalLevels[20]\n        level[21] = originalLevels[21]\n        level[22] = originalLevels[22]\n        level[23] = originalLevels[23]\n        level[24] = originalLevels[26]\n        level[25] = originalLevels[28]\n        level[26] = originalLevels[30]\n        level[27] = originalLevels[33]\n        level[28] = originalLevels[36]\n        level[29] = originalLevels[37]\n        level[30] = originalLevels[40]\n    }\n}","package kmptemplate.arrays\n\nclass IntArr2D(val s0: Int, val s1: Int, val data: IntArray = IntArray(s0 * s1)) {\n\n    val s = IntArray(DIM)\n    val numel: Int\n\n    init {\n        s[0] = s0\n        s[1] = s1\n\n        numel = s0 * s1\n    }\n\n    fun checkIndex(i0: Int, i1: Int) {\n        require(i0 in 0 until s0 && i1 in 0 until s1) { \"index accessed: [${i0},${i1}], but the size is ${s0}x${s1}\" }\n    }\n\n    operator fun set(i0: Int, i1: Int, v: Int) {\n        checkIndex(i0, i1)\n        data[i0 + i1 * s0] = v\n    }\n\n    operator fun get(i0: Int, i1: Int): Int {\n        checkIndex(i0, i1)\n        return data[i0 + i1 * s0]\n    }\n\n    inline fun iter(codeblock: (i0: Int, i1: Int) -> Unit) {\n        for (i1 in 0 until s1) {\n            for (i0 in 0 until s0) {\n                codeblock(i0, i1)\n            }\n        }\n    }\n\n    companion object {\n        const val DIM = 2\n    }\n}\n\n\nclass IntArr3D(val s0: Int, val s1: Int, val s2: Int, val data: IntArray = IntArray(s0 * s1 * s2)) {\n\n    val s = IntArray(DIM)\n    val numel: Int\n\n    init {\n        s[0] = s0\n        s[1] = s1\n        s[2] = s2\n\n        numel = s0 * s1 * s2\n    }\n\n    fun checkIndex(i0: Int, i1: Int, i2: Int) {\n        require(\n            i0 in 0 until s0\n                    && i1 in 0 until s1\n                    && i2 in 0 until s2\n        ) { \"index accessed: [${i0},${i1},${i2}], but the size is ${s0}x${s1}x${s2}\" }\n    }\n\n    operator fun set(i0: Int, i1: Int, i2: Int, v: Int) {\n        checkIndex(i0, i1, i2)\n        data[i0 + i1 * s0 + i2 * s0 * s1] = v\n    }\n\n    operator fun get(i0: Int, i1: Int, i2: Int): Int {\n        checkIndex(i0, i1, i2)\n        return data[i0 + i1 * s0 + i2 * s0 * s1]\n    }\n\n    companion object {\n        const val DIM = 3\n    }\n}\n","package kmptemplate.nodes\n\nimport kotlin.jvm.JvmName\n\ninline fun <T> IF(cond: Node<Boolean>, trueNode: Node<T>, falseNode: Node<T>): Node<T> {\n    val res = Node(if (cond.value) trueNode.value else falseNode.value)\n\n    val calcOnChange = {\n        res.value = if (cond.value) trueNode.value else falseNode.value\n    }\n    cond.onChange.add(calcOnChange)\n    trueNode.onChange.add(calcOnChange)\n    falseNode.onChange.add(calcOnChange)\n\n    return res\n}\n\ninline fun <T> IF(cond: Node<Boolean>, trueValue: T, falseValue: T): Node<T> {\n    val res = Node(if (cond.value) trueValue else falseValue)\n\n    val calcOnChange = {\n        res.value = if (cond.value) trueValue else falseValue\n    }\n    cond.onChange.add(calcOnChange)\n\n    return res\n}\n\ninfix fun <T> Node<T>.eq(that: Node<T>): Node<Boolean> {\n    val res = Node(this.value == that.value)\n\n    val calcOnChange = {\n        res.value = this.value == that.value\n    }\n\n    this.onChange.add(calcOnChange)\n    that.onChange.add(calcOnChange)\n\n    return res\n}\n\ninfix fun Node<Int>.gt(that: Node<Int>) = node(this, that) { this.value > that.value }\n\ninfix fun Node<Int>.lt(that: Node<Int>) = node(this, that) { this.value < that.value }\n\ninfix fun Node<Int>.gtEq(that: Node<Int>) = node(this, that) { this.value >= that.value }\n\ninfix fun Node<Int>.ltEq(that: Node<Int>) = node(this, that) { this.value <= that.value }\n\n\ninfix fun Node<Int>.gt(that: Int) = node(this) { this.value > that }\n\ninfix fun Node<Int>.lt(that: Int) = node(this) { this.value < that }\n\ninfix fun Node<Int>.gtEq(that: Int) = node(this) { this.value >= that }\n\ninfix fun Node<Int>.ltEq(that: Int) = node(this) { this.value < that }\n\nfun not(n: Node<Boolean>) = node(n) { !n.value }\n\ninfix fun <T> Node<T>.eq(that: T): Node<Boolean> {\n    val res = Node(this.value == that)\n\n    val calcOnChange = {\n        res.value = this.value == that\n    }\n\n    this.onChange.add(calcOnChange)\n\n    return res\n}\n\nfun <T1, R> node(node1: Node<T1>, calc: () -> R): Node<R> {\n    val res = Node(calc())\n\n    val calcOnChange = {\n        res.value = calc()\n    }\n    node1.onChange.add(calcOnChange)\n\n    return res\n}\n\nfun <T1, T2, R> node(node1: Node<T1>, node2: Node<T2>, calc: () -> R): Node<R> {\n    val res = Node(calc())\n\n    val calcOnChange = {\n        res.value = calc()\n    }\n    node1.onChange.add(calcOnChange)\n    node2.onChange.add(calcOnChange)\n\n    return res\n}\n\n\nfun <T, T1> Node<T>.setNode(node1: Node<T1>, calc: T.() -> Unit) {\n    calc(value)\n    val calcOnChange = {\n        calc(value)\n    }\n    node1.onChange.add(calcOnChange)\n}\n\nfun <T, T1, T2> Node<T>.setNode(node1: Node<T1>, node2: Node<T2>, calc: (T) -> Unit) {\n    calc(value)\n    val calcOnChange = {\n        calc(value)\n    }\n    node1.onChange.add(calcOnChange)\n    node2.onChange.add(calcOnChange)\n}\n\n\nclass Node<T>(initialValue: T) {\n    var onChange = mutableListOf<() -> Unit>()\n\n    var value = initialValue\n        set(value) {\n            val changed = value != field\n            field = value\n            if (changed) {\n                onChange.forEach { it.invoke() }\n            }\n        }\n\n    override fun toString(): String {\n        return value.toString()\n    }\n}\n\n\n@JvmName(\"NodeInt_plus\")\noperator fun Node<Int>.plus(that: Node<Int>): Node<Int> {\n    val res = Node(this.value + that.value)\n    this.onChange.add { res.value = this.value + that.value }\n    that.onChange.add { res.value = this.value + that.value }\n    return res\n}\n\n\n@JvmName(\"NodeString_plus\")\noperator fun <T> Node<String>.plus(that: Node<T>): Node<String> {\n    val res = Node(this.value + that.value)\n    this.onChange.add { res.value = this.value + that.value }\n    that.onChange.add { res.value = this.value + that.value }\n    return res\n}\n\ninfix fun <T> String.concat(that: Node<T>): Node<String> {\n    val res = Node(this + that.value)\n    that.onChange.add { res.value = this + that.value }\n    return res\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.color.COLOR_CYAN\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.nodes.IF\nimport kmptemplate.nodes.Node\nimport kmptemplate.nodes.gtEq\nimport kmptemplate.nodes.node\nimport kmptemplate.nodes.not\nimport kmptemplate.ui.Widget\nimport kmptemplate.ui.box\nimport kmptemplate.ui.column\nimport kmptemplate.ui.grid\nimport kmptemplate.ui.img\nimport kmptemplate.ui.padding\nimport kmptemplate.ui.row\nimport kmptemplate.ui.space\nimport kmptemplate.ui.text\n\nclass LevelsMenu(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var menuWidget: Widget\n    private lateinit var im: ImmediateMode\n\n    companion object {\n        val LEVELS_COUNT = 30\n    }\n\n    private val starNodes = Array(LEVELS_COUNT + 1) { Node(0) }\n    private val locked = Array(LEVELS_COUNT + 1) { Node(false) }\n\n    val totalStarsNode = Node(0)\n    val totalScoreNode = Node(0)\n\n    override fun init(gloo: GLOO) {\n        im = ImmediateMode(gloo)\n\n        menuWidget = column {\n            text(game.loc.game_name, game.resources.font, 2.5f) {\n                outlineColor.value = Color(COLOR_BLACK)\n            }\n\n            space(0.5f)\n\n            row {\n                text(node(totalStarsNode) { totalStarsNode.value.toString() }, game.resources.font, 1.5f) {\n                    outlineColor.value = Color(COLOR_BLACK)\n                }\n                img(game.resources.starTexture, 1.5f, 1.5f)\n            }\n\n            text(node(totalScoreNode) { game.loc.score(totalScoreNode.value) }, game.resources.font, 1.5f) {\n                outlineColor.value = Color(COLOR_BLACK)\n            }\n\n\n            space(0.5f)\n\n            grid {\n\n                columns = 5\n                for (lvl in 1..LEVELS_COUNT) {\n                    padding(0.25f) {\n                        padding(0.25f) {\n                            drawBg = true\n\n                            column {\n                                text(\"${lvl}\", game.resources.font, 1f) {\n                                    color.value = COLOR_BLACK\n                                    bgColor.value = COLOR_CYAN\n\n                                    compress = 0.65f\n                                }\n\n                                box {\n                                    row {\n                                        img(game.resources.clothTexture, 1f, 1f) {\n                                            texture = IF(starNodes[lvl] gtEq 1, game.resources.starTexture, game.resources.emptyStarTexture)\n                                        }\n\n                                        img(game.resources.clothTexture, 1f, 1f) {\n                                            texture = IF(starNodes[lvl] gtEq 2, game.resources.starTexture, game.resources.emptyStarTexture)\n                                        }\n\n                                        img(game.resources.clothTexture, 1f, 1f) {\n                                            texture = IF(starNodes[lvl] gtEq 3, game.resources.starTexture, game.resources.emptyStarTexture)\n                                        }\n\n                                        visible = not(locked[lvl])\n                                    }\n\n                                    img(game.resources.lockTexture, 1.5f, 1.5f) {\n                                        visible = locked[lvl]\n                                    }\n                                }\n\n\n                            }\n\n                            onMouseDown = {\n                                game.soundManager.play(game.resources.buttonSound)\n                                if (!locked[lvl].value) {\n                                    game.aimDialog.show(lvl)\n                                } else {\n                                    game.notEnoughStarsDialog.show(lvl)\n                                }\n                            }\n                            onTouchDown = onMouseDown\n                        }\n                    }\n                }\n            }\n        }\n\n        show()\n    }\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        if (inputActive) {\n            input.forEvents { event ->\n                menuWidget.handleEvent(event, game.uiCam)\n            }\n        }\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        menuWidget.measureSelf()\n        menuWidget.layoutChilds()\n    }\n\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        im.disableDepthTest()\n        menuWidget.render(im, game.uiCam)\n        im.enableDepthTest()\n    }\n\n    fun reloadStars() {\n        var totalStarsCount = 0\n        var totalScore = 0\n\n        for (lvl in 1..LEVELS_COUNT) {\n            val starsCount = Levels.levels[lvl]!!.shotsToStars(game.storage.getBestShot(lvl))\n\n            val score = game.storage.getBestScore(lvl)\n            println(\"level ${lvl} stars: ${starsCount} score: ${score}\")\n\n            starNodes[lvl].value = starsCount\n\n            totalStarsCount += starsCount\n            totalScore += score\n        }\n\n        totalStarsNode.value = totalStarsCount\n        totalScoreNode.value = totalScore\n\n        for (lvl in 1..LEVELS_COUNT) {\n            locked[lvl].value = totalStarsNode.value < lvlToStarsToUnlock(lvl)\n        }\n    }\n\n    fun show() {\n        reloadStars()\n        active = true\n    }\n\n}","package kmptemplate.games.billiard\n\ninterface Localization {\n    val game_name: String\n    val game_over: String\n    val try_again: String\n\n    val goto_menu: String\n\n    val gameover_SAVE_THE_BALL_for_ads: String\n    val gameover_save_the_ball_FOR_ADS: String\n\n    val you_win: String\n    val next_level: String\n    val play_again: String\n\n    fun top_bar_level(level: Int): String\n    fun shots_count(count: Int): String\n\n    val without_aim: String\n    val WITH_AIM_for_ads: String\n    val with_aim_FOR_ADS: String\n\n    val beat_ball_should_not_get_in_pocket: String\n\n    fun to_unlock(stars: Int): String\n    val not_enough_stars_OK: String\n\n    fun score(s: Int): String\n}\n\nclass Ru : Localization {\n    override val game_name = \" \"\n    override val game_over = \"\"\n    override val try_again = \" \"\n    override val goto_menu = \"  \"\n    override val gameover_SAVE_THE_BALL_for_ads = \" \"\n    override val gameover_save_the_ball_FOR_ADS = \"( )\"\n    override val you_win = \" !\"\n    override val next_level = \" \"\n    override val play_again = \"  \"\n    override fun top_bar_level(level: Int) = \": ${level}\"\n\n    override fun shots_count(count: Int) = \": ${count}\"\n\n    override val without_aim = \" \"\n\n    override val WITH_AIM_for_ads = \" \"\n    override val with_aim_FOR_ADS = \"( )\"\n\n    override val beat_ball_should_not_get_in_pocket = \"      \"\n\n    override fun to_unlock(stars: Int) = \" ${stars}\"\n\n    override val not_enough_stars_OK = \"Ok\"\n\n    override fun score(s: Int) = \": ${s}\"\n}\n\nclass En : Localization {\n    override val game_name = \"Arcade Billiard\"\n    override val game_over = \"Game Over\"\n    override val try_again = \"Try again\"\n    override val goto_menu = \"Goto Menu\"\n    override val gameover_SAVE_THE_BALL_for_ads = \"Save the Ball\"\n    override val gameover_save_the_ball_FOR_ADS = \"(for Ads)\"\n    override val you_win = \"You Win!\"\n    override val next_level = \"Next Level\"\n    override val play_again = \"Play Again\"\n    override fun top_bar_level(level: Int) = \"Level: ${level}\"\n    override fun shots_count(count: Int) = \"Shots: ${count}\"\n    override val without_aim = \"Without Aim\"\n    override val WITH_AIM_for_ads = \"With Aim\"\n    override val with_aim_FOR_ADS = \"(for ads)\"\n    override val beat_ball_should_not_get_in_pocket = \"White ball should not fall into a pocket\"\n    override fun to_unlock(stars: Int) = \"Required ${stars}\"\n    override val not_enough_stars_OK = \"Ok\"\n    override fun score(s: Int) = \"Score: ${s}\"\n\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.sq\nimport kmptemplate.nodes.Node\nimport kmptemplate.nodes.node\nimport kmptemplate.ui.Widget\nimport kmptemplate.ui.column\nimport kmptemplate.ui.img\nimport kmptemplate.ui.padding\nimport kmptemplate.ui.row\nimport kmptemplate.ui.text\n\nclass NotEnoughStarsDialog(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var textIm: ImmediateMode\n\n    private lateinit var widget: Widget\n\n    private var level = Node(0)\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        textIm = ImmediateMode(gloo)\n\n        val bgCol = Color(COLOR_WHITE)\n        val fontCol = Color(COLOR_BLACK)\n\n\n        widget = column {\n            drawBg = true\n            bgColor.value = bgCol\n\n            padding(0.25f) {\n                padding(0.25f) {\n\n                    column {\n\n                        row {\n\n                            text(node(level) { game.loc.to_unlock(lvlToStarsToUnlock(level.value)) }, fontSize = 2f, font = game.resources.font) {\n                                color.value = fontCol\n                            }\n                            img(game.resources.starTexture, 2f, 2f)\n                        }\n                    }\n\n\n                    onMouseDown = {\n                    }\n                    onTouchDown = onMouseDown\n                }\n            }\n\n            padding(0.25f) {\n                padding(0.25f) {\n                    drawBg = true\n\n                    text(game.loc.not_enough_stars_OK, fontSize = 2f, font = game.resources.font) {\n                        color.value = fontCol\n                    }\n\n                    onMouseDown = {\n                        close()\n                    }\n                    onTouchDown = onMouseDown\n                }\n            }\n        }\n    }\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        if (inputActive) {\n            input.forEvents { event ->\n                widget.handleEvent(event, game.uiCam)\n            }\n        }\n\n        widget.measureSelf()\n        widget.layoutChilds()\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        widget.render(textIm, game.uiCam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n\n    fun show(lvl: Int) {\n        level.value = lvl\n        active = true\n        game.menu.inputActive = false\n    }\n\n    fun close() {\n        active = false\n        game.menu.inputActive = true\n    }\n}\n\nfun lvlToStarsToUnlock(lvl: Int): Int {\n    if (lvl == 1) return 0\n    if (lvl == 2) return 1\n\n    return (1.75f * (lvl - 1) + 10.0 * sq(lvl.toFloat() / LevelsMenu.LEVELS_COUNT)).toInt()\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.Color\n\nobject Palette {\n    val YELLOW1 = Color(0.98f, 0.67f, 0.27f, 1.0f)\n    val YELLOW2 = Color(0.99f, 0.82f, 0.23f, 1.0f)\n\n    val CYAN1 = Color(0.19f, 0.81f, 0.81f, 1.0f)\n    val CYAN2 = Color(0.25f, 0.92f, 0.96f, 1.0f)\n\n    val YELLOW_TRANSPARENT = Color(1f, 1f, 0f, -1.0f)\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.math.Vec3\n\nclass Pocket(x: Float, y: Float) {\n\n    private lateinit var gloo: GLOO\n    lateinit var im: ImmediateMode\n    val pos = Vec3(x, y, 0f)\n    val R = 2f * Ball.R\n\n//    override fun init(gloo: GLOO) {\n//        this.gloo = gloo\n//        im = ImmediateMode(gloo)\n//    }\n//\n//    override fun update(dt: Double, t: Double, input: Keyboard) {\n//        for (ball in game.balls) {\n//            if (distSq(ball.pos, this.pos) < sq(R)) {\n//                ball.active = false\n//            }\n//        }\n//    }\n\n\n//    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n//        val color = COLOR_BLACK\n//\n//        val N = 16\n//        im.clear()\n//        for (i in 0 until N) {\n//            val a1 = i * F_2PI / N\n//            val a2 = (i + 1) * F_2PI / N\n//\n//            val s1 = sin(a1)\n//            val c1 = cos(a1)\n//\n//            val s2 = sin(a2)\n//            val c2 = cos(a2)\n//\n//            im.pos(pos.x, pos.y, pos.z)\n//            im.color(color)\n//\n//            im.pos(pos.x + R * c1, pos.y + R * s1, pos.z)\n//            im.color(color)\n//\n//            im.pos(pos.x + R * c2, pos.y + R * s2, pos.z)\n//            im.color(color)\n//        }\n//        im.gloo.gl.disable(GL_DEPTH_TEST)\n//        im.renderColoredTriangles(game.cam)\n//        im.gloo.gl.enable(GL_DEPTH_TEST)\n//\n//        frame++\n//    }\n\n}\n","package kmptemplate.games.billiard\n\nimport kmptemplate.asteroids.hasHardwareKeyboard\nimport kmptemplate.asteroids.platformName\nimport kmptemplate.color.COLOR_YELLOW\nimport kmptemplate.entities.Entity\nimport kmptemplate.games.billiard.Palette.YELLOW_TRANSPARENT\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL.Companion.GL_DEPTH_TEST\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.primitives.Sphere\nimport kmptemplate.gloo.primitives.intersect\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Quaternion\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.dist\nimport kmptemplate.math.dot\nimport kmptemplate.math.isNaN\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.math.sq\nimport kmptemplate.pool.VecPool\nimport kmptemplate.ui.UiEvent\nimport kotlin.math.sqrt\n\nclass Sling(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    lateinit var im: ImmediateMode\n\n    var started: Boolean = false\n\n    val pos = Vec3()\n\n    private val ballPhysics = BallPhysics()\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n    }\n\n    private val perp = Vec3()\n\n    fun inside(x: Float, y: Float): Boolean {\n        return true\n    }\n\n    private val MAX_SLING_LENGTH = 10.0f * Ball.R\n    private val DIST_TO_MAGNITUDE_COEF = 3.0f\n\n    private val tmpAdjustedPos = Vec3()\n\n    private val tmpSphere = Sphere()\n\n    private val TOUCH_BALL_R = 2.0f * Ball.R\n\n    private val ballIntersection = Vec3()\n    private val planeIntersection = Vec3()\n\n    private var drawAim = false\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        val (mx, my) = input.mouseCoords()\n\n        val allBallsStopped = game.allBalls.all { !it.active || it.vel.norm() < 0.0001f }\n\n        //we only can shot when all balls are stopped\n        if (allBallsStopped) {\n            input.forEvents { event ->\n                if (event.type == UiEvent.MOUSE_DOWN && event.button == UiEvent.MOUSE_BUTTON_LEFT) {\n                    val ray = VecPool.obtainRay()\n\n                    game.cam.rayThrough(ray, mx.toFloat(), my.toFloat())\n\n                    tmpSphere.r = TOUCH_BALL_R\n                    tmpSphere.pos.set(game.beatBall.pos)\n                    ballIntersection.intersect(ray, tmpSphere)\n                    if (ballIntersection.isNaN()) {\n                        game.beatBall.startBlink()\n                        println(\"blinking mouse\")\n                    }\n                    if (ballIntersection.isNotNaN()) {\n                        println(\"ball mousedown\")\n                        started = true\n                    }\n                }\n            }\n\n            input.forEvents { event ->\n                if (event.type == UiEvent.TOUCH_DOWN) {\n                    val ray = VecPool.obtainRay()\n\n                    game.cam.rayThrough(ray, event.x, event.y)\n\n                    tmpSphere.r = TOUCH_BALL_R\n                    tmpSphere.pos.set(game.beatBall.pos)\n                    ballIntersection.intersect(ray, tmpSphere)\n\n                    if (ballIntersection.isNaN()) {\n                        game.beatBall.startBlink()\n                        println(\"blinking touch\")\n                    }\n\n                    if (ballIntersection.isNotNaN()) {\n                        println(\"ball TOUCH_DOWN\")\n                        started = true\n                    }\n                }\n\n                if (event.type == UiEvent.POINTER_MOVE || event.type == UiEvent.TOUCH_DOWN) {\n                    val ray = VecPool.obtainRay()\n                    game.cam.rayThrough(ray, event.x, event.y)\n\n                    planeIntersection.intersect(ray, game.table.plane)\n                    if (planeIntersection.isNotNaN()) {\n                        pos.set(planeIntersection)\n\n                        if (dist(pos, game.beatBall.pos) > MAX_SLING_LENGTH) {\n                            tmpAdjustedPos.setDiff(pos, game.beatBall.pos)\n                            tmpAdjustedPos.normalize()\n                            tmpAdjustedPos *= MAX_SLING_LENGTH\n                            tmpAdjustedPos += game.beatBall.pos\n\n                            pos.set(tmpAdjustedPos)\n                        }\n                    }\n                }\n            }\n\n            if (started) {\n                val ray = VecPool.obtainRay()\n                game.cam.rayThrough(ray, mx.toFloat(), my.toFloat())\n\n                if (hasHardwareKeyboard()) {\n                    planeIntersection.intersect(ray, game.table.plane)\n                    if (planeIntersection.isNotNaN()) {\n                        pos.set(planeIntersection)\n\n\n                        if (dist(pos, game.beatBall.pos) > MAX_SLING_LENGTH) {\n                            val adjustedPos = VecPool.obtainVec3()\n                            adjustedPos.setDiff(pos, game.beatBall.pos)\n                            adjustedPos.normalize()\n                            adjustedPos *= MAX_SLING_LENGTH\n                            adjustedPos += game.beatBall.pos\n\n                            pos.set(adjustedPos)\n                        }\n                    }\n                }\n\n                //find nearest collision ball\n                var nearestCollisionBall: Ball? = null\n                var minBallDistSoFar = 100500.0f\n                var nearestS = 0.0f\n\n                for (anotherBall in game.freeBalls) {\n                    if (anotherBall.active) {\n\n                        ray.origin.set(game.beatBall.pos)\n                        ray.dir.setDiff(game.beatBall.pos, pos)\n\n                        val p1 = game.beatBall.pos\n                        val p2 = anotherBall.pos\n                        val p2_p1 = VecPool.obtainVec3()\n                        p2_p1.setDiff(p2, p1)\n\n                        val r1 = Ball.R\n                        val r2 = Ball.R\n\n                        val a = ray.dir.normSq()\n                        val b = -dot(ray.dir, p2_p1)\n                        val c = -sq(r1) - sq(r2) - 2f * r1 * r2 + p2_p1.normSq()\n\n                        val d4 = sq(b) - a * c\n                        if (d4 > 0f) {\n                            val s = (-b - sqrt(d4)) / a\n                            if (s < 0.0) continue //         (..   )\n\n                            val d = s * ray.dir.norm()\n                            if (d < minBallDistSoFar) {\n                                minBallDistSoFar = d\n                                nearestCollisionBall = anotherBall\n                                nearestS = s\n                            }\n\n                            val pos1 = VecPool.obtainVec3(game.beatBall.pos) //    \n                            pos1.addMult(s, ray.dir)\n\n                            val pos2 = anotherBall.pos\n\n\n                            val v1 = VecPool.obtainVec3(ray.dir) //        (  , .)\n                            v1.normalize()\n\n                            val v2 = VecPool.obtainVec3(0f, 0f, 0f) // another ball is stable before collision\n\n                            ballPhysics.calc(v1, v2, pos1, pos2)\n                        }\n\n                    }\n                }\n\n                if (nearestCollisionBall != null) {\n\n                    val pos1 = VecPool.obtainVec3(game.beatBall.pos) //    \n                    pos1.addMult(nearestS, ray.dir)\n\n                    val pos2 = nearestCollisionBall.pos\n\n\n                    val v1 = VecPool.obtainVec3(ray.dir) //        (  , .)\n                    v1.normalize()\n\n                    val v2 = VecPool.obtainVec3(0f, 0f, 0f) // another ball is stable before collision\n\n                    ballPhysics.calc(v1, v2, pos1, pos2)\n                    drawAim = true\n                } else {\n                    drawAim = false\n                }\n            }\n\n            input.forEvents { event ->\n                val launchedWithTouch = event.type == UiEvent.TOUCH_UP\n                val launchedWithMouse = event.type == UiEvent.MOUSE_UP && event.button == UiEvent.MOUSE_BUTTON_LEFT\n\n                if (launchedWithTouch || launchedWithMouse) {\n                    if (started) {\n                        println(\"launchBeatBall 2 launchedWithTouch: ${launchedWithTouch} launchedWithMouse:${launchedWithMouse}\")\n                        launchBeatBall()\n                    }\n                }\n            }\n        }\n    }\n\n    private fun launchBeatBall() {\n        game.storage.setTutorialFinished(true)\n        game.tutorial.active = false\n\n        savePreviousState()\n\n        //early stop without shot\n        val distToBall = dist(game.beatBall.pos, pos)\n        if (distToBall < Ball.R) {\n            started = false\n            return\n        }\n\n        game.table.shots.value++\n        game.analytics.shot(game.table.level.value, game.table.shots.value)\n        game.soundManager.play(game.resources.ballCueSound)\n\n        val magnitude = distToBall * DIST_TO_MAGNITUDE_COEF\n\n        game.beatBall.vel.setDiff(game.beatBall.pos, pos)\n\n        val eps = 0.00001f\n        if (game.beatBall.vel.normSq() > eps) {\n            game.beatBall.vel.normalize()\n            game.beatBall.vel *= magnitude\n        } else {\n            game.beatBall.vel.setZero()\n        }\n\n        started = false\n    }\n\n    private var savedShots = 0\n    private val savedBallOriention = Array(BilliardGame.TOTAL_BALLS_COUNT) { Quaternion(1f, 0f, 0f, 1f) }\n    private val savedBallVel = Array(BilliardGame.TOTAL_BALLS_COUNT) { Vec3() }\n    private val savedBallPos = Array(BilliardGame.TOTAL_BALLS_COUNT) { Vec3() }\n    private val savedBallActive = Array(BilliardGame.TOTAL_BALLS_COUNT) { false }\n\n    private fun savePreviousState() {\n        for ((i, ball) in game.allBalls.withIndex()) {\n            savedBallOriention[i].set(ball.orientation)\n            savedBallVel[i].set(ball.vel)\n            savedBallPos[i].set(ball.pos)\n            savedBallActive[i] = ball.active\n        }\n        savedShots = game.table.shots.value\n    }\n\n    fun restorePrevState() {\n        for ((i, ball) in game.allBalls.withIndex()) {\n            ball.orientation.set(savedBallOriention[i])\n            ball.vel.set(savedBallVel[i])\n            ball.pos.set(savedBallPos[i])\n            ball.active = savedBallActive[i]\n        }\n        game.table.shots.value = savedShots\n    }\n\n\n    val tmpPos = Vec3()\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        im.clear()\n\n        if (started || game.tutorial.active) {\n            val ballPos = game.beatBall.pos\n            val r = Ball.R * 0.75f\n\n            perp.setDiff(ballPos, pos)\n            perp.normalize()\n            perp.set(perp.y, -perp.x, perp.z) //perpendicular direction\n\n            im.pos(ballPos.x - r * perp.x, ballPos.y - r * perp.y, ballPos.z)\n            im.color(COLOR_YELLOW)\n\n            tmpPos.setDiff(pos, ballPos)\n            tmpPos.add(pos)\n\n            im.pos(tmpPos)\n            im.color(YELLOW_TRANSPARENT)\n\n            im.pos(ballPos.x + r * perp.x, ballPos.y + r * perp.y, ballPos.z)\n            im.color(COLOR_YELLOW)\n\n            gloo.gl.disable(GL_DEPTH_TEST)\n            im.renderColoredTriangles(game.cam)\n\n\n            if (game.table.withAim) {\n                im.clear()\n                im.line(\n                    ballPos.x, ballPos.y, ballPos.z,\n                    ballPos.x + (ballPos.x - pos.x),\n                    ballPos.y + (ballPos.y - pos.y), ballPos.z\n                )\n\n                if (drawAim) {\n                    im.line(\n                        ballPhysics.p2.x,\n                        ballPhysics.p2.y,\n                        ballPhysics.p2.z,\n\n                        ballPhysics.p2.x + ballPhysics.v2_.x * 7f,\n                        ballPhysics.p2.y + ballPhysics.v2_.y * 7f,\n                        ballPos.z\n                    )\n                }\n                im.renderColoredLines(game.cam)\n            }\n\n            gloo.gl.enable(GL_DEPTH_TEST)\n        }\n    }\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.immediate.TexturedShader\nimport kmptemplate.gloo.primitives.Plane\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.F_2PI\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.distSq\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.math.setNaN\nimport kmptemplate.math.sq\nimport kmptemplate.nodes.Node\nimport kmptemplate.svg.svgPath\nimport kmptemplate.triangulator.KFloatArray\nimport kmptemplate.triangulator.Triangulator\nimport kotlinx.coroutines.launch\nimport kotlin.math.cos\nimport kotlin.math.sin\n\n\nclass Wall(x1: Float, y1: Float, x2: Float, y2: Float) {\n    val p1 = Vec3(x1, y1, Ball.R) // z should be ball radius\n    val p2 = Vec3(x2, y2, Ball.R) // z should be ball radius\n}\n\n\nclass Trigger(val cond: () -> Boolean) {\n    private var prevConditionMet = false\n    private var conditionMet = false\n\n    fun check() {\n        prevConditionMet = conditionMet\n        conditionMet = cond()\n    }\n\n    fun justTriggered() = conditionMet && !prevConditionMet\n}\n\nclass Table(val game: BilliardGame) : Entity(parent = game) {\n\n    lateinit var im: ImmediateMode\n    lateinit var tableIm: ImmediateMode\n    lateinit var woodIm: ImmediateMode\n\n    val ext = 1f\n    val left = game.left + ext\n    val right = game.right - ext\n    val bottom = game.bottom + ext\n    val top = game.top - ext\n\n    val walls = mutableListOf(\n        Wall(left, bottom, right, bottom),\n        Wall(right, bottom, right, top),\n        Wall(right, top, left, top),\n        Wall(left, top, left, bottom)\n    )\n\n    val pockets = mutableListOf<Pocket>()\n\n    lateinit var shader: TexturedShader\n\n    override fun init(gloo: GLOO) {\n        im = ImmediateMode(gloo)\n        tableIm = ImmediateMode(gloo)\n        woodIm = ImmediateMode(gloo)\n\n        shader = TexturedShader(gloo)\n    }\n\n    /**\n     * Plane on the level of ball centers\n     */\n    val plane = Plane(Vec3(0f, 0f, Ball.R), Vec3(1f, 0f, 0f), Vec3(0f, 1f, 0f))\n\n    var shots = Node(0)\n    var level = Node(0)\n    var withAim = false\n\n    val win = Trigger { game.beatBall.active && game.freeBalls.all { !it.active && game.beatBall.vel.norm() < 0.0001f } }\n    val gameOver = Trigger { !game.beatBall.active } //actually the same as beat in pocket, but can be different (for example after 3 beats in pocket)\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        for (pocket in pockets) {\n            for (ball in game.allBalls) {\n                if (ball.active && distSq(ball.pos, pocket.pos) < sq(pocket.R)) {\n\n                    ball.active = false\n\n                    game.soundManager.play(game.resources.ballInPocketSound)\n\n                    if (ball == game.beatBall) {\n                        game.analytics.logBeatInPocket(level.value, shots.value)\n                    } else {\n                        game.analytics.logBallInPocket(level.value, shots.value)\n                    }\n                }\n            }\n        }\n\n        win.check()\n        gameOver.check()\n\n        if (win.justTriggered()) {\n            println(\"Epic Win!\")\n            game.analytics.logLevelComplete(level.value, shots.value)\n            game.storage.addResult(level.value, shots.value)\n\n            var score = Levels.levels[level.value]!!.shotsToScore(shots.value)\n            if (!withAim) {\n                score *= 2\n            }\n\n            game.storage.addScore(level.value, score)\n            game.winScreen.show(level.value, shots.value, score)\n\n            var totalScore = 0L\n            for (i in 1..Levels.LEVELS_COUNT) {\n                totalScore += game.storage.getBestScore(i)\n            }\n\n            game.scope.launch {\n                try {\n                    if (game.leaderBoard.isAvailable()) {\n                        game.leaderBoard.setScore(totalScore)\n                        println(\"total score: ${totalScore}\")\n                    } else {\n                        println(\"leaderboard is not available\")\n                    }\n                } catch (t: Throwable) {\n                    t.printStackTrace()\n                }\n            }\n        }\n\n        if (gameOver.justTriggered()) {\n            println(\"Game Over!\")\n\n            game.analytics.logGameOver(level.value, shots.value)\n            game.gotoGameOver()\n            game.soundManager.play(game.resources.gameOverSound)\n        }\n\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        im.disableDepthTest()\n\n        tableIm.prepareBuffers()\n        tableIm.tableShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(game.cam.projMatrix)\n            uView.set(game.cam.viewMatrix)\n\n            uTexture.set(game.resources.clothTexture)\n            aTexCoord.set(tableIm.texCoordsBuf)\n            aPos.set(tableIm.linePosBuf)\n            aColor.set(tableIm.lineColorBuf)\n\n            tableIm.gloo.gl.drawArrays(GL.GL_TRIANGLES, 0, tableIm.posFB.length() / 3)\n        }\n\n        woodIm.prepareBuffers()\n        woodIm.tableShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(game.cam.projMatrix)\n            uView.set(game.cam.viewMatrix)\n\n            uTexture.set(game.resources.woodTexture)\n            aTexCoord.set(woodIm.texCoordsBuf)\n            aPos.set(woodIm.linePosBuf)\n            aColor.set(woodIm.lineColorBuf)\n\n            woodIm.gloo.gl.drawArrays(GL.GL_TRIANGLES, 0, woodIm.posFB.length() / 3)\n        }\n\n\n        im.clear()\n        im.color.set(1f, 1f, 1f, 0.4f)\n        for (wall in walls) {\n            im.line(wall.p1, wall.p2)\n        }\n        im.renderColoredLines(game.cam)\n\n\n        val color = COLOR_WHITE\n        val N = 16\n        im.clear()\n        val R = Ball.R * 1f\n        for (pocket in pockets) {\n            for (i in 0 until N) {\n                val a1 = i * F_2PI / N\n                val a2 = (i + 1) * F_2PI / N\n\n                val s1 = sin(a1)\n                val c1 = cos(a1)\n\n                val s2 = sin(a2)\n                val c2 = cos(a2)\n\n                im.pos(pocket.pos.x, pocket.pos.y, pocket.pos.z)\n                im.color(color)\n                im.texCoord(0.5f, 0.5f)\n\n                im.pos(pocket.pos.x + R * c1, pocket.pos.y + R * s1, pocket.pos.z)\n                im.color(color)\n                im.texCoord(0.5f + 0.5f * c1, 0.5f + 0.5f * s1)\n\n\n                im.pos(pocket.pos.x + R * c2, pocket.pos.y + R * s2, pocket.pos.z)\n                im.color(color)\n                im.texCoord(0.5f + 0.5f * c2, 0.5f + 0.5f * s2)\n            }\n        }\n        im.prepareBuffers()\n        im.tableShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(game.cam.projMatrix)\n            uView.set(game.cam.viewMatrix)\n\n            uTexture.set(game.resources.pocketTexture)\n            aTexCoord.set(im.texCoordsBuf)\n            aPos.set(im.linePosBuf)\n            aColor.set(im.lineColorBuf)\n\n            im.gloo.gl.drawArrays(GL.GL_TRIANGLES, 0, im.posFB.length() / 3)\n        }\n\n        im.enableDepthTest()\n    }\n\n\n    fun reset() {\n        shots.value = 0\n        game.gameOver.active = false\n        walls.clear()\n        pockets.clear()\n        for (ball in game.allBalls) {\n            ball.vel.setZero()\n            ball.active = false\n        }\n    }\n\n    fun setTable(level: Int) {\n        this.level.value = level\n\n        Levels.levels[level]!!.setup(this)\n    }\n\n    fun textureTable() {\n\n        val verts = FloatArray(walls.size * 2)\n        for ((i, wall) in walls.withIndex()) {\n            verts[i * 2] = wall.p1.x\n            verts[i * 2 + 1] = wall.p1.y\n        }\n\n        val trng = Triangulator()\n        val indices = trng.computeTriangles(verts)\n\n        tableIm.clear()\n\n//        for (triangle in 0 until indices.size / 3) {\n//            println(\"${indices[3 * triangle]} ${indices[3 * triangle + 1]} ${indices[3 * triangle + 2]}\")\n//        }\n//        println(\"indices.size = ${indices.size}\")\n//        println(\"verts.size = ${verts.size}\")\n\n        val tableColor = Color(0.09f, 0.5f, 0.2f, 1.0f)\n        for (t in 0 until indices.size / 3) {\n\n            //triangulator returns indices of triangles in clockwise order\n            // so we switched the indices to (3t+0,3t+2,3t+1) order to fix the order to counter clockwise:\n            val idx1 = indices[3 * t]\n            val idx2 = indices[3 * t + 2]\n            val idx3 = indices[3 * t + 1]\n\n            tableIm.pos(verts[2 * idx1 + 0], verts[2 * idx1 + 1], 0.0f)\n            tableIm.pos(verts[2 * idx2 + 0], verts[2 * idx2 + 1], 0.0f)\n            tableIm.pos(verts[2 * idx3 + 0], verts[2 * idx3 + 1], 0.0f)\n\n            val scale = 1f / 8f\n            tableIm.texCoord(scale * verts[2 * idx1 + 0], scale * verts[2 * idx1 + 1])\n            tableIm.texCoord(scale * verts[2 * idx2 + 0], scale * verts[2 * idx2 + 1])\n            tableIm.texCoord(scale * verts[2 * idx3 + 0], scale * verts[2 * idx3 + 1])\n\n            tableIm.color(tableColor)\n            tableIm.color(tableColor)\n            tableIm.color(tableColor)\n        }\n    }\n\n    fun textureWood(clear: Boolean = true) {\n\n        val trng = Triangulator()\n        val verts = woodKFar\n        val indices = trng.computeTriangles(verts)\n\n        if (clear) {\n            woodIm.clear()\n        }\n\n//        for (triangle in 0 until indices.size / 3) {\n//            println(\"${indices[3 * triangle]} ${indices[3 * triangle + 1]} ${indices[3 * triangle + 2]}\")\n//        }\n//        println(\"indices.size = ${indices.size}\")\n//        println(\"verts.size = ${verts.size}\")\n\n        val woodColorMult = Color(1f, 1f, 1f, 1f)\n        for (t in 0 until indices.size / 3) {\n\n            //triangulator returns indices of triangles in clockwise order\n            // so we switched the indices to (3t+0,3t+2,3t+1) order to fix the order to counter clockwise:\n            val idx1 = indices[3 * t]\n            val idx2 = indices[3 * t + 2]\n            val idx3 = indices[3 * t + 1]\n\n            woodIm.pos(verts[2 * idx1 + 0], verts[2 * idx1 + 1], 0.0f)\n            woodIm.pos(verts[2 * idx2 + 0], verts[2 * idx2 + 1], 0.0f)\n            woodIm.pos(verts[2 * idx3 + 0], verts[2 * idx3 + 1], 0.0f)\n\n            val scale = 1f / 8f\n            woodIm.texCoord(scale * verts[2 * idx1 + 0], scale * verts[2 * idx1 + 1])\n            woodIm.texCoord(scale * verts[2 * idx2 + 0], scale * verts[2 * idx2 + 1])\n            woodIm.texCoord(scale * verts[2 * idx3 + 0], scale * verts[2 * idx3 + 1])\n\n            woodIm.color(woodColorMult)\n            woodIm.color(woodColorMult)\n            woodIm.color(woodColorMult)\n        }\n    }\n\n    fun setTable0() {\n        reset()\n\n        startContour()\n        wallTo(-8f, -8f)\n        wallTo(+8f, -8f)\n        wallTo(0f, 0f)\n        wallTo(+8f, +8f)\n        wallTo(-8f, +8f)\n        wallTo(-8f, -8f)\n\n        textureTable()\n\n        ball(0, -6f, 0f)\n        ball(1, -4f, 0f)\n\n        pocket(-2f, 0f)\n    }\n\n    fun setTable1() {\n        reset()\n\n        startContour()\n        svgWalls(\"m 12,-8.5 h -2 l -1,1 H 1 v -1 h -2 v 1 h -8 l -1,-1 h -2 v 2 l 1,1 v 11 l -1,1 v 2 h 2 l 1,-1 h 8 v 1 h 2 v -1 h 8 l 1,1 h 2 v -2 l -1,-1 v -11 l 1,-1 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 l -1,1 v 11 l 1,1 v 2 H 10 L 9,7.5 H 1 v 1 h -2 v -1 h -8 l -1,1 h -2 v -2 l 1,-1 v -11 l -1,-1 v -2 h 2 l 1,1 h 8 v -1 h 2 v 1 h 8 l 1,-1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"M -6,0 H 4 L 5.5,-1 V 1 L 7,-2 v 2 2\")\n\n        svgPockets(\"m -11,-7.5 11,-1 11,1 v 15 l -11,1 -11,-1\")\n    }\n\n    fun setTable2() {\n        reset()\n\n        startContour()\n        svgWalls(\"m 12,-8.5 h -2 l -1,1 H -8 l -1,1 -1,-1 v -1 h -2 v 2 l 1,1 v 10 l 1,1 -1,1 h -1 v 2 h 2 l 1,-1 H 8 l 1,-1 1,1 v 1 h 2 v -2 l -1,-1 v -10 l -1,-1 1,-1 h 1 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 h -1 l -1,1 1,1 v 10 l 1,1 v 2 h -2 v -1 l -1,-1 -1,1 H -9 l -1,1 h -2 v -2 h 1 l 1,-1 -1,-1 v -10 l -1,-1 v -2 h 2 v 1 l 1,1 1,-1 H 9 l 1,-1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"m 0,0 -9,-5.5 v 11 h 3 15 v -11 H 6\")\n\n        svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n    }\n\n    fun setTable3() {\n        reset()\n\n        startContour()\n        svgWalls(\"M 12,-8.5 H 5 v 4 H -5 v -4 h -7 v 6 h 5 v 5 h -5 v 6 h 7 v -4 H 5 v 4 h 7 v -6 H 7 v -5 h 5 z\")\n        textureTable()\n\n        svgWood(\"M 13,-9.5 H 4 v 4 h -8 v -4 h -9 v 8 h 5 v 3 h -5 v 8 h 9 v -4 h 8 v 4 h 9 v -8 H 8 v -3 h 5 v -8 l -1,1 v 6 H 7 v 5 h 5 v 6 H 5 v -4 H -5 v 4 h -7 v -6 h 5 v -5 h -5 v -6 h 7 v 4 H 5 v -4 h 7 z\")\n        textureWood()\n\n        svgBalls(\"m 0,0 -11,-3.5 h 5 12 l -12,7 h 12 5\")\n\n        svgPockets(\"m -6,-7.5 17,4 -5,11 -17,-4\")\n    }\n\n    fun setTable4() {\n        reset()\n\n        startContour()\n        svgWalls(\"m 12,-8.5 h -2 l -1,1 H 5 l -5,5 -5,-5 h -4 l -1,-1 h -2 v 2 l 1,1 v 11 l -1,1 v 2 h 2 l 1,-1 h 4 l 5,-5 5,5 h 4 l 1,1 h 2 v -2 l -1,-1 v -11 l 1,-1 z\")\n        textureTable()\n\n        svgWood(\"M 13,-9.5 H 4 l -4,4 -4,-4 h -9 v 19 h 9 l 4,-4 4,4 h 9 v -19 l -1,1 v 2 l -1,1 v 11 l 1,1 v 2 H 10 L 9,7.5 H 5 l -5,-5 -5,5 h -4 l -1,1 h -2 v -2 l 1,-1 v -11 l -1,-1 v -2 h 2 l 1,1 h 4 l 5,5 5,-5 h 4 l 1,-1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"m 1,0 2,-2.5 v 5 l -8,-7 v 9 l 2,-7 v 5 L -1,0\")\n        svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n    }\n\n    fun setTable5() {\n        reset()\n\n        startContour()\n        svgWalls(\"m 0,-6 -2,-2 -6,6 V 2 L -2,8 0,6 2,8 8,2 V -2 L 2,-8 Z\")\n        textureTable()\n\n        svgWood(\"m 2,-10 -2,2 -2,-2 -8,8 v 4 l 8,8 2,-2 2,2 8,-8 v -4 l -8,-8 v 2 l 6,6 V 2 L 2,8 0,6 -2,8 -8,2 v -4 l 6,-6 2,2 2,-2 z\")\n        textureWood()\n\n        svgBalls(\"M 0,-3 2,-6.5 -2,6.5 -5,0 H 5 l -9,-4 8,8\")\n        svgPockets(\"M -2,-6.5 2,6.5 8,0 H -8\")\n    }\n\n    fun setTable6() {\n        reset()\n\n        startContour()\n        wallTo(-8f, 7.5f)\n        wallTo(-3f, 7.5f)\n        wallTo(-3f, 8.5f)\n        wallTo(3f, 8.5f)\n        wallTo(3f, 7.5f)\n        wallTo(8f, 7.5f)\n        wallTo(11f, 4.5f)\n        wallTo(11f, -4.5f)\n        wallTo(8f, -7.5f)\n        wallTo(4f, -7.5f)\n        wallTo(4f, -8.5f)\n        wallTo(-4f, -8.5f)\n        wallTo(-4f, -7.5f)\n        wallTo(-8f, -7.5f)\n        wallTo(-11f, -4.5f)\n        wallTo(-11f, 4.5f)\n        wallTo(-8f, 7.5f)\n\n        textureTable()\n\n        svgWood(\"m 9,-9.5 -1,2 3,3 v 9 l -3,3 H 4 v 1 h -8 v -1 h -4 l -3,-3 v -9 l 3,-3 h 5 v -1 h 6 v 1 h 5 l 1,-2 H -9 l -4,4 v 11 l 4,4 H 9 l 4,-4 v -11 z\")\n        textureWood()\n\n        ball(0, 0f, 1.5f)\n        ball(1, 0f, -5.5f)\n        ball(2, -3f, -5.5f)\n        ball(3, 3f, -5.5f)\n        ball(4, -2f, 5.5f)\n        ball(5, 2f, 5.5f)\n        ball(6, 0f, 3.5f)\n\n        pocket(-2f, 8.5f)\n        pocket(2f, 8.5f)\n        pocket(-3f, -8.5f)\n        pocket(0f, -8.5f)\n        pocket(3f, -8.5f)\n    }\n\n    fun setTable7() {\n        reset()\n\n        startContour()\n        wallTo(0f, 3.5f)\n        wallTo(4f, 7.5f)\n        wallTo(11f, 7.5f)\n        wallTo(11f, -1.5f)\n        wallTo(5f, -7.5f)\n        wallTo(-5f, -7.5f)\n        wallTo(-11f, -1.5f)\n        wallTo(-11f, 7.5f)\n        wallTo(-4f, 7.5f)\n        wallTo(0f, 3.5f)\n\n        textureTable()\n\n        svgWood(\"M 13,-9.5 H 4 l -4,4 -4,-4 h -9 v 12 l 7,7 H 6 l 7,-7 v -12 l -2,2 v 9 l -6,6 H -5 l -6,-6 v -9 h 7 l 4,4 4,-4 h 7 z\")\n        textureWood()\n\n        ball(0, 0f, 0.5f)\n        ball(1, -3f, 3.5f)\n        ball(2, 3f, 3.5f)\n        ball(3, -5f, 0.5f)\n        ball(4, 5f, 0.5f)\n        ball(5, -3f, -2.5f)\n        ball(6, 3f, -2.5f)\n        ball(7, 0f, -4.5f)\n\n        pocket(-7f, 3.5f)\n        pocket(7f, 3.5f)\n    }\n\n    fun setTable8() {\n        reset()\n\n        startContour()\n        wallTo(-4f, 7.5f)\n        wallTo(4f, 7.5f)\n        wallTo(5f, 8.5f)\n        wallTo(7f, 8.5f)\n        wallTo(7f, 6.5f)\n        wallTo(6f, 5.5f)\n        wallTo(6f, 2.5f)\n        wallTo(9f, 2.5f)\n        wallTo(10f, 3.5f)\n        wallTo(12f, 3.5f)\n        wallTo(12f, 1.5f)\n        wallTo(11f, 0.5f)\n        wallTo(11f, -0.5f)\n        wallTo(12f, -1.5f)\n        wallTo(12f, -3.5f)\n        wallTo(10f, -3.5f)\n        wallTo(9f, -2.5f)\n        wallTo(6f, -2.5f)\n        wallTo(6f, -5.5f)\n        wallTo(7f, -6.5f)\n        wallTo(7f, -8.5f)\n        wallTo(5f, -8.5f)\n        wallTo(4f, -7.5f)\n\n        wallTo(-4f, -7.5f)\n        wallTo(-5f, -8.5f)\n        wallTo(-7f, -8.5f)\n        wallTo(-7f, -6.5f)\n        wallTo(-6f, -5.5f)\n\n        wallTo(-6f, -2.5f)\n        wallTo(-9f, -2.5f)\n        wallTo(-10f, -3.5f)\n        wallTo(-12f, -3.5f)\n        wallTo(-12f, -1.5f)\n        wallTo(-11f, -0.5f)\n        wallTo(-11f, 0.5f)\n        wallTo(-12f, 1.5f)\n        wallTo(-12f, 3.5f)\n        wallTo(-10f, 3.5f)\n        wallTo(-9f, 2.5f)\n        wallTo(-6f, 2.5f)\n        wallTo(-6f, 5.5f)\n        wallTo(-7f, 6.5f)\n        wallTo(-7f, 8.5f)\n        wallTo(-5f, 8.5f)\n        wallTo(-4f, 7.5f)\n\n        textureTable()\n\n        svgWood(\"M 8,-9.5 H -8 v 5 h -5 v 9 h 5 v 5 H 8 v -5 h 5 v -9 H 8 v -5 l -1,1 v 2 l -1,1 v 3 h 3 l 1,-1 h 2 v 2 l -1,1 v 1 l 1,1 v 2 H 10 L 9,2.5 H 6 v 3 l 1,1 v 2 H 5 l -1,-1 h -8 l -1,1 h -2 v -2 l 1,-1 v -3 h -3 l -1,1 h -2 v -2 l 1,-1 v -1 l -1,-1 v -2 h 2 l 1,1 h 3 v -3 l -1,-1 v -2 h 2 l 1,1 h 8 l 1,-1 h 2 z\")\n        textureWood()\n\n        ball(0, 0f, 5.5f)\n        ball(1, -3f, 3.5f)\n        ball(2, 3f, 3.5f)\n        ball(3, -5f, 0.5f)\n        ball(4, 5f, 0.5f)\n        ball(5, -3f, -2.5f)\n        ball(6, 3f, -2.5f)\n        ball(7, 0f, -4.5f)\n\n        pocket(6f, 7.5f)\n        pocket(11f, 2.5f)\n        pocket(11f, -2.5f)\n        pocket(6f, -7.5f)\n        pocket(-6f, -7.5f)\n        pocket(-11f, -2.5f)\n        pocket(-11f, 2.5f)\n        pocket(-6f, 7.5f)\n    }\n\n    fun setTable9() {\n        reset()\n\n        startContour()\n        wallTo(-3f, 6.5f)\n        wallTo(3f, 6.5f)\n        wallTo(4f, 7.5f)\n        wallTo(10f, 7.5f)\n        wallTo(11f, 6.5f)\n        wallTo(11f, 2.5f)\n        wallTo(10f, 1.5f)\n        wallTo(10f, -1.5f)\n        wallTo(11f, -2.5f)\n        wallTo(11f, -6.5f)\n        wallTo(10f, -7.5f)\n        wallTo(4f, -7.5f)\n        wallTo(3f, -6.5f)\n        wallTo(-3f, -6.5f)\n        wallTo(-4f, -7.5f)\n        wallTo(-10f, -7.5f)\n        wallTo(-11f, -6.5f)\n        wallTo(-11f, -2.5f)\n        wallTo(-10f, -1.5f)\n        wallTo(-10f, 1.5f)\n        wallTo(-11f, 2.5f)\n        wallTo(-11f, 6.5f)\n        wallTo(-10f, 7.5f)\n        wallTo(-4f, 7.5f)\n        wallTo(-3f, 6.5f)\n\n        textureTable()\n\n        svgWood(\"M 11,-9.5 H 4 l -1,1 h -6 l -1,-1 h -7 l -2,2 v 5 l 1,1 v 3 l -1,1 v 5 l 2,2 h 7 l 1,-1 h 6 l 1,1 h 7 l 2,-2 v -5 l -1,-1 v -3 l 1,-1 v -5 l -2,-2 -1,2 1,1 v 4 l -1,1 v 3 l 1,1 v 4 l -1,1 H 4 l -1,-1 h -6 l -1,1 h -6 l -1,-1 v -4 l 1,-1 v -3 l -1,-1 v -4 l 1,-1 h 6 l 1,1 h 6 l 1,-1 h 6 z\")\n        textureWood()\n\n        svgWood(\"m 3,-3.5 h -6 l -2,2 v 3 l 2,2 h 6 l 2,-2 v -3 z\")\n        textureWood(clear = false)\n\n        ball(0, -9f, 5.5f)\n        ball(1, -9f, 1.5f)\n        ball(2, -7f, -1.5f)\n        ball(3, -9f, -4.5f)\n        ball(4, -2f, 4.5f)\n        ball(5, 1f, 5.5f)\n        ball(6, 4f, 4.5f)\n\n        pocket(-7f, -4.5f)\n        pocket(7f, 4.5f)\n\n\n        startContour()\n        wallTo(-3f, 3.5f)\n        wallTo(3f, 3.5f)\n        wallTo(5f, 1.5f)\n        wallTo(5f, -1.5f)\n        wallTo(3f, -3.5f)\n        wallTo(-3f, -3.5f)\n        wallTo(-5f, -1.5f)\n        wallTo(-5f, 1.5f)\n        wallTo(-3f, 3.5f)\n    }\n\n    fun setTable10() {\n        reset()\n\n        startContour()\n        wallTo(-3f, 7.5f)\n        wallTo(9f, 7.5f)\n        wallTo(10f, 8.5f)\n        wallTo(12f, 8.5f)\n        wallTo(12f, 6.5f)\n        wallTo(11f, 5.5f)\n        wallTo(11f, -0.5f)\n        wallTo(12f, -1.5f)\n        wallTo(12f, -3.5f)\n        wallTo(10f, -3.5f)\n        wallTo(9f, -2.5f)\n        wallTo(5f, -2.5f)\n        wallTo(5f, -5.5f)\n        wallTo(6f, -6.5f)\n        wallTo(6f, -8.5f)\n        wallTo(4f, -8.5f)\n        wallTo(3f, -7.5f)\n        wallTo(-9f, -7.5f)\n        wallTo(-10f, -8.5f)\n        wallTo(-12f, -8.5f)\n        wallTo(-12f, -6.5f)\n        wallTo(-11f, -5.5f)\n        wallTo(-11f, 0.5f)\n        wallTo(-12f, 1.5f)\n        wallTo(-12f, 3.5f)\n        wallTo(-10f, 3.5f)\n        wallTo(-9f, 2.5f)\n        wallTo(-5f, 2.5f)\n        wallTo(-5f, 5.5f)\n        wallTo(-6f, 6.5f)\n        wallTo(-6f, 8.5f)\n        wallTo(-4f, 8.5f)\n        wallTo(-3f, 7.5f)\n\n        textureTable()\n\n        svgWood(\"M 13,-9.5 H -7 v 5 h -6 v 14 H 7 v -5 h 6 v -14 l -1,1 v 2 l -1,1 v 6 l 1,1 v 2 H 10 L 9,2.5 H 5 v 3 l 1,1 v 2 H 4 L 3,7.5 H -9 l -1,1 h -2 v -2 l 1,-1 v -6 l -1,-1 v -2 h 2 l 1,1 h 4 v -3 l -1,-1 v -2 h 2 l 1,1 H 9 l 1,-1 h 2 z\")\n        textureWood()\n\n        ball(0, 0f, 0.0f)\n        ball(1, -3f, 4.5f)\n        ball(2, 8f, 4.5f)\n        ball(3, 8f, -1.5f)\n        ball(4, 3f, -4.5f)\n        ball(5, -8f, -4.5f)\n        ball(6, -8f, 1.5f)\n\n        pocket(-5f, 7.5f)\n        pocket(11f, 7.5f)\n        pocket(11f, -2.5f)\n        pocket(5f, -7.5f)\n        pocket(-11f, -7.5f)\n        pocket(-11f, 2.5f)\n        pocket(-5f, 7.5f)\n    }\n\n    fun setTable11() {\n        reset()\n\n        startContour()\n        svgWalls(\"M 12,-8 H 4 l -3,3 v 1 h -2 v -1 l -3,-3 h -8 v 3 l 4,4 h 1 v 2 h -1 l -4,4 v 3 h 8 L -1,5 V 4 h 2 v 1 l 3,3 h 8 V 5 L 8,1 H 7 v -2 h 1 l 4,-4 z\")\n        textureTable()\n\n        svgWood(\"M 13,-9 H 2 l -2,2 -2,-2 h -11 v 6 l 3,3 -3,3 V 9 H -2 L 0,7 2,9 H 13 V 3 l -3,-3 3,-3 v -6 l -1,1 v 3 L 8,-1 H 7 v 2 h 1 l 4,4 V 8 H 4 L 1,5 V 4 h -2 v 1 l -3,3 h -8 V 5 l 4,-4 h 1 v -2 h -1 l -4,-4 v -3 h 8 l 3,3 v 1 h 2 v -1 l 3,-3 h 8 z\")\n        textureWood()\n\n        ball(0, 0f, 0f)\n        ball(1, -5f, 0f)\n        ball(2, 5f, 0f)\n        ball(3, -1f, 2f)\n        ball(4, 1f, 2f)\n        ball(5, -1f, -2f)\n        ball(6, 1f, -2f)\n\n        pocket(-1f, 4f)\n        pocket(-5f, 8f)\n        pocket(-12f, 8f)\n        pocket(7f, 1f)\n        pocket(7f, -1f)\n        pocket(12f, -8f)\n        pocket(5f, -8f)\n        pocket(1f, -4f)\n        pocket(-1f, -4f)\n        pocket(-5f, -8f)\n        pocket(-12f, -8f)\n        pocket(-7f, -1f)\n        pocket(-7f, 1f)\n        pocket(-12f, 8f)\n        pocket(1f, 4f)\n        pocket(5f, 8f)\n        pocket(12f, 8f)\n\n    }\n\n    fun setTable12() {\n        reset()\n\n        startContour()\n        svgWalls(\"m 4,-7 3,3 V 5 L 4,8 H -4 L -7,5 v -9 l 3,-3 z\")\n        textureTable()\n\n        svgWood(\"M 5,-9 H -5 l -4,4 V 6 l 4,4 H 5 L 9,6 V -5 L 5,-9 4,-7 7,-4 V 5 L 4,8 H -4 L -7,5 v -9 l 3,-3 h 8 z\")\n        textureWood()\n\n        svgBalls(\"m 0,-4.5 -3,2 h 6 l -8,3 H 5 l -8,3 h 6 l -3,2\")\n\n        svgPockets(\"m 0,-1.5 1,1 1,1 -1,1 -1,1 -1,-1 -1,-1 1,-1\")\n    }\n\n    fun setTable13() {\n        reset()\n\n        startContour()\n        wallTo(-9f, 8f)\n        wallTo(3f, 8f)\n        wallTo(11f, 0f)\n        wallTo(3f, -8f)\n        wallTo(-9f, -8f)\n        wallTo(-1f, 0f)\n        wallTo(-9f, 8f)\n\n        textureTable()\n\n        svgWood(\"m 4,-9 h -17 l 9,9 -9,9 H 4 L 13,0 4,-9 3,-8 11,0 3,8 H -9 L -1,0 -9,-8 H 3 Z\")\n        textureWood()\n\n        ball(0, 0f, -7f)\n        ball(1, 4f, -3f)\n        ball(2, 4f, -1f)\n        ball(3, 4f, 1f)\n        ball(4, 6f, 1f)\n        ball(5, 6f, -1f)\n        ball(6, 6f, -3f)\n        ball(7, 2f, -5f)\n\n        pocket(9f, 0f)\n    }\n\n    fun setTable14() {\n        reset()\n\n        svgWalls(\"m -1,-8.5 h 13 v 7 l -1,1 v 2 l -1,1 v 1 l -3,3 H 6 l -1,1 H 2 l -1,1 h -13 v -7 l 1,-1 v -2 l 1,-1 v -1 l 3,-3 h 1 l 1,-1 h 3 z\")\n\n        svgWood(\"m 13,-9.5 v 19 h -26 v -19 h 26 l -1,1 H -1 l -1,1 h -3 l -1,1 h -1 l -3,3 v 1 l -1,1 v 2 l -1,1 v 7 H 1 l 1,-1 h 3 l 1,-1 h 1 l 3,-3 v -1 l 1,-1 v -2 l 1,-1 v -7 z\")\n\n        textureTable()\n\n        textureWood()\n\n        svgBalls(\"m 0,-5.5 -1,3 h 2 l 5,-4 -16,6 4,7 10,-3 6,-3\")\n\n        pocket(0f, 0f)\n    }\n\n    fun setTable15() {\n        reset()\n        svgWalls(\"m 0,-8.5 4,4 h 8 v 9 H 4 l -4,4 -4,-4 h -8 v -9 h 8 z\")\n        textureTable()\n\n        svgWood(\"m 12,-4.5 1,-1 v 11 H 6 l -4,4 h -4 l -4,-4 h -7 v -11 h 7 l 4,-4 h 4 l 4,4 h 7 l -1,1 H 4 l -4,-4 -4,4 h -8 v 9 h 8 l 4,4 4,-4 h 8 z\")\n        textureWood()\n\n        svgWalls(\"m -8,-0.5 h 1 v -1 h 1 v 1 h 1 v 1 h -1 v 1 h -1 v -1 h -1 z\")\n        svgWalls(\"m -2,-0.5 h 4 v 1 h -4 z\")\n        svgWalls(\"m 6,-0.5 h 1 v -1 h 1 v 1 h 1 v 1 H 8 v 1 H 7 v -1 H 6 Z\")\n\n        svgBalls(\"m 0,-6.5 -4,4 h 2 2 2 2\")\n\n        svgPockets(\"m -7,-0.5 h 1 l -1,1 h 1 l 6,-1 v 1 l 7,-1 h 1 v 1 H 7\")\n    }\n\n    fun setTable16() {\n        reset()\n        svgWalls(\"m 10,-8.5 2,2 v 4 l -1,1 v 1 h 1 v 7 l -2,2 h -20 l -2,-2 v -4 l 1,-1 v -1 h -1 v -7 l 2,-2 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -3,1 2,2 v 4 l -1,1 v 1 h 1 v 7 l -2,2 h -20 l -2,-2 v -4 l 1,-1 v -1 h -1 v -7 l 2,-2 h 20 z\")\n        textureWood()\n\n        svgWood(\"m -6,-0.5 h 4 v 1 h -4 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 2,-0.5 h 4 v 1 H 2 Z\")\n        textureWood(clear = false)\n\n\n        svgWalls(\"m -6,-0.5 h 4 v 1 h -4 z\")\n        svgWalls(\"m 2,-0.5 h 4 v 1 H 2 Z\")\n\n        svgBalls(\"m 0,-5.5 -9,4 v -2 -2 l 18,7 v 2 2\")\n\n        svgPockets(\"m -11,-0.5 22,1\")\n    }\n\n    fun setTable17() {\n        reset()\n        svgWalls(\"m -12,-8.5 h 5 l 1,1 1,-1 H 5 l 1,1 1,-1 h 5 v 6 l -1,1 1,1 v 9 H 7 l -1,-1 -1,1 H -5 l -1,-1 -1,1 h -5 v -6 l 1,-1 -1,-1 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 6 l -1,1 1,1 v 9 H 7 l -1,-1 -1,1 H -5 l -1,-1 -1,1 h -5 v -6 l 1,-1 -1,-1 v -9 h 5 l 1,1 1,-1 H 5 l 1,1 1,-1 h 5 z\")\n        textureWood()\n\n        svgWood(\"m -9,4.5 h 1 v 1 h -1 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 8,-5.5 h 1 v 1 H 8 Z\")\n        textureWood(clear = false)\n\n        svgWalls(\"m -9,4.5 h 1 v 1 h -1 z\")\n        svgWalls(\"m 8,-5.5 h 1 v 1 H 8 Z\")\n\n        svgBalls(\"m 2,1.5 -4,-4 9,-4 3,3 -17,10 -3,-3\")\n\n        svgPockets(\"m -11,7.5 22,-15\")\n    }\n\n    fun setTable18() {\n        reset()\n        svgWalls(\"M -1.873768,-5.501028 -9.7545238,-6.9787165 -5.9028566,0.044536 -9.780109,7.097959 -1.873768,5.590101 3.636299,11.457214 4.645434,3.471884 11.928095,0.044537 4.645434,-3.382811 3.636299,-11.368142 Z\")\n        textureTable()\n\n        svgWood(\"m -2.191965,-6.5984955 -9.471005,-1.8062638 4.6445599,8.4492953 -4.6445609,8.449296 9.471006,-1.806264 6.600509,7.028216 1.208843,-9.565628 8.7239,-4.105619 -8.7239,-4.10562 -1.208842,-9.565628 -6.60051,7.0282155 0.318197,1.0974675 5.510067,-5.867114 1.009135,7.985331 7.282661,3.427348 -7.282661,3.427347 -1.009135,7.98533 -5.510067,-5.867113 -7.906341,1.507858 3.877252,-7.053423 -3.8516668,-7.0232525 7.8807558,1.4776885 z\")\n        textureWood()\n\n        svgBalls(\"M 1.4989936,-4.8729264 -4.2375148,-2.9096429 -4.183409,3.0064445 1.422223,4.8747718 4.9416018,0.04071578 2.4855285,-7.3913398 2.3781083,7.5860744\")\n\n        svgPockets(\"m -6.4964445,4.6800963 -0.06241,-9.198239 14.6998834,4.58931737 -8.24304055,0.03251996\")\n    }\n\n    fun setTable19() {\n        reset()\n        svgWalls(\"m -6,-5.5 v -2 H 6 v 2 l 3,-3 h 3 v 3 l -3,3 h 1 l 2,-2 v 9 l -2,-2 H 9 l 3,3 v 3 H 9 l -3,-3 v 2 H -6 v -2 l -3,3 h -3 v -3 l 3,-3 h -1 l -2,2 v -9 l 2,2 h 1 l -3,-3 v -3 h 3 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 3 l -3,3 h 1 l 2,-2 v 9 l -2,-2 H 9 l 3,3 v 3 H 9 l -3,-3 v 2 H -6 v -2 l -3,3 h -3 v -3 l 3,-3 h -1 l -2,2 v -9 l 2,2 h 1 l -3,-3 v -3 h 3 l 3,3 v -2 H 6 v 2 l 3,-3 h 3 z\")\n        textureWood()\n\n        svgWood(\"m -6,-1.5 1,1 v 1 l -1,1 -1,-1 v -1 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 0,3.5 1,1 -1,1 -1,-1 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 5,-0.5 1,-1 1,1 v 1 l -1,1 -1,-1 z\")\n        textureWood(clear = false)\n\n        svgWalls(\"m -6,-1.5 1,1 v 1 l -1,1 -1,-1 v -1 z\")\n        svgWalls(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n        svgWalls(\"m 0,3.5 1,1 -1,1 -1,-1 z\")\n        svgWalls(\"m 5,-0.5 1,-1 1,1 v 1 l -1,1 -1,-1 z\")\n\n        svgBalls(\"m 0,0 v -6.5 13 l -9,-12 H 9 v 11 H -9\")\n\n        svgPockets(\"m -11,-6.5 1,-1 h 20 l 1,1 v 13 l -1,1 h -20 l -1,-1\")\n    }\n\n    fun setTable21() {\n        reset()\n        svgWalls(\"m -1,-8 h 2 l 6,6 5,-5 V 6 L 10,8 H -10 L -12,6 V -7 l 5,5 z\")\n        textureTable()\n\n        svgWood(\"M 13,-9 H -13 V 9 H 13 V -9 l -1,2 V 6 L 10,8 H -10 L -12,6 V -7 l 5,5 6,-6 h 2 l 6,6 5,-5 z\")\n        textureWood()\n\n        svgWood(\"m -4,-3 3,-3 V 3 H -2 L -4,1 Z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 1,-6 3,3 V 1 L 2,3 H 1 Z\")\n        textureWood(clear = false)\n\n        svgWood(\"m -10,-1 1,-1 1,1 -1,1 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 8,-1 1,-1 1,1 -1,1 z\")\n        textureWood(clear = false)\n\n\n        svgWalls(\"m -4,-3 3,-3 V 3 H -2 L -4,1 Z\")\n        svgWalls(\"m 1,-6 3,3 V 1 L 2,3 H 1 Z\")\n        svgWalls(\"m -10,-1 1,-1 1,1 -1,1 z\")\n        svgWalls(\"m 8,-1 1,-1 1,1 -1,1 z\")\n\n        svgBalls(\"m -4,7 h 2 L -11,4 V 2 H 11 V 4 L 4,7 H 2\")\n\n        svgPockets(\"M -10,-3 H 10 L 0,7\")\n    }\n\n    fun setTable22() {\n        reset()\n        svgWalls(\"m -12,-8.5 h 24 v 17 h -24 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 17 h -24 v -17 h 24 z\")\n        textureWood()\n\n        svgWood(\"m -9,-2.5 7,7 v 1 l -7,-7 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 2,4.5 7,-7 v 1 l -7,7 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n        textureWood(clear = false)\n\n        svgWalls(\"m -9,-2.5 7,7 v 1 l -7,-7 z\")\n        svgWalls(\"m 2,4.5 7,-7 v 1 l -7,7 z\")\n        svgWalls(\"m -1,-4.5 1,-1 1,1 -1,1 z\")\n\n        svgBalls(\"m 2,-6.5 h -4 v 6 h 2 2 l -4,2 h 2 2\")\n\n        svgPockets(\"m 0,3.5 v 4\")\n    }\n\n    fun setTable23() {\n        reset()\n        svgWalls(\"m 2,-7.5 h 7 l 1,-1 h 2 v 2 l -1,1 v 2 L 0,7.5 v 1 h -2 v -1 h -7 l -1,1 h -2 v -2 l 1,-1 v -2 l 11,-11 v -1 h 2 z\")\n        textureTable()\n\n        svgWood(\"M 13,-9.5 H -1 l -12,12 v 7 H 1 l 12,-12 v -7 l -1,1 v 2 l -1,1 v 2 L 0,7.5 v 1 h -2 v -1 h -7 l -1,1 h -2 v -2 l 1,-1 v -2 l 11,-11 v -1 h 2 v 1 h 7 l 1,-1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"m -3,0.5 -1,2 -1,2 -1,2 9,-7 1,-2 1,-2 1,-2\")\n\n        svgPockets(\"m 1,-8.5 10,1 -12,16 -10,-1\")\n    }\n\n    fun setTable26() {\n        reset()\n        svgWalls(\"M 10,0 2,-8 h -6 l 4,4 H -12 V 4 H 0 l -4,4 h 6 z\")\n        textureTable()\n\n        svgWood(\"M 4,-9 H -8 l 4,4 h -9 V 5 h 9 L -8,9 H 4 L 13,0 4,-9 2,-8 10,0 2,8 H -4 L 0,4 H -12 V -4 H 0 l -4,-4 h 6 z\")\n        textureWood()\n\n        svgWood(\"M 5,0 4,-1 3,0 4,1 Z\")\n        textureWood(clear = false)\n\n        svgWalls(\"M 5,0 4,-1 3,0 4,1 Z\")\n\n        svgBalls(\"m -11,0 h 2 2 6 l -2,-2 h -2 l 2,4 h -2\")\n\n        svgPockets(\"M 1.5,-7 V 7\")\n    }\n\n    fun setTable28() {\n        reset()\n        svgWalls(\"m -2,-8.5 h 4 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 1,-1 h 2 v 2 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 1 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 2 h -2 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -4 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -2 v -2 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -1 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -2 h 2 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 z\")\n        textureTable()\n\n        svgWood(\"m 12,-9.5 h -24 l -1,1 v 17 l 1,1 h 24 l 1,-1 v -17 l -1,-1 v 1 2 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 1 l -1,1 1,1 -1,1 1,1 -1,1 1,1 v 2 h -2 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -4 l -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 -1,-1 -1,1 h -2 v -2 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -1 l 1,-1 -1,-1 1,-1 -1,-1 1,-1 -1,-1 v -2 h 2 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 1,-1 h 4 l 1,1 1,-1 1,1 1,-1 1,1 1,-1 1,1 1,-1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"M -6,0 H 4 L 5.5,-1 V 1 L 7,-2 v 2 2\")\n\n        svgPockets(\"m -11,-7.5 11,-1 11,1 v 15 l -11,1 -11,-1\")\n    }\n\n    fun setTable30() {\n        reset()\n        svgWalls(\"M -9,-7.5 H 9 l 1,-1 h 2 v 2 l -1,1 H 9 l -1,1 H 6 l -1,1 H 3 l -1,1 v 1 h 2 l 1,-1 h 2 l 1,-1 h 4 v 7 H 8 L 7,2.5 H 5 L 4,1.5 H 2 v 1 l 1,1 h 2 l 1,1 h 2 l 1,1 h 2 l 1,1 v 2 H 10 L 9,7.5 H -9 l -1,1 h -2 v -2 l 1,-1 h 2 l 1,-1 h 2 l 1,-1 h 2 l 2,-2 v -3 l -2,-2 h -2 l -1,-1 h -2 l -1,-1 h -2 l -1,-1 v -2 h 2 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 l -1,1 H 9 l -1,1 H 6 l -1,1 H 3 l -1,1 v 1 h 2 l 1,-1 h 2 l 1,-1 h 4 v 7 H 8 L 7,2.5 H 5 L 4,1.5 H 2 v 1 l 1,1 h 2 l 1,1 h 2 l 1,1 h 2 l 1,1 v 2 H 10 L 9,7.5 H -9 l -1,1 h -2 v -2 l 1,-1 h 2 l 1,-1 h 2 l 1,-1 h 2 l 2,-2 v -3 l -2,-2 h -2 l -1,-1 h -2 l -1,-1 h -2 l -1,-1 v -2 h 2 l 1,1 H 9 l 1,-1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"M 0.5,0 -8,-6.5 h 2 2 L 8,6.5 H 6 4\")\n\n        svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n    }\n\n    fun setTable33() {\n        reset()\n        svgWalls(\"m 1,-6.5 10,10 v 2 h 1 v 2 h -24 v -2 h 1 v -2 l 10,-10 v -1 h 2 z\")\n        textureTable()\n\n        svgWood(\"m 1,-8.5 h -2 l -12,12 v 5 h 26 v -5 L 1,-8.5 v 1 1 l 10,10 v 2 h 1 v 2 h -24 v -2 h 1 v -2 l 10,-10 v -1 h 2 z\")\n        textureWood()\n\n        svgBalls(\"m 0,2.5 -8,3 2,-1 2,-1 12,2 -2,-1 -2,-1\")\n\n        svgPockets(\"M -12,6.5 H 12 L 0,-7.5\")\n    }\n\n    fun setTable36() {\n        reset()\n        svgWalls(\"m -9,-7.5 v -1 H 8 l 1,1 1,-1 h 2 v 2 l -1,1 1,1 v 9 l -1,1 1,1 v 2 h -2 l -1,-1 -1,1 H -9 v -1 h -1 v 1 h -2 v -2 h 1 v -1 h -1 v -11 h 1 v -1 h -1 v -2 h 2 v 1 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 2 l -1,1 1,1 v 9 l -1,1 1,1 v 2 h -2 l -1,-1 -1,1 H -9 v -1 h -1 v 1 h -2 v -2 h 1 v -1 h -1 v -11 h 1 v -1 h -1 v -2 h 2 v 1 h 1 v -1 H 8 l 1,1 1,-1 h 2 z\")\n        textureWood()\n\n        svgWood(\"m 0,-5.5 h 6 v 1 H 0 Z\")\n        textureWood(clear = false)\n\n        svgWood(\"m -5,-0.5 h 4 v 1 h -4 z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 5,-0.5 h 4 v 1 H 5 Z\")\n        textureWood(clear = false)\n\n        svgWood(\"m 0,4.5 h 6 v 1 H 0 Z\")\n        textureWood(clear = false)\n\n\n        svgWalls(\"m 0,-5.5 h 6 v 1 H 0 Z\")\n        svgWalls(\"m -5,-0.5 h 4 v 1 h -4 z\")\n        svgWalls(\"m 5,-0.5 h 4 v 1 H 5 Z\")\n        svgWalls(\"m 0,4.5 h 6 v 1 H 0 Z\")\n\n        svgBalls(\"m 3,0 5,-6.5 1,2 -2,1 1,10 1,-2 -2,-1 3.5,-3.5\")\n\n        svgPockets(\"m -11,-7.5 h 22 v 15 h -22\")\n    }\n\n    fun setTable37() {\n        reset()\n        svgWalls(\"m 3,-6.5 1,-1 h 6 l 1,1 v 4 l -1,1 v 3 l 1,1 v 4 l -1,1 H 4 l -1,-1 h -6 l -1,1 h -6 l -1,-1 v -4 l 1,-1 v -3 l -1,-1 v -4 l 1,-1 h 6 l 1,1 z\")\n        textureTable()\n\n        svgWood(\"M 11,-9.5 H 4 l -1,1 h -6 l -1,-1 h -7 l -2,2 v 5 l 1,1 v 3 l -1,1 v 5 l 2,2 h 7 l 1,-1 h 6 l 1,1 h 7 l 2,-2 v -5 l -1,-1 v -3 l 1,-1 v -5 l -2,-2 -1,2 1,1 v 4 l -1,1 v 3 l 1,1 v 4 l -1,1 H 4 l -1,-1 h -6 l -1,1 h -6 l -1,-1 v -4 l 1,-1 v -3 l -1,-1 v -4 l 1,-1 h 6 l 1,1 h 6 l 1,-1 h 6 z\")\n        textureWood()\n\n        svgWood(\"m -1,-1.5 h 2 v 1 h 1 v 2 H 0 v -1 h -1 z\")\n        textureWood(clear = false)\n\n        svgWalls(\"m -1,-1.5 h 2 v 1 h 1 v 2 H 0 v -1 h -1 z\")\n\n        svgBalls(\"M -6,0 H 4 L 5.5,-1 V 1 L 7,-2 v 2 2\")\n\n        svgPockets(\"m -7,-4.5 14,9\")\n    }\n\n    fun setTable40() {\n        reset()\n        svgWalls(\"m -12,-8.5 h 24 v 17 h -24 z\")\n        textureTable()\n\n        svgWood(\"m 13,-9.5 h -26 v 19 h 26 v -19 l -1,1 v 17 h -24 v -17 h 24 z\")\n        textureWood()\n\n        svgSquares(\"m 6.5,-5 h -2 -2 -2 -2 -2 -2 l -2,2 v 6 l 2,2 h 2 2 2 2 2 2\")\n\n        svgBalls(\"m -7,-7.5 2,1 2,-1 2,1 2,-1 2,1 2,-1 2,1\")\n\n        svgPockets(\"m 11,-7.5 v 15 l -19,-7 v -1\")\n    }\n\n\n    fun setTable20() {\n        reset()\n\n        startContour()\n        wallTo(-11f, 4f)\n        wallTo(-12f, 3f)\n        wallTo(-12f, -3f)\n        wallTo(-11f, -4f)\n        wallTo(11f, -4f)\n        wallTo(12f, -3f)\n        wallTo(12f, 3f)\n        wallTo(11f, 4f)\n        wallTo(-11f, 4f)\n\n        textureTable()\n\n        svgWood(\"M 13,-5 H -13 V 5 H 13 V -5 l -2,1 1,1 v 6 l -1,1 h -22 l -1,-1 v -6 l 1,-1 h 22 z\")\n        textureWood()\n\n        rhombus(-9, 2)\n        rhombus(-1, -2)\n        rhombus(1, 2)\n        rhombus(9, -2)\n\n        pocket(-5, 3)\n        pocket(-3, -2)\n        pocket(3, 1)\n\n        pocket(-11, -2)\n        pocket(-11, -1)\n\n        ball(0, 8.5f, 2.5f)\n\n        ball(1, 3, 3)\n        ball(2, 5, 2)\n        ball(3, 7, 1)\n        ball(4, 5, -1)\n        ball(5, 3, -3)\n        ball(6, 1, -1)\n    }\n\n\n    private val lastWallPoint = Vec3().apply { setNaN() }\n    fun wallTo(x: Float, y: Float) {\n        if (lastWallPoint.isNotNaN()) {\n            walls.add(Wall(lastWallPoint.x, lastWallPoint.y, x, y))\n        }\n        lastWallPoint.set(x, y, 0f)\n    }\n\n    fun startContour() {\n        lastWallPoint.setNaN()\n    }\n\n    fun svgWalls(path: String) {\n        svgPath(path, line = { x1: Double, y1: Double, x2: Double, y2: Double ->\n            walls.add(Wall(x1.toFloat(), -y1.toFloat(), x2.toFloat(), -y2.toFloat()))\n        })\n    }\n\n    fun svgBalls(path: String) {\n        var i = 0\n        svgPath(path, line = { x1: Double, y1: Double, x2: Double, y2: Double ->\n            if (i == 0) {\n                ball(i, x1.toFloat(), -y1.toFloat())\n                i++\n            }\n            ball(i, x2.toFloat(), -y2.toFloat())\n            i++\n        })\n    }\n\n    val woodKFar = KFloatArray()\n    fun svgWood(path: String) {\n        woodKFar.clear()\n        svgPath(path, line = { x1: Double, y1: Double, x2: Double, y2: Double ->\n            //walls.add(Wall(x1.toFloat(), -y1.toFloat(), x2.toFloat(), -y2.toFloat()))\n            woodKFar.add(x1.toFloat(), -y1.toFloat())\n        })\n    }\n\n    fun square(x: Float, y: Float) {\n        startContour()\n        wallTo(x + 0.5f, y + 0.5f)\n        wallTo(x + 0.5f, y - 0.5f)\n        wallTo(x - 0.5f, y - 0.5f)\n        wallTo(x - 0.5f, y + 0.5f)\n        wallTo(x + 0.5f, y + 0.5f)\n\n        woodKFar.clear()\n        woodKFar.add(x + 0.5f, y + 0.5f)\n        woodKFar.add(x + 0.5f, y - 0.5f)\n        woodKFar.add(x - 0.5f, y - 0.5f)\n        woodKFar.add(x - 0.5f, y + 0.5f)\n        textureWood(clear = false)\n    }\n\n    fun svgSquares(path: String) {\n        var i = 0\n        svgPath(path, line = { x1: Double, y1: Double, x2: Double, y2: Double ->\n            if (i == 0) {\n                square(x1.toFloat(), -y1.toFloat())\n                i++\n            }\n            square(x2.toFloat(), -y2.toFloat())\n            i++\n        })\n    }\n\n    fun svgPockets(path: String) {\n        var i = 0\n        svgPath(path, line = { x1: Double, y1: Double, x2: Double, y2: Double ->\n            if (i == 0) {\n                pocket(x1.toFloat(), -y1.toFloat())\n                i++\n            }\n            pocket(x2.toFloat(), -y2.toFloat())\n            i++\n        })\n    }\n\n    fun rhombus(x: Float, y: Float) {\n        startContour()\n        wallTo(x + 0f, y + -1f)\n        wallTo(x + 1f, y + 0f)\n        wallTo(x + 0f, y + 1f)\n        wallTo(x + -1f, y + -0f)\n        wallTo(x + 0f, y + -1f)\n\n        woodKFar.clear()\n        woodKFar.add(x + 0f, y + -1f)\n        woodKFar.add(x + 1f, y + 0f)\n        woodKFar.add(x + 0f, y + 1f)\n        woodKFar.add(x + -1f, y + -0f)\n\n        textureWood(clear = false)\n    }\n\n    fun rhombus(x: Int, y: Int) = rhombus(x.toFloat(), y.toFloat())\n\n    fun pocket(x: Float, y: Float) {\n        pockets.add(Pocket(x, y))\n    }\n\n    fun pocket(x: Int, y: Int) = pocket(x.toFloat(), y.toFloat())\n\n    fun ball(idx: Int, x: Float, y: Float) {\n        val ball = game.allBalls[idx]\n        ball.pos.set(x, y, Ball.R)\n        ball.resetSlightRandomOrientation()\n        ball.active = true\n    }\n\n    fun ball(idx: Int, x: Int, y: Int) = ball(idx, x.toFloat(), y.toFloat())\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.nodes.node\nimport kmptemplate.ui.Widget\nimport kmptemplate.ui.img\nimport kmptemplate.ui.padding\nimport kmptemplate.ui.row\nimport kmptemplate.ui.space\nimport kmptemplate.ui.text\n\nclass TopBar(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var menuWidget: Widget\n    private lateinit var im: ImmediateMode\n\n    val menuHeight = 2f\n\n    override fun init(gloo: GLOO) {\n        im = ImmediateMode(gloo)\n\n        menuWidget = row {\n            drawBg = true\n            cornerR.value = 0.0f\n\n            text(node(game.table.level) { game.loc.top_bar_level(game.table.level.value) }, game.resources.font, 1f) {\n                color.value = COLOR_BLACK\n            }\n\n            space(1f)\n\n            text(node(game.table.shots) { game.loc.shots_count(game.table.shots.value) }, game.resources.font, 1f) {\n                color.value = COLOR_BLACK\n            }\n\n            space(2f)\n\n            padding(0.5f) {\n                img(game.resources.retryIcon, 1f, 1f)\n                onMouseDown = {\n                    game.ads.showInterstitial()\n                    game.gotoLevel(game.table.level.value, game.table.withAim)\n                }\n                onTouchDown = onMouseDown\n            }\n\n\n            space(0.5f)\n\n            padding(0.5f) {\n                img(game.resources.menuIcon, 1f, 1f)\n                onMouseDown = {\n                    game.ads.showInterstitial()\n                    game.gotoMenu()\n                }\n                onTouchDown = onMouseDown\n            }\n        }\n    }\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        input.forEvents { event ->\n            menuWidget.handleEvent(event, game.topBarCam)\n        }\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        menuWidget.x = 0f\n        menuWidget.y = game.topBarCam.h / 2f - menuHeight / 2f\n\n        menuWidget.measureSelf()\n        menuWidget.layoutChilds()\n\n        menuWidget.width = game.topBarCam.w\n    }\n\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        im.disableDepthTest()\n        menuWidget.render(im, game.topBarCam)\n        im.enableDepthTest()\n    }\n\n    fun show() {\n        active = true\n    }\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.cs\nimport kmptemplate.math.frac\nimport kmptemplate.time.currentTimeSeconds\nimport kotlin.math.PI\n\nclass Tutorial(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var im: ImmediateMode\n\n    private val handSize = 4f\n\n    private var startTime = 0.0\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        im = ImmediateMode(gloo)\n        startTime = currentTimeSeconds()\n    }\n\n    private var phase = 0.0\n    private var shift = 0.0f\n    private var handX = 0.0f\n    private var handY = 0.0f\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        if (game.storage.isTutorialFinished()) {\n            game.tutorial.active = false\n        }\n\n        if (game.menu.active) {\n            return\n        }\n\n        phase = frac(0.5 * (currentTimeSeconds() - startTime))\n\n        shift = 1f - cs(phase * 2.0 * PI).toFloat()\n\n        handX = game.beatBall.pos.x + dir.x * shift\n        handY = game.beatBall.pos.y + dir.y * shift\n\n        if (game.sling.started) return\n\n        if (phase < 0.5f) {\n            game.sling.pos.set(handX, handY, 0f)\n        } else {\n            game.sling.pos.set(game.beatBall.pos)\n        }\n    }\n\n\n    private val dir = Vec3(-5f, -0.2f, 0f)\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        if (game.menu.active) {\n            return\n        }\n\n        if (game.sling.started || game.storage.isTutorialFinished()) return\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        im.clear()\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.texCoord(1f, 1f)\n        im.texCoord(1f, 0f)\n        im.texCoord(0f, 0f)\n\n        im.texCoord(1f, 1f)\n        im.texCoord(0f, 0f)\n        im.texCoord(0f, 1f)\n\n        val handOffsetX = -1.67f\n        val handOffsetY = -0.13f\n\n        val x = handX + handOffsetX\n        val y = handY + handOffsetY\n\n        val halfHandSize = 0.5f * handSize * if (phase < 0.5f) 1.0f else 1.15f\n\n        im.pos(x - halfHandSize, y - halfHandSize, 0f)\n        im.pos(x + halfHandSize, y - halfHandSize, 0f)\n        im.pos(x + halfHandSize, y + halfHandSize, 0f)\n\n        im.pos(x - halfHandSize, y - halfHandSize, 0f)\n        im.pos(x + halfHandSize, y + halfHandSize, 0f)\n        im.pos(x - halfHandSize, y + halfHandSize, 0f)\n\n        im.renderTex(game.resources.handTexture, game.cam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.color.COLOR_BLACK\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.math.F_PI\nimport kmptemplate.nodes.IF\nimport kmptemplate.nodes.Node\nimport kmptemplate.nodes.gtEq\nimport kmptemplate.nodes.node\nimport kmptemplate.nodes.setNode\nimport kmptemplate.time.currentTimeSeconds\nimport kmptemplate.ui.Widget\nimport kmptemplate.ui.column\nimport kmptemplate.ui.img\nimport kmptemplate.ui.padding\nimport kmptemplate.ui.row\nimport kmptemplate.ui.text\nimport kotlin.math.sin\n\n\nclass WinScreen(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var textIm: ImmediateMode\n\n    private lateinit var widget: Widget\n\n    private val starsCount = Node(0)\n    private val showPhase = Node(0.0f)\n    private val score = Node(0)\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        textIm = ImmediateMode(gloo)\n\n        val bgCol = Color(COLOR_WHITE)\n        val fontCol = Color(COLOR_BLACK)\n\n\n        widget = column {\n\n            drawBg = true\n            bgColor.value = bgCol\n\n            padding(0.5f) {\n                row {\n                    img(game.resources.clothTexture, 2f, 2f) {\n                        texture = IF(starsCount gtEq 1, game.resources.starTexture, game.resources.emptyStarTexture)\n//                    matrix = node(showPhase) { Mat4().apply { setTranslate(0f, 2.0f * sin(showPhase.value * F_PI), 1f) } }\n                        matrix.setNode(showPhase) { setTranslate(0f, 2.0f * sin(showPhase.value * F_PI), 1f) }\n                    }\n                    img(game.resources.clothTexture, 2f, 2f) {\n                        texture = IF(starsCount gtEq 2, game.resources.starTexture, game.resources.emptyStarTexture)\n                        matrix.setNode(showPhase) { setTranslate(0f, 2.0f * sin(showPhase.value * F_PI), 1f) }\n                    }\n                    img(game.resources.clothTexture, 2f, 2f) {\n                        texture = IF(starsCount gtEq 3, game.resources.starTexture, game.resources.emptyStarTexture)\n                        matrix.setNode(showPhase) { setTranslate(0f, 2.0f * sin(showPhase.value * F_PI), 1f) }\n                    }\n                }\n            }\n\n\n            text(game.loc.you_win, fontSize = 3f, font = game.resources.font) {\n                color.value = fontCol\n            }\n\n            text(node(score) { game.loc.score(score.value) }, fontSize = 2f, font = game.resources.font) {\n                color.value = fontCol\n            }\n//\n//            text(node(game.table.shots) { \"In ${game.table.shots.value} shots\" }, fontSize = 2f, font = game.font) {\n//                color.value = fontCol\n//            }\n\n            val showNextLevelBtn = false\n\n            if (showNextLevelBtn) {\n                padding(0.5f) {\n                    padding(0.25f) {\n                        drawBg = true\n                        text(game.loc.next_level, fontSize = 2f, font = game.resources.font) {\n                            color.value = fontCol\n\n                            onMouseDown = {\n                                game.ads.showInterstitial()\n\n                                game.soundManager.play(game.resources.buttonSound)\n                                game.gotoLevel(game.table.level.value + 1, game.table.withAim)\n                            }\n                            onTouchDown = onMouseDown\n                        }\n                    }\n                }\n            }\n\n\n            padding(0.5f) {\n                padding(0.25f) {\n                    drawBg = true\n\n                    text(game.loc.play_again, fontSize = 2f, font = game.resources.font) {\n                        color.value = fontCol\n\n                        onMouseDown = {\n                            game.ads.showInterstitial()\n\n                            game.soundManager.play(game.resources.buttonSound)\n                            game.gotoLevel(game.table.level.value, game.table.withAim)\n                        }\n                        onTouchDown = onMouseDown\n                    }\n                }\n            }\n\n\n            padding(0.5f) {\n                padding(0.25f) {\n                    drawBg = true\n\n                    text(game.loc.goto_menu, fontSize = 2f, font = game.resources.font) {\n                        color.value = fontCol\n\n                        onMouseDown = {\n                            game.soundManager.play(game.resources.buttonSound)\n\n                            game.gotoMenu()\n                        }\n                        onTouchDown = onMouseDown\n                    }\n                }\n            }\n        }\n    }\n\n    override fun preUpdate(dt: Double, t: Double, input: Keyboard) {\n        input.forEvents { event ->\n            widget.handleEvent(event, game.uiCam)\n        }\n\n        widget.measureSelf()\n        widget.layoutChilds()\n    }\n\n    private var t = -1E30\n    private val SHOW_ANIM_TIME = 0.35f\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        showPhase.value = ((t - showStartTime).toFloat() / SHOW_ANIM_TIME).coerceIn(0.0f, 1.0f)\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n\n        widget.render(textIm, game.uiCam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n\n    private var showStartTime = -1E30\n\n    fun show(level: Int, shots: Int, score: Int) {\n        game.stopAllBalls()\n\n        showStartTime = currentTimeSeconds()\n        game.winScreen.active = true\n        game.soundManager.play(game.resources.winSound)\n\n        val starsCount = Levels.levels[level]!!.shotsToStars(shots)\n\n        this.starsCount.value = starsCount\n        this.score.value = score\n    }\n\n}","package kmptemplate.games.billiard.creatives\n\nimport kmptemplate.entities.Entity\nimport kmptemplate.games.billiard.Ball\nimport kmptemplate.games.billiard.BilliardGame\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.OrthoCamera\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\n\nclass IconScene(val game: BilliardGame) : Entity(parent = game) {\n\n    private lateinit var gloo: GLOO\n    lateinit var ball0: Ball\n    lateinit var ball1: Ball\n    lateinit var ball2: Ball\n    lateinit var ball3: Ball\n\n    val cam = OrthoCamera()\n\n    val dx = 0f\n\n    //    val dy = -0.75f\n    val dy = 0.0f\n\n    override fun init(gloo: GLOO) {\n        super.init(gloo)\n\n        this.gloo = gloo\n\n\n        cam.worldUp.set(1f, 0f, 0f)\n\n        val D = 2.0f * Ball.R\n        ball0 = Ball(game, game.resources.ballTextures[0]!!, game.resources.envTexture, -0f, -1.0f * D + dy + 0.5f * D, null)\n\n        ball1 = Ball(game, game.resources.ballTextures[1]!!, game.resources.envTexture, -1.0f * D, dy, null)\n        ball2 = Ball(game, game.resources.ballTextures[2]!!, game.resources.envTexture, 0.0f * D, dy + 0.5f * D, null)\n        ball3 = Ball(game, game.resources.ballTextures[3]!!, game.resources.envTexture, 1.0f * D, dy, null)\n\n        ball0.init(gloo)\n        ball1.init(gloo)\n        ball2.init(gloo)\n        ball3.init(gloo)\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        gloo.gl.clearColor(game.BILLIARD_GREEN)\n        gloo.gl.clear()\n\n        cam.setScreenSize(viewport.w, viewport.h)\n\n        val camSz = 2.5f\n\n        cam.fitHeightCalcWidth(viewport, camSz * 2.0f)\n\n        ball1.render(cam)\n        ball2.render(cam)\n        ball3.render(cam)\n        ball0.render(cam)\n    }\n}","package kmptemplate.games.billiard\n\nimport kmptemplate.entities.YaGamesJsPlayer\nimport kmptemplate.tetris.yaGamesLoc\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.launch\n\nfun billiardMain() = GlobalScope.launch {\n    println(\"Billiard 1.0 inside player\")\n\n    val player = YaGamesJsPlayer(\n        yaMetricaId = \"89962603\",\n        leaderBoardName = \"MainLeaderBoardV2\"\n    )\n\n    val entity = BilliardGame(\n        player.soundman,\n        player.ads,\n        BilliardStorage(player.storage),\n        BilliardResources(),\n        BilliardAnalytics(player.analytics),\n        player.leaderBoard,\n        yaGamesLoc(\"en\" to En(), \"ru\" to Ru()),\n        player.loader\n    )\n\n    player.start(entity)\n}\n\n","package kmptemplate.gloo.immediate\n\nimport kmptemplate.color.COLOR_BLUE\nimport kmptemplate.color.COLOR_GREEN\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.color.Color\nimport kmptemplate.gloo.Buffer\nimport kmptemplate.gloo.Cam\nimport kmptemplate.gloo.FloatBuffer2\nimport kmptemplate.gloo.FloatBuffer3\nimport kmptemplate.gloo.FloatBuffer4\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GL.Companion.GL_DEPTH_TEST\nimport kmptemplate.gloo.GL.Companion.GL_LINES\nimport kmptemplate.gloo.GL.Companion.GL_TRIANGLES\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.fonts.SdfFontShader\nimport kmptemplate.gloo.fonts.calcHeight\nimport kmptemplate.gloo.fonts.calcWidth\nimport kmptemplate.gloo.primitives.Mesh\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Vec3\nimport kotlin.math.absoluteValue\nimport kotlin.random.Random\n\nclass LightingShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        varying vec3 vPos;\n        \n        attribute vec3 aNormal;\n        varying vec3 vNormal;\n        \n        attribute vec4 aColor;\n        varying vec4 vColor;\n       \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            vNormal = (uModel * vec4(aNormal,0.0)).xyz;\n            vPos = (uModel * vec4(aPos,1.0)).xyz;\n            gl_Position =  uProj * uView * uModel * vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        varying vec3 vPos;\n        varying vec4 vColor;\n        varying vec3 vNormal;\n\n        uniform vec3 uLightPos;\n        uniform vec4 uLightColor;\n        \n        void main() {\n            vec3 dirToLight = normalize(uLightPos - vPos);\n            vec3 tint = vColor.rgb * uLightColor.rgb * ( 0.2 + 0.8*max(dot(dirToLight, vNormal), 0.0));\n            gl_FragColor = vec4(tint, 1.0);\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val aNormal = prog.getAttrib3f(\"aNormal\")\n\n    val uLightPos = prog.getUniform3f(\"uLightPos\")\n    val uLightColor = prog.getUniform4f(\"uLightColor\")\n    val uModel = prog.getUniformMat4f(\"uModel\");\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: LightingShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\nclass ColoredShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        \n        attribute vec4 aColor;\n        varying vec4 vColor;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            gl_Position =  uProj * uView * uModel * vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        varying vec4 vColor;\n        \n        void main() {\n            gl_FragColor = vColor;\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: ColoredShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\nclass TexturedShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n                \n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n\n        attribute vec4 aColor;\n        varying vec4 vColor;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            vTexCoord = aTexCoord;\n            gl_Position =  uProj * uView * uModel* vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uTexture;\n        varying vec4 vColor;\n        varying vec2 vTexCoord;\n\n        void main() {\n            gl_FragColor = vColor * texture2D(uTexture, vTexCoord);\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val uTexture = prog.getUniformSampler2D(\"uTexture\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: TexturedShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\nclass TableShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        varying vec3 vPos;\n                \n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n\n        attribute vec4 aColor;\n        varying vec4 vColor;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main() {\n            vColor = aColor;\n            vTexCoord = aTexCoord;\n            vPos = aPos;\n            gl_Position =  uProj * uView * uModel* vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uTexture;\n        varying vec4 vColor;\n        varying vec2 vTexCoord;\n        varying vec3 vPos;\n        \n        float sq(vec2 v) {\n            return dot(v,v);    \n        }\n\n        void main() {\n            vec2 lightPos1 = vec2(-9.0, 0.1);\n            vec2 lightPos2 = vec2(-3.0, -0.2);\n            vec2 lightPos3 = vec2(3.0, 0.2);\n            vec2 lightPos4 = vec2(9.0, -0.1);\n            \n            float invScale = 1.0 / 64.0;\n            float invCount = 1.0 / 4.0; //count of light sources\n            float brightness = 2.4;\n            \n            float light = 0.0;\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos1));\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos2));\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos3));\n            light += invCount/(1.0 + invScale * sq(vPos.xy - lightPos4));\n            \n            vec4 envColor = vec4(0.0,0.0,0.0,1.0);\n        \n            gl_FragColor = mix(vColor * texture2D(uTexture, vTexCoord), envColor, 1.1 - light * brightness);\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n    val uTexture = prog.getUniformSampler2D(\"uTexture\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: TableShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\n\nclass CardShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aPos;\n        attribute vec4 aColor;\n                        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        varying vec3 vPos;\n        varying vec4 vColor;\n        \n        void main() {\n            vColor = aColor;\n            vPos = aPos;\n            gl_Position =  uProj * uView * uModel * vec4(aPos, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform vec2 uOrigin;\n        uniform vec2 uSize;\n        uniform vec4 uShColor;\n        uniform float uCornerR;\n        uniform float uShadowSz;\n                \n        varying vec3 vPos;\n        varying vec4 vColor;\n        \n        const vec2 V0 = vec2(0.0);\n                \n        float box(vec2 p, vec2 sz, vec2 offset) {\n            vec2 q = p - offset;\n            vec2 d = abs(q) - sz;\n            \n            return length( max(V0,d)) + min(max(d.x,d.y) , 0.0);\n        }\n        \n        float sn(float t) {\n            return 0.5 + 0.5 * sin(t);\n        }\n\n        void main() {\n            float px = 0.05;\n       \n            float d = box(vPos.xy, uSize - vec2(uCornerR), uOrigin);\n            vec4 fgColor = vColor;\n            vec4 bgColor = vec4(0.5, 0.6, 0.7, 1.0);\n        \n            float c = 1.0 - smoothstep(uCornerR, uCornerR + 0.75*px, d);//foreground intensity\n            float s = 1.0 - smoothstep(uCornerR, uCornerR + uShadowSz, d);//shadow intensity\n            \n//            c = sn(d*10.0);\n            \n            gl_FragColor =  mix(mix(bgColor,uShColor, s), fgColor, c);\n            gl_FragColor.a = s;\n//            gl_FragColor =  vec4(c,c,c,1.0);\n//            gl_FragColor =  uShColor;\n        }   \n        \"\"\".trimIndent()\n    )\n\n    val aColor = prog.getAttrib4f(\"aColor\")\n    val aPos = prog.getAttrib3f(\"aPos\")\n\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uView = prog.getUniformMat4f(\"uView\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n\n    val uOrigin = prog.getUniform2f(\"uOrigin\");\n    val uSize = prog.getUniform2f(\"uSize\");\n    val uShadowColor = prog.getUniform4f(\"uShColor\")\n\n    val uCornerR = prog.getUniform1f(\"uCornerR\")\n    val uShadowSz = prog.getUniform1f(\"uShadowSz\")\n\n    inline fun use(code: CardShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\ntypealias Align = Int\n\nprivate var cachedColoredShader: ColoredShader? = null\nprivate var cachedLightingShader: LightingShader? = null\nprivate var cachedCardShader: CardShader? = null\nprivate var cachedTableShader: TableShader? = null\nprivate var cachedTexturedShader: TexturedShader? = null\nprivate var cachedSdfFontShader: SdfFontShader? = null\n\nclass ImmediateMode(val gloo: GLOO) {\n    private var changed: Boolean = true\n\n    val color = Color(1f, 1f, 1f, 1f)\n\n    val posFB = FloatBuffer3()\n    private val colorFB = FloatBuffer4()\n    private val texCoordFB = FloatBuffer2()\n    private val normalsFB = FloatBuffer3()\n\n    var linePosBuf: Buffer\n    var lineColorBuf: Buffer\n    var texCoordsBuf: Buffer\n    private var normalsBuf: Buffer\n\n    private val coloredShader: ColoredShader\n        get() {\n            if (cachedColoredShader == null) {\n                cachedColoredShader = ColoredShader(gloo)\n            }\n            return cachedColoredShader!!\n        }\n\n    private val lightingShader: LightingShader\n        get() {\n            if (cachedLightingShader == null) {\n                cachedLightingShader = LightingShader(gloo)\n            }\n            return cachedLightingShader!!\n        }\n    private val cardShader: CardShader\n        get() {\n            if (cachedCardShader == null) {\n                cachedCardShader = CardShader(gloo)\n            }\n            return cachedCardShader!!\n        }\n    public val tableShader: TableShader\n        get() {\n            if (cachedTableShader == null) {\n                cachedTableShader = TableShader(gloo)\n            }\n            return cachedTableShader!!\n        }\n\n    val texShader: TexturedShader\n        get() {\n            if (cachedTexturedShader == null) {\n                cachedTexturedShader = TexturedShader(gloo)\n            }\n            return cachedTexturedShader!!\n        }\n\n    private val sdfFontShader: SdfFontShader\n        get() {\n            if (cachedSdfFontShader == null) {\n                cachedSdfFontShader = SdfFontShader(gloo)\n            }\n            return cachedSdfFontShader!!\n        }\n\n    init {\n        linePosBuf = gloo.createBuffer()\n        lineColorBuf = gloo.createBuffer()\n        texCoordsBuf = gloo.createBuffer()\n        normalsBuf = gloo.createBuffer()\n    }\n\n    fun pos(x: Float, y: Float, z: Float) {\n        posFB.add(x, y, z)\n        changed = true\n    }\n\n    fun pos(v: Vec3) {\n        pos(v.x, v.y, v.z)\n    }\n\n    fun normal(x: Float, y: Float, z: Float) {\n        normalsFB.add(x, y, z)\n        changed = true\n    }\n\n    fun texCoord(x: Float, y: Float) {\n        texCoordFB.add(x, y)\n        changed = true\n    }\n\n    fun color(r: Float, g: Float, b: Float, a: Float) {\n        colorFB.add(r, g, b, a)\n        changed = true\n    }\n\n    fun color(c: Color) {\n        color(c.r, c.g, c.b, c.a)\n    }\n\n    fun line(x1: Float, y1: Float, z1: Float, x2: Float, y2: Float, z2: Float) {\n        posFB.add(x1, y1, z1)\n        colorFB.add(color)\n\n        posFB.add(x2, y2, z2)\n        colorFB.add(color)\n\n        changed = true\n    }\n\n    fun line(v1: Vec3, v2: Vec3) {\n        posFB.add(v1.x, v1.y, v1.z)\n        colorFB.add(color)\n\n        posFB.add(v2.x, v2.y, v2.z)\n        colorFB.add(color)\n\n        changed = true\n    }\n\n    fun pivot(x: Float, y: Float, z: Float, sz: Float = 0.01f) {\n        val hsz = sz / 2\n        line(x - hsz, y, z, x + hsz, y, z)\n        line(x, y - hsz, z, x, y + hsz, z)\n        line(x, y, z - hsz, x, y, z + hsz)\n    }\n\n    fun diamond(x: Float, y: Float, z: Float, sz: Float = 0.01f) {\n        val hsz = sz / 2\n        line(x - hsz, y, z, x, y + hsz, z)\n        line(x, y + hsz, z, x + hsz, y, z)\n        line(x + hsz, y, z, x, y - hsz, z)\n        line(x, y - hsz, z, x - hsz, y, z)\n    }\n\n    fun pivot(v: Vec3, sz: Float = 0.01f) {\n        pivot(v.x, v.y, v.z, sz)\n    }\n\n    fun cell(\n        x1: Float, y1: Float, z1: Float,\n        x2: Float, y2: Float, z2: Float\n    ) {\n        color.set(COLOR_RED)\n        line(x1, y1, z1, x2, y1, z1)\n        line(x1, y1, z2, x2, y1, z2)\n        line(x1, y2, z2, x2, y2, z2)\n        line(x1, y2, z1, x2, y2, z1)\n\n        color.set(COLOR_GREEN)\n        line(x1, y1, z1, x1, y2, z1)\n        line(x1, y1, z2, x1, y2, z2)\n        line(x2, y1, z2, x2, y2, z2)\n        line(x2, y1, z1, x2, y2, z1)\n\n        color.set(COLOR_BLUE)\n        line(x1, y1, z1, x1, y1, z2)\n        line(x1, y2, z1, x1, y2, z2)\n        line(x2, y2, z1, x2, y2, z2)\n        line(x2, y1, z1, x2, y1, z2)\n    }\n\n    fun arrow(\n        x1: Float, y1: Float, z1: Float,\n        x2: Float, y2: Float, z2: Float\n    ) {\n        line(x1, y1, z1, x2, y2, z2)\n        pivot(x2, y2, z2, sz = 0.2f)\n    }\n\n    fun prepareBuffers() {\n        linePosBuf.setData(posFB)\n        lineColorBuf.setData(colorFB)\n        texCoordsBuf.setData(texCoordFB)\n\n        changed = false\n    }\n\n    fun renderColoredLines(cam: Cam, modelMat: Mat4 = Mat4.IDENT) {\n        if (changed) {\n            prepareBuffers()\n        }\n\n        coloredShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n\n            gloo.gl.drawArrays(GL.GL_LINES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderColoredTriangles(cam: Cam) {\n        if (changed) {\n            prepareBuffers()\n        }\n\n        coloredShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderTex(tex: Texture2D, cam: Cam, modelMat: Mat4 = Mat4.IDENT) {\n        if (changed) {\n            prepareBuffers()\n        }\n\n        texShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            uTexture.set(tex)\n            aTexCoord.set(texCoordsBuf)\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    companion object {\n        val ALIGN_CENTER = 0\n\n        /** object will be located to the top of specified (x,y) coordinates */\n        val ALIGN_TOP = 1\n\n        /** object will be located to the bottom of specified (x,y) coordinates */\n        val ALIGN_BOTTOM = 2\n\n        /** object will be located to the left of specified (x,y) coordinates */\n        val ALIGN_LEFT = 3\n\n        /** object will be located to the right of specified (x,y) coordinates */\n        val ALIGN_RIGHT = 4\n    }\n\n    fun renderText(text: String, font: SdfFont, x0: Float, y0: Float, h: Float, color: Color, cam: Cam? = null, horAlign: Align = ALIGN_CENTER, verAlign: Align = ALIGN_CENTER, z: Float = 0f, weight: Float = 0.5f, edge: Float = 8f / 256f, compress: Float = 1.0f, outlineColor: Color? = null) {\n\n        var textVertsCount = 0\n\n\n        val textWidth = calcWidth(text, h, compress)\n        val textHeight = calcHeight(text, h)\n\n        val fixX = when (horAlign) {\n            ALIGN_RIGHT -> 0.0f\n            ALIGN_LEFT -> -textWidth\n            ALIGN_CENTER -> -textWidth / 2.0f\n            else -> throw IllegalArgumentException(\"Unknown text alignment\")\n        }\n\n        val fixY = when (verAlign) {\n            ALIGN_TOP -> textHeight - h\n            ALIGN_BOTTOM -> -h\n            ALIGN_CENTER -> textHeight / 2f - h\n            else -> throw IllegalArgumentException(\"Unknown text alignment\")\n        }\n\n        val screenX0 = x0 + fixX\n        val screenY0 = y0 + fixY\n\n        var screenX = screenX0\n        var screenY = screenY0\n\n        val screenW = h * 0.75f\n        val screenH = h\n\n        val dz = 0.00001f\n        var zz = z\n\n        for (ch in text) {\n\n            if (ch == '\\n') {\n                screenY -= screenH;\n                screenX = screenX0;\n                continue\n            }\n\n            val sdfChar = font.charmap.get(ch.code) ?: continue\n\n            val x = sdfChar.x / font.texture.width.toFloat()\n            val y = sdfChar.y / font.texture.height.toFloat()\n            val w = sdfChar.width / font.texture.width.toFloat()\n            val h = sdfChar.height / font.texture.height.toFloat()\n\n            texCoord(x, y + h);\n            texCoord(x + w, y + h);\n            texCoord(x + w, y);\n\n            texCoord(x + w, y);\n            texCoord(x, y);\n            texCoord(x, y + h);\n\n            pos(screenX, screenY, zz)\n            pos(screenX + screenW, screenY, zz)\n            pos(screenX + screenW, screenY + screenH, zz)\n\n            pos(screenX + screenW, screenY + screenH, zz)\n            pos(screenX, screenY + screenH, zz)\n            pos(screenX, screenY, zz)\n\n            zz += dz\n\n            textVertsCount += 6\n\n            screenX += screenW * compress\n        }\n\n        if (outlineColor != null) {\n            sdfFontShader.use {\n                //outline\n\n                sdfFontShader.uFontTexture.set(font.texture)\n                sdfFontShader.uColor.set(outlineColor)\n                sdfFontShader.uWeight.set(1.1f * weight)\n                sdfFontShader.uThreshold.set(edge)\n                sdfFontShader.aTexCoord.set(texCoordsBuf)\n                sdfFontShader.aCoord.set(linePosBuf)\n                sdfFontShader.uModel.set(Mat4.IDENT)\n                sdfFontShader.uView.set(cam?.viewMatrix ?: Mat4.IDENT)\n                sdfFontShader.uProj.set(cam?.projMatrix ?: Mat4.IDENT)\n\n                if (changed) {\n                    prepareBuffers()\n                }\n\n                gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n            }\n        }\n\n\n        sdfFontShader.use {\n            //glyph\n\n            sdfFontShader.uFontTexture.set(font.texture)\n            sdfFontShader.uColor.set(color.r, color.g, color.b, color.a)\n            sdfFontShader.uWeight.set(weight)\n            sdfFontShader.uThreshold.set(edge)\n            sdfFontShader.aTexCoord.set(texCoordsBuf)\n            sdfFontShader.aCoord.set(linePosBuf)\n            sdfFontShader.uModel.set(Mat4.IDENT)\n            sdfFontShader.uView.set(cam?.viewMatrix ?: Mat4.IDENT)\n            sdfFontShader.uProj.set(cam?.projMatrix ?: Mat4.IDENT)\n\n            if (changed) {\n                prepareBuffers()\n            }\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderWireframe(mesh: Mesh, cam: Cam, renderNormals: Boolean = false, modelMat: Mat4 = Mat4.IDENT) {\n        val NORM_COEFF = 0.15f\n\n        for (i in 0 until mesh.vertsCount / 3) {\n            val x0 = mesh.posBuf[9 * i + 0]\n            val y0 = mesh.posBuf[9 * i + 1]\n            val z0 = mesh.posBuf[9 * i + 2]\n\n            val x1 = mesh.posBuf[9 * i + 3]\n            val y1 = mesh.posBuf[9 * i + 4]\n            val z1 = mesh.posBuf[9 * i + 5]\n\n            val x2 = mesh.posBuf[9 * i + 6]\n            val y2 = mesh.posBuf[9 * i + 7]\n            val z2 = mesh.posBuf[9 * i + 8]\n\n            pos(x0, y0, z0)\n            pos(x1, y1, z1)\n\n            pos(x1, y1, z1)\n            pos(x2, y2, z2)\n\n            pos(x2, y2, z2)\n            pos(x0, y0, z0)\n\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n            color(1f, 1f, 1f, 1f)\n\n            if (renderNormals) {\n                val nx0 = mesh.normalsBuf[9 * i + 0]\n                val ny0 = mesh.normalsBuf[9 * i + 1]\n                val nz0 = mesh.normalsBuf[9 * i + 2]\n\n                val nx1 = mesh.normalsBuf[9 * i + 3]\n                val ny1 = mesh.normalsBuf[9 * i + 4]\n                val nz1 = mesh.normalsBuf[9 * i + 5]\n\n                val nx2 = mesh.normalsBuf[9 * i + 6]\n                val ny2 = mesh.normalsBuf[9 * i + 7]\n                val nz2 = mesh.normalsBuf[9 * i + 8]\n\n\n                pos(x0, y0, z0)\n                pos(x0 + NORM_COEFF * nx0, y0 + NORM_COEFF * ny0, z0 + NORM_COEFF * nz0)\n\n                pos(x1, y1, z1)\n                pos(x1 + NORM_COEFF * nx1, y1 + NORM_COEFF * ny1, z1 + NORM_COEFF * nz1)\n\n                pos(x2, y2, z2)\n                pos(x2 + NORM_COEFF * nx2, y2 + NORM_COEFF * ny2, z2 + NORM_COEFF * nz2)\n\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n                color(0f, 1f, 0f, 1f)\n            }\n        }\n\n\n\n\n\n        coloredShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            gloo.gl.drawArrays(GL_LINES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderRandomColoredTriangles(mesh: Mesh, cam: Cam, meshColor: Color? = null) {\n        val rnd = Random(100500L)\n        posFB.reset()\n        colorFB.reset()\n\n        for (i in 0 until mesh.vertsCount / 3) {\n            val x0 = mesh.posBuf[9 * i + 0]\n            val y0 = mesh.posBuf[9 * i + 1]\n            val z0 = mesh.posBuf[9 * i + 2]\n\n            val x1 = mesh.posBuf[9 * i + 3]\n            val y1 = mesh.posBuf[9 * i + 4]\n            val z1 = mesh.posBuf[9 * i + 5]\n\n            val x2 = mesh.posBuf[9 * i + 6]\n            val y2 = mesh.posBuf[9 * i + 7]\n            val z2 = mesh.posBuf[9 * i + 8]\n\n            pos(x0, y0, z0)\n            pos(x1, y1, z1)\n            pos(x1, y1, z1)\n            pos(x2, y2, z2)\n\n            if (meshColor == null) {\n                color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1.0f)\n                color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1.0f)\n                color(rnd.nextFloat(), rnd.nextFloat(), rnd.nextFloat(), 1.0f)\n            } else {\n                color(meshColor)\n                color(meshColor)\n                color(meshColor)\n            }\n        }\n\n\n        coloredShader.use {\n            uModel.set(Mat4.IDENT)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderWithLighting(mesh: Mesh, cam: Cam, lightPos: Vec3, modelMat: Mat4 = Mat4.IDENT) {\n        for (i in 0 until mesh.vertsCount / 3) {\n            val x0 = mesh.posBuf[9 * i + 0]\n            val y0 = mesh.posBuf[9 * i + 1]\n            val z0 = mesh.posBuf[9 * i + 2]\n\n            val x1 = mesh.posBuf[9 * i + 3]\n            val y1 = mesh.posBuf[9 * i + 4]\n            val z1 = mesh.posBuf[9 * i + 5]\n\n            val x2 = mesh.posBuf[9 * i + 6]\n            val y2 = mesh.posBuf[9 * i + 7]\n            val z2 = mesh.posBuf[9 * i + 8]\n\n            pos(x0, y0, z0)\n            pos(x1, y1, z1)\n            pos(x2, y2, z2)\n\n            color(0.6f, 0.6f, 0.6f, 1.0f)\n            color(0.6f, 0.6f, 0.6f, 1.0f)\n            color(0.6f, 0.6f, 0.6f, 1.0f)\n\n            val nx0 = mesh.normalsBuf[9 * i + 0]\n            val ny0 = mesh.normalsBuf[9 * i + 1]\n            val nz0 = mesh.normalsBuf[9 * i + 2]\n\n            val nx1 = mesh.normalsBuf[9 * i + 3]\n            val ny1 = mesh.normalsBuf[9 * i + 4]\n            val nz1 = mesh.normalsBuf[9 * i + 5]\n\n            val nx2 = mesh.normalsBuf[9 * i + 6]\n            val ny2 = mesh.normalsBuf[9 * i + 7]\n            val nz2 = mesh.normalsBuf[9 * i + 8]\n\n            normal(nx0, ny0, nz0)\n            normal(nx1, ny1, nz1)\n            normal(nx2, ny2, nz2)\n        }\n\n\n        lightingShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n            normalsBuf.setData(normalsFB)\n\n            uLightColor.set(1f, 1f, 0.7f, 1f)\n            uLightPos.set(lightPos)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            aNormal.set(normalsBuf)\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n    fun renderWithLightingOpt(mesh: Mesh, cam: Cam, lightPos: Vec3, modelMat: Mat4 = Mat4.IDENT) {\n        if (changed) {\n            for (i in 0 until mesh.vertsCount / 3) {\n                val x0 = mesh.posBuf[9 * i + 0]\n                val y0 = mesh.posBuf[9 * i + 1]\n                val z0 = mesh.posBuf[9 * i + 2]\n\n                val x1 = mesh.posBuf[9 * i + 3]\n                val y1 = mesh.posBuf[9 * i + 4]\n                val z1 = mesh.posBuf[9 * i + 5]\n\n                val x2 = mesh.posBuf[9 * i + 6]\n                val y2 = mesh.posBuf[9 * i + 7]\n                val z2 = mesh.posBuf[9 * i + 8]\n\n                pos(x0, y0, z0)\n                pos(x1, y1, z1)\n                pos(x2, y2, z2)\n\n                color(0.6f, 0.6f, 0.6f, 1.0f)\n                color(0.6f, 0.6f, 0.6f, 1.0f)\n                color(0.6f, 0.6f, 0.6f, 1.0f)\n\n                val nx0 = mesh.normalsBuf[9 * i + 0]\n                val ny0 = mesh.normalsBuf[9 * i + 1]\n                val nz0 = mesh.normalsBuf[9 * i + 2]\n\n                val nx1 = mesh.normalsBuf[9 * i + 3]\n                val ny1 = mesh.normalsBuf[9 * i + 4]\n                val nz1 = mesh.normalsBuf[9 * i + 5]\n\n                val nx2 = mesh.normalsBuf[9 * i + 6]\n                val ny2 = mesh.normalsBuf[9 * i + 7]\n                val nz2 = mesh.normalsBuf[9 * i + 8]\n\n                normal(nx0, ny0, nz0)\n                normal(nx1, ny1, nz1)\n                normal(nx2, ny2, nz2)\n            }\n        }\n\n        lightingShader.use {\n            uModel.set(modelMat)\n            uProj.set(cam.projMatrix)\n            uView.set(cam.viewMatrix)\n\n            linePosBuf.setData(posFB)\n            lineColorBuf.setData(colorFB)\n            normalsBuf.setData(normalsFB)\n\n            uLightColor.set(1f, 1f, 0.7f, 1f)\n            uLightPos.set(lightPos)\n\n            aPos.set(linePosBuf)\n            aColor.set(lineColorBuf)\n            aNormal.set(normalsBuf)\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, posFB.length() / 3)\n        }\n    }\n\n\n    fun clear() {\n        posFB.reset()\n        colorFB.reset()\n        texCoordFB.reset()\n        normalsFB.reset()\n        changed = true\n    }\n\n\n    fun enableDepthTest() {\n        gloo.gl.enable(GL_DEPTH_TEST)\n    }\n\n    fun disableDepthTest() {\n        gloo.gl.disable(GL_DEPTH_TEST)\n    }\n\n    fun renderCard(x1: Float, y1: Float, x2: Float, y2: Float, r: Float, color1: Color, color2: Color, cam: Cam) {\n        posFB.add(x1, y1, 0f)\n        posFB.add(x2, y1, 0f)\n        posFB.add(x2, y2, 0f)\n\n        posFB.add(x1, y1, 0f)\n        posFB.add(x2, y2, 0f)\n        posFB.add(x1, y2, 0f)\n\n        colorFB.add(color1)\n        colorFB.add(color2)\n        colorFB.add(color1)\n\n        colorFB.add(color1)\n        colorFB.add(color1)\n        colorFB.add(color2)\n\n        renderColoredTriangles(cam)\n    }\n\n    private val cardColor = Color(0.0f, 0.05f, 0.1f, 0.05f)\n\n    fun renderCardNew(x1: Float, y1: Float, x2: Float, y2: Float, r: Float, shadowSz: Float, color1: Color, color2: Color, cam: Cam) {\n        val rr = shadowSz\n\n        posFB.add(x1 - rr, y1 - rr, 0f)\n        posFB.add(x2 + rr, y1 - rr, 0f)\n        posFB.add(x2 + rr, y2 + rr, 0f)\n\n        posFB.add(x1 - rr, y1 - rr, 0f)\n        posFB.add(x2 + rr, y2 + rr, 0f)\n        posFB.add(x1 - rr, y2 + rr, 0f)\n\n        colorFB.add(color1)\n        colorFB.add(color2)\n        colorFB.add(color1)\n\n        colorFB.add(color1)\n        colorFB.add(color1)\n        colorFB.add(color2)\n\n        prepareBuffers()\n\n        cardShader.use {\n            uOrigin.set((x1 + x2) * 0.5f, (y1 + y2) * 0.5f)\n            uSize.set((x2 - x1).absoluteValue * 0.5f, (y2 - y1).absoluteValue * 0.5f)\n            uShadowColor.set(cardColor)\n\n            uCornerR.set(r)\n            uShadowSz.set(shadowSz)\n\n            uModel.set(Mat4.IDENT)\n            uView.set(cam.viewMatrix)\n            uProj.set(cam.projMatrix)\n\n            aColor.set(lineColorBuf)\n            aPos.set(linePosBuf)\n\n\n            gloo.gl.drawArrays(GL_TRIANGLES, 0, 6)\n        }\n    }\n\n\n}\n","package kmptemplate\n\nclass MutableInt(var value: Int = 0)\n\nclass PerformanceTracker {\n\n    var allocsCount = 0\n    var raytrace = 0\n\n    var drawCallsCount = 0\n    var drawVertsCount = 0\n\n    var glBufUploads = 0\n    var glBufUploadBytes = 0L\n\n    var tagToCount = HashMap<String, MutableInt>()\n\n    fun trackVec() {\n        allocsCount++\n    }\n\n    fun trackRayTrace() {\n        raytrace++\n    }\n\n    fun trackDrawCall(vertsCount: Int) {\n        drawCallsCount++\n        drawVertsCount += vertsCount\n    }\n\n    fun trackGLbufferData(bytesCount: Int) {\n        glBufUploads++\n        glBufUploadBytes += bytesCount\n    }\n\n    fun track(tag: String) {\n        tagToCount.getOrPut(tag) { MutableInt(0) }.value++\n    }\n\n    fun tagsInfo(): String = tagToCount.entries\n        .joinToString(separator = \"\\n\") { \"${it.key}: ${it.value.value}\" }\n\n    fun clear() {\n        allocsCount = 0\n        raytrace = 0\n\n        drawCallsCount = 0\n        drawVertsCount = 0\n\n        glBufUploads = 0\n        glBufUploadBytes = 0L\n\n        for (count in tagToCount.values) {\n            count.value = 0\n        }\n    }\n\n    fun trackUiEvent() {\n        allocsCount++\n    }\n}\n\nval PERF_TRACKER = PerformanceTracker()",null,null,"package kmptemplate.asteroids\n\nimport kmptemplate.asteroids.entities.RaceWorldEntity\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.KEY_H\nimport kmptemplate.input.KEY_I\nimport kmptemplate.input.KEY_J\nimport kmptemplate.input.KEY_K\nimport kmptemplate.input.KEY_L\nimport kmptemplate.input.KEY_Y\nimport kmptemplate.input.Keyboard\nimport kmptemplate.sound.SoundBuffer\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.time.currentTimeSeconds\nimport kmptemplate.ui.Text\nimport kotlin.random.Random\n\nval MAP_SZ = 30f\nval CELL_SZ = 50f\nval CELL_H = 10f\nval ROAD_W = 8f * 2f //about ten times car size\nval ROAD_HLFW = ROAD_W / 2\nval ROAD_H = 0.55f\nval CURB_W = 0.5f\nval CURB_H = 0.5f\n\nclass GridSampleRender(val gl: GL, val kb: Keyboard, val soundMan: SoundManager) {\n\n    val gloo = GLOO(gl)\n\n    private var startTime = 0.0\n\n    private lateinit var raceTimerText: Text\n\n\n    private lateinit var mouseTexture: Texture2D\n\n    private var width: Int = 1\n    private var height: Int = 1\n    fun onSizeChanged(width: Int, height: Int) {\n        gl.viewPort(0, 0, width, height)\n        this.width = width\n        this.height = height\n    }\n\n    val CONTROL_CAM_LEFT = KEY_J\n    val CONTROL_CAM_RIGHT = KEY_L\n    val CONTROL_CAM_FWD = KEY_I\n    val CONTROL_CAM_BACK = KEY_K\n    val CONTROL_CAM_UP = KEY_Y\n    val CONTROL_CAM_DOWN = KEY_H\n\n    lateinit var uiIm: ImmediateMode\n    lateinit var mitrFont: SdfFont\n\n    val rnd = Random(100500200600L)\n\n    private var raceStartTime = 0.0\n\n    private var raceFinishTime = 0.0\n\n    lateinit var worldEntity: RaceWorldEntity\n\n    lateinit var pulse: SoundBuffer\n\n    suspend fun init() {\n\n        gl.enable(GL.GL_DEPTH_TEST)\n\n        gl.enable(GL.GL_CULL_FACE)\n        gl.cullFace(GL.GL_BACK)\n\n        gl.enable(GL.GL_BLEND)\n        gl.blendFunc(GL.GL_SRC_ALPHA, GL.GL_ONE_MINUS_SRC_ALPHA)\n\n        uiIm = ImmediateMode(gloo)\n\n        mitrFont = SdfFont(gloo, gloo.createTexture2D(\"fonts/mitr.fnt.png\"))\n\n        raceTimerText = Text(\" \", mitrFont, 0.0f, 0.9f, 0.1f)\n\n        worldEntity = RaceWorldEntity(mitrFont)\n        worldEntity.initHierarchy(gloo)\n\n        worldEntity.carEntity.reset()\n\n        mouseTexture = gloo.createTexture2D(\"mouse.png\")\n        mouseTexture.bind(0)\n\n//        pulse = soundMan.loadSoundBuf(\"sounds/pulse_s8.raw\")\n        pulse = soundMan.loadSoundBuf(\"sounds/pulse.wav\")\n\n        startTime = currentTimeSeconds()\n    }\n\n    val uiCam = PlainCamera()\n\n    fun render() {\n        kb.pollMouse()\n\n        val dt = 1.0 / 60.0\n\n        val currentTimeSeconds = currentTimeSeconds()\n        val t = (currentTimeSeconds - startTime)\n\n        worldEntity.updateHierarchy(dt, t, kb)\n\n        gl.clearColor(0f, 0f, 0.2f, 1f)\n        gl.clear()\n\n        if (kb.mouseJustPressed(0)) {\n            val coords = kb.mouseCoords()\n            val x = 2f * coords.first.toFloat() / width - 1f\n            val y = 1f - 2f * coords.second.toFloat() / height\n            println(\"mouse pressed coords ${x} ${y}\")\n        }\n\n        if (kb.mouseJustPressed(0)) {\n            val (mx, my) = kb.mouseCoords()\n            val x = 2f * mx.toFloat() / width - 1f\n            val y = 1f - 2f * my.toFloat() / height\n\n            for (btn in worldEntity.menu.allBtns) {\n                btn.handleMouse(x, y)\n            }\n        }\n\n        if (kb.mouseJustPressed(0)) {\n            soundMan.play(pulse)\n            println(\"playing pulse\")\n        }\n\n\n        worldEntity.renderHierarchy(Viewport.FAKE_VIEWPORT, worldEntity.camEntity.cam, uiCam)\n\n        worldEntity.carEntity.prevCarPos.set(worldEntity.carEntity.car.pos)\n    }\n\n}","package kmptemplate.asteroids.entities\n\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GL\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\n\nclass RaceTimerEntity(val world: RaceWorldEntity, val font: SdfFont) : Entity(world) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var textIm: ImmediateMode\n\n    private var startTime = 0.0\n    private var time = 0.0\n    private var finishTime = 0.0\n    private var stopped = false\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n        textIm = ImmediateMode(gloo)\n    }\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        if (!stopped) {\n            this.time = t\n        }\n    }\n\n    override fun render(viewport: Viewport, cam: Camera, uiCam: PlainCamera) {\n        val t = (time - startTime).toFloat()\n\n        gloo.gl.disable(GL.GL_DEPTH_TEST)\n        val hundreds = (t * 100.0).toLong() % 100L\n        var formatHundreds = hundreds.toString()\n        while (formatHundreds.length < 2) {\n            formatHundreds = '0' + formatHundreds\n        }\n\n        val seconds = t.toInt()\n        val formattedTime = \"${seconds}.${formatHundreds}\"\n\n        textIm.clear()\n        textIm.renderText(formattedTime, font, 0f, 0.9f, 0.1f, COLOR_WHITE, uiCam)\n\n        gloo.gl.enable(GL.GL_DEPTH_TEST)\n    }\n\n    fun reset(t: Double) {\n        stopped = false\n        startTime = t\n    }\n\n    fun stop(t: Double) {\n        stopped = true\n        finishTime = t\n    }\n}",null,null,null,null,null,null,null,null,"package kmptemplate.tetris\n\nimport kmptemplate.arrays.IntArr2D\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.COLOR_YELLOW\nimport kmptemplate.color.Color\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.Keyboard\nimport kmptemplate.sound.SoundBuffer\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.tetris.Shape.Companion.COLORS\n\nclass CupEntity(val tetrisGame: TetrisGame, val soundMan: SoundManager, val pulse: SoundBuffer) : Entity(parent = tetrisGame) {\n\n    private lateinit var gloo: GLOO\n\n    private lateinit var gridIm: ImmediateMode\n    private lateinit var cellsIm: ImmediateMode\n\n    val width = 10\n    val height = 20\n\n    val cells = IntArr2D(width, height + 4)\n\n    val EMPTY = -1\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n\n        gridIm = ImmediateMode(gloo)\n        cellsIm = ImmediateMode(gloo)\n\n        gridIm.color.set(COLOR_YELLOW)\n\n        cells.data.fill(EMPTY)\n    }\n\n    private var t = 0.0\n\n    override fun update(dt: Double, t: Double, input: Keyboard) {\n        this.t = t\n    }\n\n    val blockColor = Color(0f, 0f, 0f, 1f)\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        gridIm.clear()\n        gridIm.color.set(COLOR_YELLOW)\n        for (ix in 0..width) {\n            gridIm.line(\n                ix.toFloat(), 0f, 0f,\n                ix.toFloat(), height.toFloat(), 0f\n            )\n        }\n\n        for (iy in 0..height) {\n            gridIm.line(\n                0f, iy.toFloat(), 0f,\n                width.toFloat(), iy.toFloat(), 0f\n            )\n        }\n\n        gridIm.renderColoredLines(tetrisGame.cam)\n\n\n        val WHITENING = 0.6f\n        cellsIm.clear()\n        for (ix in 0 until width) {\n            for (iy in 0 until height) {\n                if (cells[ix, iy] >= 0) {\n\n                    val shapeColor = COLORS[cells[ix, iy]]\n                    blockColor.r = shapeColor.r * (1f - WHITENING) + COLOR_WHITE.r * WHITENING\n                    blockColor.g = shapeColor.g * (1f - WHITENING) + COLOR_WHITE.g * WHITENING\n                    blockColor.b = shapeColor.b * (1f - WHITENING) + COLOR_WHITE.b * WHITENING\n\n                    cellsIm.renderBlock(ix.toFloat(), iy.toFloat(), blockColor)\n                }\n            }\n        }\n\n        cellsIm.renderColoredTriangles(tetrisGame.cam)\n    }\n\n    fun petrify(dropEntity: DropEntity) {\n\n        var petrified = false\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (dropEntity.shape.cells[ix, iy, dropEntity.orientation] == 1) {\n                    cells[dropEntity.x + ix, dropEntity.y + iy] = dropEntity.shape.color\n                    petrified = true\n                }\n            }\n        }\n\n        if (petrified) {\n\n            val clearedLinesCount = clearCheck()\n\n            val multiplier = 1f + tetrisGame.score.level * 0.1\n\n            if (clearedLinesCount > 0) {\n                val score = when (clearedLinesCount) {\n                    1 -> 100L\n                    2 -> 300L\n                    3 -> 500L\n                    4 -> 1000L\n                    else -> 2000L //may be for pentris\n                }\n                tetrisGame.score.addScore((score * multiplier).toLong())\n                tetrisGame.score.addLines(clearedLinesCount)\n                soundMan.play(tetrisGame.dropSound)\n                soundMan.play(tetrisGame.clearSound)\n            } else {\n                soundMan.play(tetrisGame.dropSound)\n            }\n        }\n\n        if (petrified) {\n            tetrisGame.boom.activate(t, dropEntity.x, dropEntity.y, dropEntity.orientation, dropEntity.shape)\n        }\n\n        for (ix in 0 until width) {\n            if (cells[ix, height - 1] >= 0) {\n                tetrisGame.gameOverState()\n                break\n            }\n        }\n    }\n\n\n    private val emptyLinesBefore = IntArray(height + 4)\n\n    fun clearCheck(): Int {\n        var iy = 0\n\n        //clear filled lines\n        var emptyLinesCount = 0\n        var countLinesCleared = 0\n        while (iy < height) {\n            var lineFilled = true\n            for (ix in 0 until width) {\n                lineFilled = lineFilled && cells[ix, iy] >= 0\n            }\n\n            emptyLinesBefore[iy] = emptyLinesCount\n\n            if (lineFilled) {\n                for (ix in 0 until width) {\n                    cells[ix, iy] = EMPTY\n                }\n                emptyLinesCount++\n                countLinesCleared++\n            }\n\n            iy++\n        }\n\n        //shift empty lines\n        if (countLinesCleared > 0) {\n            for (iy in 0 until height) {\n                if (emptyLinesBefore[iy] > 0) {\n                    for (ix in 0 until width) {\n                        cells[ix, iy - emptyLinesBefore[iy]] = cells[ix, iy]\n                    }\n                }\n            }\n\n            soundMan.play(tetrisGame.clearSound)\n        }\n\n        return countLinesCleared\n    }\n\n    fun reset() {\n        cells.data.fill(EMPTY)\n    }\n}\n\nfun ImmediateMode.renderBlock(ix: Float, iy: Float, color: Color, z: Float = 0.0f, a: Float = 1.0f, sz: Float = 1.0f) {\n\n    val cellsIm = this\n\n    val shapeColor = color\n\n    val hsz = 0.5f * sz\n\n    //top\n    run {\n        val coef = 1.0f\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n\n    //right\n    run {\n        val coef = 0.9f\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        //right\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n\n    //left\n    run {\n        val coef = 0.8f\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f + hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n\n    //bottom\n    run {\n        val coef = 0.7f\n\n        val r = shapeColor.r * coef\n        val g = shapeColor.g * coef\n        val b = shapeColor.b * coef\n\n        cellsIm.pos(ix + 0.5f - hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f + hsz, iy + 0.5f - hsz, z)\n        cellsIm.color(r, g, b, a)\n\n        cellsIm.pos(ix + 0.5f, iy + 0.5f, z)\n        cellsIm.color(r, g, b, a)\n    }\n}\n","package kmptemplate.tetris\n\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.entities.Entity\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.input.KEY_ARROW_DOWN\nimport kmptemplate.input.KEY_ARROW_LEFT\nimport kmptemplate.input.KEY_ARROW_RIGHT\nimport kmptemplate.input.KEY_ARROW_UP\nimport kmptemplate.input.KEY_Q\nimport kmptemplate.input.KEY_SPACE\nimport kmptemplate.input.Keyboard\nimport kmptemplate.tetris.Shape.Companion.COLORS\nimport kotlin.math.pow\n\nclass DropEntity(val tetrisGame: TetrisGame) : Entity(parent = tetrisGame) {\n\n    private lateinit var gloo: GLOO\n    private lateinit var im: ImmediateMode\n\n    lateinit var shape: Shape\n\n    var x = 0\n    var y = 0\n    var orientation = 0\n\n    val showGhost = true\n\n    override fun init(gloo: GLOO) {\n        this.gloo = gloo\n\n        im = ImmediateMode(gloo)\n\n        resetShape()\n    }\n\n    private var prevUpdateTime = 0.0\n    private var tickTime = 1.0\n\n\n    fun resetShape() {\n        shape = tetrisGame.nextShape.poll()\n        x = tetrisGame.cup.width / 2\n        y = tetrisGame.cup.height - shape.lastLine - 1\n\n        orientation = 0\n    }\n\n    private var inputLocked = false\n\n    var gameTime = 0.0\n\n    override fun update(dt: Double, clockTime: Double, input: Keyboard) {\n\n        if (tetrisGame.gameOverEntity.active) return\n\n        //https://harddrop.com/wiki/Tetris_Worlds\n        //Time = (0.8-((Level-1)*0.007))^(Level-1)\n\n        val level_m1 = tetrisGame.score.level - 1.0\n        tickTime = (0.8 - level_m1 * 0.007).pow(level_m1 - 1.0)\n\n        if (gameTime - prevUpdateTime > tickTime) {\n            prevUpdateTime = gameTime\n\n            if (canMoveDown()) {\n                y--\n            } else {\n                tetrisGame.cup.petrify(this)\n                inputLocked = true\n                resetShape()\n            }\n        }\n\n        if (input.justPressed(KEY_Q)) {\n            tetrisGame.switchPause()\n        }\n\n        if (!tetrisGame.pauseEntity.active) {\n            gameTime += dt\n        } else {\n            //do not handle input on pause\n            return\n        }\n\n        if (input.anyKeyJustPressed() || tetrisGame.touchUI.anyBtnJustPressed()) {\n            inputLocked = false\n        }\n\n        if (!inputLocked) {\n\n            if (input.justPressed(KEY_ARROW_UP) || tetrisGame.touchUI.rotateBtn.justPressed()) {\n                if (canRotate(+1)) {\n                    orientation++\n                    orientation %= 4\n                    tetrisGame.soundManager.play(tetrisGame.rotateSound)\n                }\n            }\n\n\n            if (input.justPressed(KEY_ARROW_LEFT) || tetrisGame.touchUI.leftBtn.justPressed()) {\n                if (canMoveLeft()) {\n                    x--\n                    tetrisGame.soundManager.play(tetrisGame.moveSounnd)\n                }\n            }\n            if (input.justPressed(KEY_ARROW_RIGHT) || tetrisGame.touchUI.rightBtn.justPressed()) {\n                if (canMoveRight()) {\n                    x++\n                    tetrisGame.soundManager.play(tetrisGame.moveSounnd)\n                }\n            }\n\n            if (input.pressed(KEY_ARROW_DOWN) || input.pressed(KEY_SPACE) || tetrisGame.touchUI.downBtn.pressed()) {\n                //TODO remove code duplication upper\n                if (canMoveDown()) {\n                    y--\n                    tetrisGame.score.addScore(1)\n                } else {\n                    tetrisGame.cup.petrify(this)\n                    inputLocked = true\n                    resetShape()\n                }\n            }\n        }\n\n    }\n\n    override fun render(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n\n        im.clear()\n        im.color.set(COLOR_RED)\n\n        val z = -0.01f\n\n        var resGhostOffset = 0\n        if (showGhost) {\n            for (ghostOffset in 0 until tetrisGame.cup.height) {\n                var stopped = false\n                for (ix in 0 until 4) {\n                    for (iy in 0 until 4) {\n                        if (shape.cells[ix, iy, orientation] == 1) {\n                            val stoppedByWall = y + iy - ghostOffset == 0\n                            val stoppedByBrick = (iy + y - 1 - ghostOffset in 0 until tetrisGame.cup.height) && (tetrisGame.cup.cells[x + ix, iy + y - 1 - ghostOffset] >= 0)\n\n                            if (stoppedByWall || stoppedByBrick) {\n                                stopped = true\n                            }\n                        }\n                    }\n                }\n\n                if (stopped) {\n                    resGhostOffset = ghostOffset\n                    break\n                }\n            }\n        }\n\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n                    im.renderBlock(x + ix.toFloat(), y + iy.toFloat(), COLORS[shape.color])\n\n                    if (showGhost && resGhostOffset != 0) {\n                        im.renderBlock(x + ix.toFloat(), y + iy.toFloat() - resGhostOffset, COLORS[shape.color], a = 0.12f)\n                    }\n                }\n            }\n        }\n\n        im.renderColoredTriangles(tetrisGame.cam)\n    }\n\n    fun canMoveRight(): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n\n                    val stoppedByWall = x + ix == tetrisGame.cup.width - 1\n                    val stoppedByBrick = (ix + x + 1 in 0 until tetrisGame.cup.width) && (tetrisGame.cup.cells[x + ix + 1, iy + y] >= 0)\n\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n\n                }\n            }\n        }\n        return true\n    }\n\n    fun canMoveLeft(): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n\n                    val stoppedByWall = x + ix == 0\n                    val stoppedByBrick = (ix + x - 1 in 0 until tetrisGame.cup.width) && (tetrisGame.cup.cells[x + ix - 1, iy + y] >= 0)\n\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n\n                }\n            }\n        }\n        return true\n    }\n\n    fun canMoveDown(): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                if (shape.cells[ix, iy, orientation] == 1) {\n\n                    val stoppedByWall = y + iy == 0\n                    val stoppedByBrick = (iy + y - 1 in 0 until tetrisGame.cup.height) && (tetrisGame.cup.cells[x + ix, iy + y - 1] >= 0)\n\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n                }\n            }\n        }\n        return true\n    }\n\n    fun canRotate(dir: Int): Boolean {\n        for (ix in 0 until 4) {\n            for (iy in 0 until 4) {\n                val newOrient = (orientation + dir + 4) % 4\n                if (shape.cells[ix, iy, newOrient] == 1) {\n                    val stoppedByWall = y + iy < 0 || x + ix < 0 || x + ix >= tetrisGame.cup.width\n                    val stoppedByBrick = (ix + x in 0 until tetrisGame.cup.width && iy + y in 0 until tetrisGame.cup.height) && (tetrisGame.cup.cells[x + ix, iy + y] >= 0)\n                    if (stoppedByWall || stoppedByBrick) {\n                        return false\n                    }\n                }\n            }\n        }\n        return true\n    }\n}",null,null,"package kmptemplate.analytics\n\nabstract class Analytics {\n    abstract fun sendEvent(event: String, map: Map<String, Any> = emptyMap())\n}\n\nclass PrintAnalytics : Analytics() {\n    override fun sendEvent(event: String, map: Map<String, Any>) {\n        println(\"analytics event: ${event} params: ${map}\")\n    }\n}\n\nclass CombinedAnalytics(vararg val analytics: Analytics) : Analytics() {\n    override fun sendEvent(event: String, map: Map<String, Any>) {\n        for (analytic in analytics) {\n            try {\n                analytic.sendEvent(event, map)\n            } catch (t: Throwable) {\n                println(\"Failed to send analytic event ${event} params: ${map}\")\n                t.printStackTrace()\n            }\n        }\n    }\n}","package kmptemplate.color\n\nimport kmptemplate.math.Vec4\n\nclass Color(red: Float, green: Float, blue: Float, alpha: Float) : Vec4(red, green, blue, alpha) {\n\n    var r: Float\n        get() = super.data[0]\n        set(value) {\n            super.data[0] = value\n        }\n\n    var g: Float\n        get() = super.data[1]\n        set(value) {\n            super.data[1] = value\n        }\n\n    var b: Float\n        get() = super.data[2]\n        set(value) {\n            super.data[2] = value\n        }\n\n    var a: Float\n        get() = super.data[3]\n        set(value) {\n            super.data[3] = value\n        }\n\n    constructor(c: Color) : this(c.r, c.g, c.b, c.a)\n\n    init {\n        r = red\n        g = green\n        b = blue\n        a = alpha\n    }\n\n    fun set(r: Float, g: Float, b: Float, a: Float) {\n        this.r = r\n        this.g = g\n        this.b = b\n        this.a = a\n    }\n\n    fun set(color: Color) {\n        set(color.r, color.g, color.b, color.a)\n    }\n\n    fun setMix(color1: Color, color2: Color, k: Float) {\n        val q = 1f - k\n        set(color1.r * q + color2.r * k, color1.g * q + color2.g * k, color1.b * q + color2.b * k, color1.a * q + color2.a * k)\n    }\n\n    fun set(r: Float, g: Float, b: Float) {\n        this.r = r\n        this.g = g\n        this.b = b\n        this.a = 1f\n    }\n\n}\n\nval COLOR_RED = Color(1f, 0f, 0f, 1f)\nval COLOR_GREEN = Color(0f, 1f, 0f, 1f)\nval COLOR_BLUE = Color(0f, 0f, 1f, 1f)\nval COLOR_YELLOW = Color(1f, 1f, 0f, 1f)\nval COLOR_CYAN = Color(0f, 1f, 1f, 1f)\nval COLOR_MAGENTA = Color(1f, 0f, 1f, 1f)\nval COLOR_BLACK = Color(0f, 0f, 0f, 1f)\nval COLOR_WHITE = Color(1f, 1f, 1f, 1f)\nval COLOR_GRAY = Color(0.5f, 0.5f, 0.5f, 1f)\n\nval COLOR_DARK_RED = Color(0.25f, 0f, 0f, 1f)\n\n\nval COLOR_LIGHT_RED = Color(1f, 0.5f, 0.5f, 1f)\nval COLOR_LIGHT_GREEN = Color(0.5f, 1f, 0.5f, 1f)\nval COLOR_LIGHT_BLUE = Color(0.5f, 0.5f, 1f, 1f)\n\n\n","package kmptemplate.entities\n\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.input.Keyboard\n\nprivate var idCounter = 1\n\nopen class Entity(val parent: Entity? = null, var childs: ArrayList<Entity> = ArrayList()) {\n\n    val id = idCounter++\n\n    init {\n        parent?.childs?.add(this)\n    }\n\n    var active = true\n\n    var inputActive = true\n\n    open suspend fun loadResources(gloo: GLOO) {}\n    open fun init(gloo: GLOO) {}\n    open fun preUpdate(dt: Double, t: Double, input: Keyboard) {}\n    open fun update(dt: Double, t: Double, input: Keyboard) {}\n    open fun render(viewport: Viewport, cam: Camera, uiCam: PlainCamera) {}\n\n    fun initHierarchy(gloo: GLOO) {\n        init(gloo)\n        for (child in childs) {\n            child.initHierarchy(gloo)\n        }\n    }\n\n    fun preUpdateHierarchy(dt: Double, t: Double, input: Keyboard) {\n        if (active) {\n            preUpdate(dt, t, input)\n            for (i in 0 until childs.size) {\n                val child = childs[childs.size - 1 - i]\n                child.preUpdateHierarchy(dt, t, input)\n            }\n        }\n    }\n\n    fun updateHierarchy(dt: Double, t: Double, input: Keyboard) {\n        if (active) {\n            update(dt, t, input)\n            for (i in 0 until childs.size) {\n                val child = childs[childs.size - 1 - i]\n                child.updateHierarchy(dt, t, input)\n            }\n        }\n    }\n\n    fun renderHierarchy(viewport: Viewport, unused1: Camera, unused2: PlainCamera) {\n        if (active) {\n            render(viewport, unused1, unused2)\n            for (child in childs) {\n                child.renderHierarchy(Viewport.FAKE_VIEWPORT, unused1, unused2)\n            }\n        }\n    }\n}\n","package kmptemplate.gloo\n\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.degToRad\nimport kmptemplate.math.setMult\nimport kotlin.math.tan\n\nabstract class Cam {\n    var width = 320\n    var height = 240\n\n    val projMatrix = Mat4()\n    val viewMatrix = Mat4()\n\n    fun setScreenSize(w: Int, h: Int) {\n        width = w\n        height = h\n        recalc()\n    }\n\n    abstract fun recalc()\n\n    @Deprecated(message = \"use Ray.ray() instead\")\n    abstract fun ray(x: Float, y: Float): Ray\n\n    abstract fun rayThrough(ray: Ray, x: Float, y: Float)\n}\n\nclass Camera : Cam() {\n\n    var fov = 90f\n        set(newFov) {\n            field = newFov\n            recalc()\n        }\n\n    var near = 0.05f\n        set(newNear) {\n            field = newNear\n            recalc()\n        }\n\n    var far = 10000f\n        set(newFar) {\n            field = newFar\n            recalc()\n        }\n\n    var pos = Vec3(0f, 0f, 0f)\n        set(newPos) {\n            field.assign(newPos)\n            recalc()\n        }\n\n    //normalized\n    val worldUp = Vec3(0f, 1f, 0f)\n\n    //normalized\n    var up = Vec3(0f, 1f, 0f)\n        set(newUp) {\n            field.assign(newUp)\n            recalc()\n        }\n\n    //normalized\n    var dir = Vec3(0f, 0f, -1f)\n        set(newDir) {\n            field.assign(newDir)\n            recalc()\n        }\n\n    //normalized\n    val right = Vec3(1f, 1f, 1f)\n\n    fun lookAt(center: Vec3) {\n        dir.assign(center)\n        dir.minusAssign(pos)\n\n        recalc()\n    }\n\n    fun lookDir(newDir: Vec3) {\n        dir.assign(newDir)\n        recalc()\n    }\n\n    private val tmpLookCenter = Vec3(0f, 0f, 0f)\n\n    override fun recalc() {\n        dir.normalize()\n\n        right.setCross(dir, worldUp)\n        right.normalize()\n\n        up.setCross(right, dir)\n        up.normalize()\n\n\n        tmpLookCenter.assign(pos)\n        tmpLookCenter.plusAssign(dir)\n\n        viewMatrix.setLookAt(pos, tmpLookCenter, up)\n        val aspect = width.toFloat() / height\n        projMatrix.setPerspective(degToRad(fov), aspect, near, far)\n    }\n\n    override fun ray(x: Float, y: Float): Ray {\n        recalc()\n\n        val ray = Ray()\n        ray.origin.set(pos)\n        ray.dir.set(dir)\n\n        val beta = fov / 2.0f\n\n        val l = 0.5f / tan(degToRad(beta))\n\n        ray.dir.setZero()\n        ray.dir.addMult(l, dir)\n        ray.dir.addMult(y / height, up)\n        ray.dir.addMult(x / height, right)\n\n        return ray\n    }\n\n    override fun rayThrough(ray: Ray, x: Float, y: Float) {\n        TODO(\"Not yet implemented\")\n    }\n}\n\nclass OrthoCamera : Cam() {\n\n    var w: Float = 2f\n    var h: Float = 2f\n\n    private var near = -10f\n    private var far = 10f\n\n    private val pos = Vec3(0f, 0f, 0f)\n    private val dir = Vec3(0f, 0f, -1f)\n    private val up = Vec3(0f, 1f, 0f)\n    private val right = Vec3(1f, 1f, 1f)\n    val worldUp = Vec3(0f, 1f, 0f)\n\n    fun setFullScreen() {\n        pos.set(0f, 0f, 0f)\n        dir.set(0f, 0f, -1f)\n\n        viewMatrix.setIdentity()\n\n        near = -10f\n        far = 10f\n\n        recalc()\n    }\n\n\n    fun fitH(b: Float, t: Float, cx: Float, cy: Float, cz: Float = 0f) {\n        pos.set(cx, cy, cz)\n        dir.set(0f, 0f, -1f)\n\n        val a: Float = width.toFloat() / height\n\n        val sz = (t - b) / 2\n\n        val left = -sz * a + cx\n        val right = sz * a + cx\n\n        val bottom = b + cy\n        val top = t + cy\n\n        w = right - left\n        h = top - bottom\n\n        recalc()\n    }\n\n    fun fitW(l: Float, r: Float, cx: Float, cy: Float, cz: Float = 0f) {\n        pos.set(cx, cy, cz)\n        dir.set(0f, 0f, -1f)\n\n        val a: Float = width.toFloat() / height\n\n        val sz = (r - l) / 2\n\n        val bottom = -sz / a\n        val top = sz / a\n\n        w = r - l\n        h = top - bottom\n\n        recalc()\n    }\n\n    fun fit(l: Float, r: Float, b: Float, t: Float, cx: Float, cy: Float, cz: Float = 0f) {\n        val screenAspect = width.toFloat() / height.toFloat()\n\n        val contentAspect = (r - l) / (t - b)\n\n        if (contentAspect > screenAspect) {\n            fitW(l, r, cx, cy, cz)\n        } else {\n            fitH(b, t, cx, cy, cz)\n        }\n    }\n\n    private val tmpLookCenter = Vec3(0f, 0f, 0f)\n\n    override fun recalc() {\n        dir.normalize()\n\n        right.setCross(dir, worldUp)\n        right.normalize()\n\n        up.setCross(right, dir)\n        up.normalize()\n\n        tmpLookCenter.assign(pos)\n        tmpLookCenter.plusAssign(dir)\n\n        viewMatrix.setLookAt(pos, tmpLookCenter, up)\n        projMatrix.setOrtho(-w / 2f, w / 2f, -h / 2f, h / 2f, near, far)\n    }\n\n\n    override fun ray(x: Float, y: Float): Ray {\n        recalc()\n\n        val winX: Float = x\n        val winY: Float = y\n        val winW: Float = width.toFloat()\n        val winH: Float = height.toFloat()\n\n        //x in -1..1 (left to right), y in -1..1 (bottom to top)\n        val fx = 2f * (winX / winW) - 1f\n        val fy = 1f - 2f * (winY / winH)\n\n        val ray = Ray()\n        ray.origin.set(pos)\n        ray.origin.addMult(fx / 2f * w, right)\n        ray.origin.addMult(fy / 2f * h, up)\n\n        ray.dir.set(dir)\n        ray.dir.normalize()\n\n        return ray\n    }\n\n    override fun rayThrough(ray: Ray, x: Float, y: Float) {\n        recalc()\n\n        val winX: Float = x\n        val winY: Float = y\n        val winW: Float = width.toFloat()\n        val winH: Float = height.toFloat()\n\n        //x in -1..1 (left to right), y in -1..1 (bottom to top)\n        val fx = 2f * (winX / winW) - 1f\n        val fy = 1f - 2f * (winY / winH)\n\n        ray.origin.set(pos)\n        ray.origin.addMult(fx / 2f * w, right)\n        ray.origin.addMult(fy / 2f * h, up)\n\n        ray.dir.set(dir)\n        ray.dir.normalize()\n    }\n\n\n    fun roll(a: Float) {\n        val m = Mat4()\n        m.setRotate(a, dir)\n\n        up.setMult(m, up)\n        right.setMult(m, right)\n        worldUp.setMult(m, worldUp)\n\n        recalc()\n    }\n\n    var verFov = 10f\n    var horFov = 10f\n\n    fun fitHeightCalcWidth(viewport: Viewport, h: Float) {\n        verFov = h\n        horFov = viewport.w * h / viewport.h\n\n        this.w = horFov\n        this.h = verFov\n    }\n\n    fun fitWidthCalcHeight(menuViewport: Viewport, w: Float) {\n        horFov = w\n        verFov = menuViewport.h * w / menuViewport.w\n\n\n        this.w = horFov\n        this.h = verFov\n    }\n\n    fun fitAll(w: Float, h: Float, viewPort: Viewport) {\n        if (w / h < viewPort.w.toFloat() / viewPort.h.toFloat()) {\n            verFov = h\n            horFov = h / viewPort.h * viewPort.w\n        } else {\n            horFov = w\n            verFov = w / viewPort.w * viewPort.h\n        }\n\n        this.w = horFov\n        this.h = verFov\n    }\n}","package kmptemplate.gloo\n\nimport kmptemplate.data.FloatArr\nimport kmptemplate.math.Vec2\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.Vec4\n\n\n\nopen class FloatBuffer {\n    var typedArr: FloatArr\n\n    /** pos to [prAdd] inside FloatBuffer (not inside underlying [typedArr])*/\n    var pos = 0\n    var capacity = 0\n\n    /** Offset inside [typedArr]*/\n    var offset = 0\n    var lengthField = 0\n\n    constructor(capacity: Int) : this(FloatArr(capacity), 0, 0)\n\n    constructor(buf: FloatArr, offset: Int, length: Int) {\n        typedArr = buf\n        capacity = buf.size - offset\n        pos = 0\n        this.offset = offset\n        this.lengthField = length\n    }\n\n    constructor(buf: FloatBuffer, offset: Int, length: Int) : this(buf.typedArr, buf.offset + offset, length)\n\n    fun prAdd(f: Float) {\n        if (pos >= capacity) {\n            capacity = capacity * 2\n            val newarr = FloatArr(capacity)\n            typedArr.copyInto(newarr)\n            typedArr = newarr\n        }\n        typedArr[pos] = f\n        pos++\n        lengthField++\n    }\n\n    operator fun get(i: Int): Float {\n        return typedArr[offset + i]\n    }\n\n    operator fun set(i: Int, v: Float) {\n        typedArr[offset + i] = v\n    }\n\n    fun length(): Int {\n        return lengthField\n    }\n\n    fun reset() {\n        pos = 0\n        lengthField = 0\n    }\n\n    override fun toString(): String {\n//        var res = \"\"\n//        for (i in 0 until pos) {\n//            res += typedArr[i]\n//            res += \" \"\n//        }\n//        return res\n        return \"FloatBuffer\"\n    }\n\n\n}\n\nclass FloatBuffer1 : FloatBuffer {\n\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun add(x: Float) {\n        prAdd(x)\n    }\n}\n\nclass FloatBuffer2 : FloatBuffer {\n\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun add(x: Float, y: Float) {\n        prAdd(x)\n        prAdd(y)\n    }\n\n    fun add(v: Vec2) {\n        add(v.x, v.y)\n    }\n}\n\nclass FloatBuffer3 : FloatBuffer {\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun set(i: Int, x: Float, y: Float, z: Float) {\n        set(i * 3, x)\n        set(i * 3 + 1, y)\n        set(i * 3 + 2, z)\n    }\n\n    fun add(x: Float, y: Float, z: Float) {\n        prAdd(x)\n        prAdd(y)\n        prAdd(z)\n    }\n\n    fun add(v: Vec3) {\n        add(v.x, v.y, v.z)\n    }\n}\n\nclass FloatBuffer4 : FloatBuffer {\n    constructor(capacity: Int = 16) : super(capacity)\n    constructor(buf: FloatBuffer, offset: Int = 0, length: Int) : super(buf, offset, length)\n\n    fun add(x: Float, y: Float, z: Float, w: Float) {\n        prAdd(x)\n        prAdd(y)\n        prAdd(z)\n        prAdd(w)\n    }\n\n    fun add(v: Vec4) {\n        add(v.x, v.y, v.z, v.w)\n    }\n}","package kmptemplate.gloo\n\n\nclass FramebufferHandle(val value: Any?)\n\nexpect fun createScreenFramebufferHandle(): FramebufferHandle\n\n\nclass Framebuffer(val gl: GL, val handle: FramebufferHandle) {\n\n    fun bind() {\n        gl.bindFramebuffer(GL.GL_FRAMEBUFFER, handle)\n    }\n\n    fun unbind() {\n        gl.bindFramebuffer(GL.GL_FRAMEBUFFER, ScreenHandle)\n    }\n\n    fun setTexture(texture: Texture2D) {\n        gl.framebufferTexture2D(GL.GL_FRAMEBUFFER, GL.GL_COLOR_ATTACHMENT0, GL.GL_TEXTURE_2D, texture.handle, 0)\n    }\n\n//    fun setDepth(texture: Texture2D) {\n//        gl.framebufferTexture2D(GL.GL_FRAMEBUFFER, GL.GL_DEPTH_ATTACHMENT, GL.GL_TEXTURE_2D, texture.handle, 0)\n//    }\n\n    fun checkStatus(): Int {\n        val status = gl.checkFramebufferStatus(GL.GL_FRAMEBUFFER)\n        if (status != GL.GL_FRAMEBUFFER_COMPLETE) {\n            throw RuntimeException(\"Framebuffer not complete (status=${status})\")\n        }\n        return status\n    }\n\n    companion object {\n        val ScreenHandle = createScreenFramebufferHandle()\n    }\n}\n","package kmptemplate.gloo\n\nimport kmptemplate.color.Color\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.math.Mat2\nimport kmptemplate.math.Mat3\nimport kmptemplate.math.Mat4\n\ndata class ShaderType(val value: Int)\ndata class ShaderHandle(val value: Any)\ndata class ProgramHandle(val value: Any)\n\ndata class BufferTarget(val value: Int)\ndata class BufferUsage(val value: Int)\n\ndata class BufferHandle(val value: Any)\n\ndata class TextureHandle(val value: Any)\n\ndata class UniformLocation(val value: Any)\ndata class AttribLocation(val value: Int)\n\ndata class DataType(val value: Int)\n\ndata class DrawMode(val value: Int)\n\ndata class ShaderQuery(val value: Int)\ndata class ProgramQuery(val value: Int)\n\nabstract class GL {\n    companion object {\n        val FRAGMENT_SHADER = ShaderType(35632)\n        val VERTEX_SHADER = ShaderType(35633)\n\n        val ARRAY_BUFFER = BufferTarget(34962)\n        val ELEMENT_ARRAY_BUFFER = BufferTarget(34963)\n\n        val STATIC_DRAW = BufferUsage(35044)\n        val DYNAMIC_DRAW = BufferUsage(35048)\n        val STREAM_DRAW = BufferUsage(35040)\n\n        val GL_FLOAT = DataType(5126)\n\n        val GL_POINTS = DrawMode(0)\n        val GL_LINES = DrawMode(1)\n        val GL_LINE_LOOP = DrawMode(2)\n        val GL_LINE_STRIP = DrawMode(3)\n        val GL_TRIANGLES = DrawMode(4)\n        val GL_TRIANGLE_STRIP = DrawMode(5)\n        val GL_TRIANGLE_FAN = DrawMode(6)\n\n        val GL_COLOR_BUFFER_BIT = 16384\n        val GL_DEPTH_BUFFER_BIT = 256\n\n        val GL_LINK_STATUS = ProgramQuery(35714)\n        val GL_VALIDATE_STATUS = ProgramQuery(35715)\n        val GL_ACTIVE_ATTRIBUTES = ProgramQuery(35721)\n        val GL_ACTIVE_UNIFORMS = ProgramQuery(35718)\n\n        val GL_SHADER_TYPE = ShaderQuery(35663)\n        val GL_COMPILE_STATUS = ShaderQuery(35713)\n        val GL_INFO_LOG_LENGTH = ShaderQuery(35716)\n        val GL_SHADER_SOURCE_LENGTH = ShaderQuery(35720)\n\n        val GL_NO_ERROR = 0\n        val GL_INVALID_ENUM = 1280\n        val GL_INVALID_VALUE = 1281\n        val GL_INVALID_OPERATION = 1282\n        val GL_INVALID_FRAMEBUFFER_OPERATION = 1286\n        val GL_OUT_OF_MEMORY = 1285\n\n        val GL_TEXTURE0 = 33984\n        val GL_TEXTURE_2D = 3553\n        val GL_RGBA = 6408\n        val GL_UNSIGNED_BYTE = 5121\n\n        val GL_TEXTURE_MAG_FILTER = 10240\n        val GL_TEXTURE_MIN_FILTER = 10241\n\n        val GL_LINEAR = 9729\n        val GL_NEAREST = 9728\n        val GL_NEAREST_MIPMAP_NEAREST = 9984\n        val GL_LINEAR_MIPMAP_NEAREST = 9985\n        val GL_NEAREST_MIPMAP_LINEAR = 9986\n        val GL_LINEAR_MIPMAP_LINEAR = 9987\n\n        val GL_CLAMP_TO_EDGE = 33071\n        val GL_REPEAT = 10497\n        val GL_MIRRORED_REPEAT = 33648\n\n        val GL_TEXTURE_WRAP_S = 10242\n        val GL_TEXTURE_WRAP_T = 10243\n\n        val GL_DEPTH_TEST = 2929\n        val GL_BLEND = 3042\n\n        val GL_CULL_FACE = 2884\n        val GL_FRONT = 1028\n        val GL_BACK = 1029\n\n        val GL_CW = 2304\n        val GL_CCW = 2305\n\n        val GL_SRC_ALPHA = 770\n        val GL_ONE_MINUS_SRC_ALPHA = 771\n\n        val GL_SCISSOR_TEST = 3089\n\n        val GL_FRAMEBUFFER = 36160\n        val GL_COLOR_ATTACHMENT0 = 36064\n        val GL_DEPTH_ATTACHMENT = 36096\n\n        val GL_FRAMEBUFFER_COMPLETE = 36053\n    }\n\n    var errorChecking = true\n\n    abstract fun clear()\n    abstract fun clearColor(r: Float, g: Float, b: Float, a: Float)\n\n    fun clearColor(color: Color) {\n        clearColor(color.r, color.g, color.b, color.a)\n    }\n\n    abstract fun viewPort(x: Int, y: Int, width: Int, height: Int)\n\n    abstract fun createShader(type: ShaderType): ShaderHandle\n\n    abstract fun shaderSource(shader: ShaderHandle, code: String)\n\n    abstract fun compileShader(shader: ShaderHandle)\n    fun compileShaderOrThrow(shader: ShaderHandle) {\n        compileShader(shader)\n        val compilationLog = glGetShaderInfoLog(shader)\n        if (!compilationLog.isNullOrBlank()) {\n            throw Exception(\"Failed to compile shader\\n${compilationLog}\")\n        }\n    }\n\n    abstract fun createProgram(): ProgramHandle\n\n    abstract fun attachShader(program: ProgramHandle, shader: ShaderHandle)\n\n    abstract fun linkProgram(program: ProgramHandle)\n    fun linkProgramOrThrow(program: ProgramHandle) {\n        linkProgram(program)\n        val linkLog = glGetProgramInfoLog(program)\n        if (!linkLog.isNullOrBlank()) {\n            throw Exception(\"Shader Compilation failed\\n${linkLog}\")\n        }\n    }\n\n    abstract fun useProgram(program: ProgramHandle)\n\n    abstract fun getUniformLocation(program: ProgramHandle, uniformName: String): UniformLocation\n    abstract fun glUniform1f(location: UniformLocation, x: Float)\n    abstract fun glUniform2f(location: UniformLocation, x: Float, y: Float)\n    abstract fun glUniform3f(location: UniformLocation, x: Float, y: Float, z: Float)\n    abstract fun glUniform4f(location: UniformLocation, x: Float, y: Float, z: Float, w: Float)\n\n    abstract fun glUniformMat2f(location: UniformLocation, data: FloatArray)\n    abstract fun glUniformMat3f(location: UniformLocation, data: FloatArray)\n    abstract fun glUniformMat4f(location: UniformLocation, data: FloatArray)\n\n    abstract fun glUniform1i(location: UniformLocation, v: Int)\n\n    fun glUniformMat2f(location: UniformLocation, m: Mat2) {\n        glUniformMat2f(location, m.data)\n    }\n\n    fun glUniformMat3f(location: UniformLocation, m: Mat3) {\n        glUniformMat3f(location, m.data)\n    }\n\n    fun glUniformMat4f(location: UniformLocation, m: Mat4) {\n        glUniformMat4f(location, m.data)\n    }\n\n    abstract fun getAttribLocation(program: ProgramHandle, attribName: String): AttribLocation\n    abstract fun vertexAttribPointer(\n        location: AttribLocation,\n        coordsPerVertex: Int,\n        type: DataType,\n        normalized: Boolean = false,\n        stride: Int = 0,\n        pointer: Int = 0\n    )\n\n    abstract fun createTexture(): TextureHandle\n    abstract fun texParameteri(target: Int, param: Int, value: Int)\n    abstract fun activeTexture(texture: Int)\n    abstract fun bindTexture(target: Int, handle: TextureHandle)\n\n    abstract fun createBuffer(): BufferHandle\n    abstract fun bufferData(target: BufferTarget, data: FloatBuffer, usage: BufferUsage)\n    abstract fun bindBuffer(target: BufferTarget, buffer: BufferHandle)\n\n    abstract fun drawArrays(mode: DrawMode, first: Int, countVerts: Int)\n\n    abstract fun glEnableVertexAttribArray(location: AttribLocation)\n\n    abstract fun glGetShaderInfoLog(shader: ShaderHandle): String\n\n    abstract fun glGetProgramInfoLog(program: ProgramHandle): String\n\n    abstract fun glGetError(): Int\n    fun checkErrors() {\n        if (errorChecking) {\n            val err = glGetError()\n            if (err != GL_NO_ERROR) {\n                val errStr = when (err) {\n                    GL_INVALID_ENUM -> \"GL_INVALID_ENUM\"\n                    GL_INVALID_VALUE -> \"GL_INVALID_VALUE\"\n                    GL_INVALID_OPERATION -> \"GL_INVALID_OPERATION\"\n                    GL_INVALID_FRAMEBUFFER_OPERATION -> \"GL_INVALID_FRAMEBUFFER_OPERATION\"\n                    GL_OUT_OF_MEMORY -> \"GL_OUT_OF_MEMORY\"\n                    else -> \"Unknown Error: ${err}\"\n                }\n                throw Exception(\"glGetError returned ${errStr}\")\n            }\n        }\n    }\n\n    abstract fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, offset: Int)\n    abstract suspend fun texImage2D(textureHandle: TextureHandle, path: String): Pair<Int, Int>\n\n    abstract fun texImage2D(textureHandle: TextureHandle, droppedImage: DroppedImage): Pair<Int, Int>\n\n    abstract fun cullFace(mode: Int)\n\n    abstract fun frontFace(mode: Int)\n\n    abstract fun blendFunc(sfactor: Int, dfactor: Int)\n\n    abstract fun enable(capability: Int)\n\n    abstract fun disable(capability: Int)\n\n    abstract fun scissor(x: Int, y: Int, w: Int, h: Int)\n\n    abstract fun genFramebuffer(): FramebufferHandle\n\n    abstract fun bindFramebuffer(target: Int, handle: FramebufferHandle)\n\n    abstract fun framebufferTexture2D(target: Int, attachment: Int, texTarget: Int, texture: TextureHandle, level: Int)\n\n    abstract fun readPixels(x: Int, y: Int, w: Int, h: Int, format: Int, type: Int, data: FloatArray)\n\n    abstract fun screenshot(path: String)\n\n    abstract fun checkFramebufferStatus(target: Int): Int\n}\n","package kmptemplate.gloo\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.gloo.GL.Companion.GL_TEXTURE0\nimport kmptemplate.gloo.GL.Companion.GL_TEXTURE_2D\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Vec2\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.Vec4\n\n\nclass Texture2D(val gl: GL, val handle: TextureHandle, val width: Int, val height: Int) {\n\n    fun bind(unit: Int) {\n        gl.activeTexture(GL_TEXTURE0 + unit)\n        gl.checkErrors()\n        gl.bindTexture(GL_TEXTURE_2D, handle)\n        gl.checkErrors()\n    }\n\n    //TODO make GLOO.createTexture(w,h) : Texture2D instead of this\n    fun createData() {\n        gl.texImage2D(GL_TEXTURE_2D, 0, GL.GL_RGBA, width, height, 0, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE, 0)\n        gl.checkErrors()\n    }\n\n    companion object {\n        val POWERS_OF_TWO = IntArray(16) { i -> 2 shl i }\n    }\n}\n\nclass Buffer(val gl: GL, val handle: BufferHandle) {\n\n    fun setData(floatBuffer: FloatBuffer, usage: BufferUsage = GL.STATIC_DRAW) {\n        bind()\n        PERF_TRACKER.trackGLbufferData(Float.SIZE_BYTES * floatBuffer.length())\n        gl.bufferData(GL.ARRAY_BUFFER, floatBuffer, usage)\n    }\n\n    fun bind() {\n        gl.bindBuffer(GL.ARRAY_BUFFER, handle)\n    }\n}\n\nclass VertexShader(val gl: GL, val handle: ShaderHandle) {\n\n}\n\nclass FragmentShader(val gl: GL, val handle: ShaderHandle) {\n\n}\n\n\nclass Uniform1f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(v: Float) {\n        program.gl.glUniform1f(location, v)\n    }\n}\n\nclass Uniform2f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(x: Float, y: Float) {\n        program.gl.glUniform2f(location, x, y)\n    }\n\n    fun set(v: Vec2) {\n        set(v.x, v.y)\n    }\n}\n\nclass Uniform3f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(x: Float, y: Float, z: Float) {\n        program.gl.glUniform3f(location, x, y, z)\n    }\n\n    fun set(v: Vec3) {\n        set(v.x, v.y, v.z)\n    }\n}\n\nclass Uniform4f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(x: Float, y: Float, z: Float, w: Float) {\n        program.gl.glUniform4f(location, x, y, z, w)\n    }\n\n    fun set(v: Vec4) {\n        set(v.x, v.y, v.z, v.w)\n    }\n}\n\nclass UniformMat4f(val program: ShaderProgram, val location: UniformLocation) {\n    fun set(mat: Mat4) {\n        program.gl.glUniformMat4f(location, mat)\n    }\n}\n\nclass UniformSampler2D(val program: ShaderProgram, val location: UniformLocation, val texUnit: Int) {\n\n    fun set(texture: Texture2D) {\n        texture.bind(texUnit)\n        program.gl.glUniform1i(location, texUnit)\n    }\n}\n\nclass Attrib1f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 1, GL.GL_FLOAT)\n    }\n\n    fun set(v: Float) {\n        TODO(\"not implemented yet (if it's even possible)\")\n    }\n}\n\nclass Attrib2f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 2, GL.GL_FLOAT)\n    }\n\n    fun set(vec: Vec2) {\n        TODO(\"not implemented yet (if it's even possible)\")\n    }\n}\n\nclass Attrib3f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 3, GL.GL_FLOAT)\n    }\n\n    fun set(vec: Vec3) {\n        TODO(\"not implemented yet (if it's even possible)\")\n    }\n}\n\nclass Attrib4f(val program: ShaderProgram, val location: AttribLocation) {\n    fun set(buf: Buffer) {\n        program.gl.glEnableVertexAttribArray(location)\n        program.gl.bindBuffer(GL.ARRAY_BUFFER, buf.handle)\n        program.gl.vertexAttribPointer(location, 4, GL.GL_FLOAT)\n    }\n\n    fun set(vec: Vec4) {\n        TODO(\"not implemented yet (if it's even possible)\")\n        //glVertexAttrib should be used\n    }\n}\n\nopen class ShaderProgram(val gl: GL, val handle: ProgramHandle, val vertexShader: VertexShader, val fragmentShader: FragmentShader) {\n\n    private var unit = 0\n    private val uniformToTextureUnit = mutableMapOf<String, Int>()\n\n    fun use() {\n        gl.useProgram(handle)\n    }\n\n    fun getUniform1f(name: String): Uniform1f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform1f(this, location)\n    }\n\n    fun getUniform2f(name: String): Uniform2f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform2f(this, location)\n    }\n\n    fun getUniform3f(name: String): Uniform3f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform3f(this, location)\n    }\n\n    fun getUniform4f(name: String): Uniform4f {\n        val location = gl.getUniformLocation(handle, name)\n        gl.checkErrors()\n        return Uniform4f(this, location)\n    }\n\n    fun getUniformMat4f(name: String): UniformMat4f {\n        val location = gl.getUniformLocation(handle, name)\n        return UniformMat4f(this, location)\n    }\n\n    fun getUniformSampler2D(name: String): UniformSampler2D {\n        val location = gl.getUniformLocation(handle, name)\n        val texUnit = uniformToTextureUnit[name] ?: unit++\n        return UniformSampler2D(this, location, texUnit)\n    }\n\n    fun getAttrib4f(name: String): Attrib4f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib4f(this, location)\n    }\n\n    fun getAttrib3f(name: String): Attrib3f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib3f(this, location)\n    }\n\n    fun getAttrib2f(name: String): Attrib2f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib2f(this, location)\n    }\n\n    fun getAttrib1f(name: String): Attrib1f {\n        val location = gl.getAttribLocation(handle, name)\n        return Attrib1f(this, location)\n    }\n\n}\n\nclass GLOO(val gl: GL) {\n\n    fun createBuffer(): Buffer {\n        val handle = gl.createBuffer()\n        return Buffer(gl, handle)\n    }\n\n    fun createVertexShader(code: String): VertexShader {\n        val handle = gl.createShader(GL.VERTEX_SHADER)\n        gl.shaderSource(handle, code)\n        gl.compileShader(handle)\n        val compilationLog = gl.glGetShaderInfoLog(handle)\n        if (compilationLog.isNotBlank()) {\n            throw Exception(\"Failed to compile vertex shader\\n${compilationLog}\")\n        }\n\n        return VertexShader(gl, handle)\n    }\n\n    fun createFragmentShader(code: String): FragmentShader {\n        val handle = gl.createShader(GL.FRAGMENT_SHADER)\n        gl.shaderSource(handle, code)\n        gl.compileShader(handle)\n        val compilationLog = gl.glGetShaderInfoLog(handle)\n        if (compilationLog.isNotBlank()) {\n            throw Exception(\"Failed to compile fragment shader\\n${compilationLog}\")\n        }\n        return FragmentShader(gl, handle)\n    }\n\n    fun createShaderProgram(vertexShaderCode: String, fragmentShaderCode: String): ShaderProgram {\n        val programHandle = gl.createProgram()\n\n        val vertesShader = createVertexShader(vertexShaderCode)\n        val fragmentShader = createFragmentShader(fragmentShaderCode)\n\n        gl.attachShader(programHandle, vertesShader.handle)\n        gl.attachShader(programHandle, fragmentShader.handle)\n\n        gl.linkProgram(programHandle)\n        val linkLog = gl.glGetProgramInfoLog(programHandle)\n        if (linkLog.isNotBlank()) {\n            throw Exception(\"Shader Compilation failed\\n${linkLog}\")\n        }\n\n        return ShaderProgram(gl, programHandle, vertesShader, fragmentShader)\n    }\n\n    suspend fun createTexture2D(path: String): Texture2D {\n        val textureHandle = gl.createTexture()\n        gl.bindTexture(GL_TEXTURE_2D, textureHandle)\n        val (w, h) = gl.texImage2D(textureHandle, path)\n\n        val texture = Texture2D(gl, textureHandle, w, h)\n        return texture\n    }\n\n    fun createTexture2D(droppedImage: DroppedImage): Texture2D {\n        val textureHandle = gl.createTexture()\n        gl.bindTexture(GL_TEXTURE_2D, textureHandle)\n        val (w, h) = gl.texImage2D(textureHandle, droppedImage)\n\n        val texture = Texture2D(gl, textureHandle, w, h)\n        return texture\n    }\n\n    fun createFramebuffer(): Framebuffer {\n        return Framebuffer(gl, gl.genFramebuffer())\n    }\n}\n\n","package kmptemplate.gloo\n\nimport kmptemplate.math.Ray\n\nclass PlainCamera : Cam() {\n    override fun recalc() {\n        viewMatrix.setIdentity()\n        projMatrix.setIdentity()\n    }\n\n    override fun ray(x: Float, y: Float): Ray {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun rayThrough(ray: Ray, x: Float, y: Float) {\n        TODO(\"Not yet implemented\")\n    }\n}","package kmptemplate.gloo\n\n/**\nRepresentation of [GL viewport](https://docs.gl/es2/glViewport)\n\nx, y - specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).\n\nw, h - specify the width and height of the viewport.\n */\ndata class Viewport(var w: Int, var h: Int, var x: Int = 0, var y: Int = 0) {\n\n    fun horizontal() = w > h\n    fun vertical() = !horizontal()\n\n    fun copyFrom(viewport: Viewport) {\n        this.w = viewport.w\n        this.h = viewport.h\n        this.x = viewport.x\n        this.y = viewport.y\n    }\n\n    companion object {\n        val FAKE_VIEWPORT = Viewport(100, 100)\n    }\n}\n\n","package kmptemplate.gloo.fonts\n\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.Texture2D\nimport kotlin.math.max\n\nclass SdfFontShader(gloo: GLOO) {\n    //language=GLSL\n    val prog = gloo.createShaderProgram(\n        \"\"\"\n        attribute vec3 aCoord;\n        attribute vec2 aTexCoord;\n        varying vec2 vTexCoord;\n        \n        uniform mat4 uModel;\n        uniform mat4 uView;\n        uniform mat4 uProj;\n        \n        void main(void)\n        {\n            vTexCoord = aTexCoord;\n            gl_Position =  uProj * uView * uModel * vec4(aCoord, 1.0);\n        }\n        \"\"\".trimIndent(),\n        \"\"\"\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform sampler2D uFontTexture;\n        uniform float uThreshold;// for example 0.2;\n        uniform float uWeight;// for example 0.4;\n        uniform vec4 uColor;\n        \n        varying vec2 vTexCoord;\n        \n        void main(void)\n        {\n//            float base = 1.0 - uWeight;\n//            float a = texture2D(uFontTexture, vTexCoord).a;\n//            vec4 res = uColor * smoothstep(base-uThreshold, base + uThreshold, a);\n            float distance = 1.0 - texture2D(uFontTexture, vTexCoord).a;\n            float a = 1.0 - smoothstep(uWeight, uWeight+uThreshold,distance);\n\n            gl_FragColor = vec4(uColor.rgb,a*uColor.a);\n        }\n        \"\"\".trimIndent()\n    )\n\n    val aCoord = prog.getAttrib3f(\"aCoord\")\n    val aTexCoord = prog.getAttrib2f(\"aTexCoord\")\n    val uFontTexture = prog.getUniformSampler2D(\"uFontTexture\")\n    val uThreshold = prog.getUniform1f(\"uThreshold\")\n    val uWeight = prog.getUniform1f(\"uWeight\")\n    val uColor = prog.getUniform4f(\"uColor\")\n    val uModel = prog.getUniformMat4f(\"uModel\")\n    val uProj = prog.getUniformMat4f(\"uProj\")\n    val uView = prog.getUniformMat4f(\"uView\")\n\n    inline fun use(code: SdfFontShader.() -> Unit) {\n        prog.use()\n        this.code()\n    }\n}\n\ndata class SdfChar(val id: Int, val x: Int, val y: Int, val width: Int, val height: Int, val xoffset: Int, val yoffset: Int, val xadvance: Int, val page: Int, val chnl: Int)\n\nclass SdfFont(val gloo: GLOO, val texture: Texture2D) {\n\n    val charmap = HashMap<Int, SdfChar>()\n\n    init {\n        loadCharMap()\n    }\n\n    private fun loadCharMap() {\n        val text = \"\"\"\ninfo face=\"Roboto Mono Light\" size=32 bold=0 italic=0 charset=\"\" unicode=0 stretchH=100 smooth=1 aa=1 padding=10,10,10,10 spacing=0,0\ncommon lineHeight=63 base=34 scaleW=512 scaleH=512 pages=1 packed=0\npage id=0 file=\"roboto.png\"\nchars count=163\nchar id=0       x=0    y=0    width=0    height=0    xoffset=-10  yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=10      x=0    y=0    width=0    height=0    xoffset=-10  yoffset=0    xadvance=20   page=0    chnl=0 \nchar id=32      x=0    y=0    width=0    height=0    xoffset=-10  yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=33      x=282  y=147  width=23   height=44   xoffset=-2   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=34      x=302  y=439  width=27   height=27   xoffset=-4   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=35      x=282  y=234  width=39   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=36      x=172  y=0    width=35   height=51   xoffset=-8   yoffset=-3   xadvance=39   page=0    chnl=0 \nchar id=37      x=132  y=102  width=39   height=45   xoffset=-10  yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=38      x=171  y=102  width=37   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=39      x=329  y=439  width=22   height=27   xoffset=-2   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=40      x=0    y=0    width=29   height=54   xoffset=-5   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=41      x=29   y=0    width=28   height=54   xoffset=-5   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=42      x=105  y=439  width=36   height=35   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=43      x=463  y=363  width=37   height=37   xoffset=-9   yoffset=5    xadvance=39   page=0    chnl=0 \nchar id=44      x=278  y=439  width=24   height=28   xoffset=-4   yoffset=21   xadvance=39   page=0    chnl=0 \nchar id=45      x=440  y=439  width=33   height=22   xoffset=-7   yoffset=13   xadvance=39   page=0    chnl=0 \nchar id=46      x=416  y=439  width=24   height=24   xoffset=-2   yoffset=21   xadvance=39   page=0    chnl=0 \nchar id=47      x=68   y=102  width=32   height=45   xoffset=-6   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=48      x=0    y=102  width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=49      x=180  y=234  width=29   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=50      x=176  y=147  width=36   height=44   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=51      x=395  y=54   width=35   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=52      x=209  y=234  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=53      x=212  y=147  width=35   height=44   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=54      x=247  y=147  width=35   height=44   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=55      x=246  y=234  width=36   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=56      x=430  y=54   width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=57      x=466  y=54   width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=58      x=485  y=320  width=24   height=38   xoffset=-1   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=59      x=212  y=320  width=25   height=42   xoffset=-2   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=60      x=141  y=439  width=34   height=34   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=61      x=243  y=439  width=35   height=29   xoffset=-8   yoffset=9    xadvance=39   page=0    chnl=0 \nchar id=62      x=175  y=439  width=35   height=34   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=63      x=35   y=102  width=33   height=45   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=64      x=305  y=147  width=39   height=44   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=65      x=420  y=147  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=66      x=458  y=147  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=67      x=73   y=54   width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=68      x=0    y=191  width=36   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=69      x=36   y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=70      x=70   y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=71      x=110  y=54   width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=72      x=104  y=191  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=73      x=139  y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=74      x=460  y=102  width=35   height=44   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=75      x=173  y=191  width=36   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=76      x=209  y=191  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=77      x=243  y=191  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=78      x=278  y=191  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=79      x=147  y=54   width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=80      x=313  y=191  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=81      x=0    y=54   width=37   height=48   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=82      x=348  y=191  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=83      x=184  y=54   width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=84      x=383  y=191  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=85      x=0    y=147  width=35   height=44   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=86      x=420  y=191  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=87      x=457  y=191  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=88      x=0    y=234  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=89      x=38   y=234  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=90      x=75   y=234  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=91      x=119  y=0    width=26   height=51   xoffset=-3   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=92      x=100  y=102  width=32   height=45   xoffset=-6   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=93      x=145  y=0    width=27   height=51   xoffset=-4   yoffset=-2   xadvance=39   page=0    chnl=0 \nchar id=94      x=210  y=439  width=33   height=33   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=95      x=473  y=439  width=35   height=22   xoffset=-8   yoffset=24   xadvance=39   page=0    chnl=0 \nchar id=96      x=390  y=439  width=26   height=25   xoffset=-3   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=97      x=274  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=98      x=476  y=0    width=34   height=45   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=99      x=309  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=100     x=220  y=54   width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=101     x=344  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=102     x=255  y=54   width=36   height=45   xoffset=-8   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=103     x=291  y=54   width=35   height=45   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=104     x=35   y=147  width=34   height=44   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=105     x=110  y=234  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=106     x=243  y=0    width=31   height=50   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=107     x=69   y=147  width=35   height=44   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=108     x=104  y=147  width=35   height=44   xoffset=-7   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=109     x=178  y=363  width=37   height=38   xoffset=-9   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=110     x=215  y=363  width=34   height=38   xoffset=-7   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=111     x=379  y=320  width=36   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=112     x=326  y=54   width=34   height=45   xoffset=-7   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=113     x=360  y=54   width=35   height=45   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=114     x=249  y=363  width=32   height=38   xoffset=-5   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=115     x=415  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=116     x=145  y=234  width=35   height=43   xoffset=-8   yoffset=2    xadvance=39   page=0    chnl=0 \nchar id=117     x=281  y=363  width=34   height=38   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=118     x=315  y=363  width=37   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=119     x=352  y=363  width=39   height=37   xoffset=-10  yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=120     x=391  y=363  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=121     x=139  y=147  width=37   height=44   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=122     x=427  y=363  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=123     x=57   y=0    width=31   height=52   xoffset=-5   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=124     x=274  y=0    width=23   height=49   xoffset=-2   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=125     x=88   y=0    width=31   height=52   xoffset=-5   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=126     x=351  y=439  width=39   height=27   xoffset=-10  yoffset=11   xadvance=39   page=0    chnl=0 \nchar id=1025    x=334  y=0    width=34   height=49   xoffset=-7   yoffset=-5   xadvance=39   page=0    chnl=0 \nchar id=1040    x=321  y=234  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1041    x=359  y=234  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1042    x=394  y=234  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1043    x=429  y=234  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1044    x=297  y=0    width=37   height=49   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1045    x=464  y=234  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1046    x=0    y=277  width=39   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1047    x=208  y=102  width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1048    x=39   y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1049    x=368  y=0    width=35   height=49   xoffset=-8   yoffset=-5   xadvance=39   page=0    chnl=0 \nchar id=1050    x=74   y=277  width=36   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1051    x=110  y=277  width=37   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1052    x=147  y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1053    x=182  y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1054    x=245  y=102  width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1055    x=217  y=277  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1056    x=252  y=277  width=35   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1057    x=282  y=102  width=37   height=45   xoffset=-9   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1058    x=287  y=277  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1059    x=344  y=147  width=39   height=44   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1060    x=324  y=277  width=37   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1061    x=361  y=277  width=38   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1062    x=403  y=0    width=36   height=49   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1063    x=399  y=277  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1064    x=433  y=277  width=36   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1065    x=439  y=0    width=37   height=49   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1066    x=469  y=277  width=38   height=43   xoffset=-10  yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1067    x=0    y=320  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1068    x=35   y=320  width=34   height=43   xoffset=-7   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1069    x=319  y=102  width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1070    x=355  y=102  width=36   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1071    x=69   y=320  width=36   height=43   xoffset=-9   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1072    x=450  y=320  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1073    x=37   y=54   width=36   height=46   xoffset=-8   yoffset=-1   xadvance=39   page=0    chnl=0 \nchar id=1074    x=0    y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1075    x=35   y=402  width=34   height=37   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1076    x=237  y=320  width=37   height=42   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1077    x=0    y=363  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1078    x=69   y=402  width=39   height=37   xoffset=-10  yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1079    x=35   y=363  width=36   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1080    x=108  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1081    x=105  y=320  width=35   height=43   xoffset=-8   yoffset=1    xadvance=39   page=0    chnl=0 \nchar id=1082    x=143  y=402  width=36   height=37   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1083    x=179  y=402  width=36   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1084    x=215  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1085    x=250  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1086    x=379  y=320  width=36   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1087    x=285  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1088    x=426  y=102  width=34   height=45   xoffset=-7   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1089    x=71   y=363  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1090    x=320  y=402  width=37   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1091    x=383  y=147  width=37   height=44   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1092    x=207  y=0    width=36   height=51   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \nchar id=1093    x=357  y=402  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1094    x=140  y=320  width=35   height=43   xoffset=-7   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1095    x=393  y=402  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1096    x=428  y=402  width=36   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1097    x=175  y=320  width=37   height=43   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1098    x=464  y=402  width=38   height=37   xoffset=-10  yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1099    x=0    y=439  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1100    x=35   y=439  width=35   height=37   xoffset=-8   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1101    x=106  y=363  width=35   height=39   xoffset=-8   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1102    x=141  y=363  width=37   height=39   xoffset=-9   yoffset=6    xadvance=39   page=0    chnl=0 \nchar id=1103    x=70   y=439  width=35   height=37   xoffset=-9   yoffset=7    xadvance=39   page=0    chnl=0 \nchar id=1105    x=391  y=102  width=35   height=45   xoffset=-8   yoffset=0    xadvance=39   page=0    chnl=0 \n\"\"\".trimIndent()\n\n        for (line in text.lineSequence()) {\n            if (line.startsWith(\"char \")) {\n                val props = line.split(\" \").filter { it.isNotBlank() }\n\n                var id = 0\n                var x = 0\n                var y = 0\n                var width = 0\n                var height = 0\n                var xoffset = 0\n                var yoffset = 0\n                var xadvance = 0\n                var page = 0\n                var chnl = 0\n                for (prop in props) {\n                    if (prop.startsWith(\"id=\")) {\n                        id = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"x=\")) {\n                        x = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"y=\")) {\n                        y = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"width=\")) {\n                        width = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"height=\")) {\n                        height = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"xoffset=\")) {\n                        xoffset = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"yoffset=\")) {\n                        yoffset = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"xadvance=\")) {\n                        xadvance = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"page=\")) {\n                        page = prop.substringAfter('=').toInt()\n                    }\n\n                    if (prop.startsWith(\"chnl=\")) {\n                        chnl = prop.substringAfter('=').toInt()\n                    }\n                }\n\n                charmap.put(id, SdfChar(id, x, y, width, height, xoffset, yoffset, xadvance, page, chnl))\n            }\n        }\n    }\n\n}\n\nfun calcWidth(btnText: String, h: Float, compress: Float = 1f): Float {\n    var maxCountInLine = 0\n    var countInLine = 0\n    for (ch in btnText) {\n        if (ch == '\\n') {\n            countInLine = 0\n        } else {\n            countInLine++\n        }\n        maxCountInLine = max(maxCountInLine, countInLine)\n    }\n    return 0.75f * ((maxCountInLine - 1) * h * compress + h)\n}\n\nfun calcHeight(btnText: String, h: Float): Float {\n    return (btnText.count { it == '\\n' } + 1) * h\n}","package kmptemplate.gloo.primitives\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.dist\nimport kmptemplate.math.distSq\nimport kmptemplate.math.dot\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.math.setMult\nimport kmptemplate.math.setMultFree\nimport kmptemplate.math.setNaN\nimport kmptemplate.math.sq\nimport kotlin.math.min\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\n\nprivate val e1_tmp_rayTriangleIntersect = Vec3()\nprivate val e2_tmp_rayTriangleIntersect = Vec3()\nprivate val pvec_tmp_rayTriangleIntersect = Vec3()\nprivate val tvec_tmp_rayTriangleIntersect = Vec3()\nprivate val qvec_tmp_rayTriangleIntersect = Vec3()\nprivate val dir_tmp_rayTriangleIntersect = Vec3()\nprivate val res_tmp_rayTriangleIntersect = Vec3()\n\n//https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9C%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D0%B0_%E2%80%94_%D0%A2%D1%80%D1%83%D0%BC%D0%B1%D0%BE%D1%80%D0%B0\nfun Vec3.rayTriangleIntersect(ray: Ray, v0: Vec3, v1: Vec3, v2: Vec3) {\n    val EPS = 1e-8f\n\n    val e1 = e1_tmp_rayTriangleIntersect\n    val e2 = e2_tmp_rayTriangleIntersect\n    val pvec = pvec_tmp_rayTriangleIntersect\n    val tvec = tvec_tmp_rayTriangleIntersect\n    val qvec = qvec_tmp_rayTriangleIntersect\n\n    val dir = dir_tmp_rayTriangleIntersect\n    dir.set(ray.dir)\n\n    val res = res_tmp_rayTriangleIntersect\n\n    e1.setDiff(v1, v0)\n    e2.setDiff(v2, v0)\n\n    // Calculating normal to plane\n    pvec.setCross(ray.dir, e2)\n    val det = dot(e1, pvec)\n\n    // ray is parallel to plane\n    if (det < EPS && det > -EPS) {\n        setNaN()\n        return\n    }\n\n    val invDet = 1.0f / det\n\n    tvec.setDiff(ray.origin, v0);\n    val u = dot(tvec, pvec) * invDet;\n    if (u < 0.0f || u > 1.0f) {\n        setNaN()\n        return\n    }\n\n    qvec.setCross(tvec, e1)\n    val v = dot(ray.dir, qvec) * invDet;\n    if (v < 0.0f || u + v > 1.0f) {\n        setNaN()\n        return\n    }\n\n    dir.normalize()\n    dir *= (dot(e2, qvec) * invDet)\n\n    res.setSum(ray.origin, dir)\n\n    set(res)\n}\n\n/*semi-optimized version of intersection, non transforming model itself - just transforming a ray with inverse transformation */\n//fun intersectSemiOptimized(ray: Ray, mesh: Mesh, modelMat: Mat4): Vec3 {\n//    val M = Mat4()\n//\n//    M.assign(modelMat)\n//    val invM = inversed(Mat4(), M)\n//\n//    val ro = Vec3()\n//    val rd = Vec3()\n//\n//    ro.setMult(invM, ray.origin)\n//\n//    rd.setMultFree(invM, ray.dir)\n//    rd.normalize()\n//\n//    val vertsCount = mesh.posBuf.length() / 3\n//    val trisCount = vertsCount / 3\n//\n//    val EPS = 1e-8f\n//\n//    val e1 = Vec3(0f, 0f, 0f)\n//    val e2 = Vec3(0f, 0f, 0f)\n//\n//    val pvec = Vec3(0f, 0f, 0f)\n//    val tvec = Vec3(0f, 0f, 0f)\n//    val qvec = Vec3(0f, 0f, 0f)\n//\n//    val v0 = Vec3()\n//    val v1 = Vec3()\n//    val v2 = Vec3()\n//\n//    val res = Vec3()\n//    res.setNaN()\n//\n//    for (tri in 0 until trisCount) {\n//        v0.x = mesh.posBuf[tri * 9 + 0]\n//        v0.y = mesh.posBuf[tri * 9 + 1]\n//        v0.z = mesh.posBuf[tri * 9 + 2]\n//\n//        v1.x = mesh.posBuf[tri * 9 + 3]\n//        v1.y = mesh.posBuf[tri * 9 + 4]\n//        v1.z = mesh.posBuf[tri * 9 + 5]\n//\n//        v2.x = mesh.posBuf[tri * 9 + 6]\n//        v2.y = mesh.posBuf[tri * 9 + 7]\n//        v2.z = mesh.posBuf[tri * 9 + 8]\n//\n//        e1.x = v1.x - v0.x\n//        e1.y = v1.y - v0.y\n//        e1.z = v1.z - v0.z\n//\n//        e2.x = v2.x - v0.x\n//        e2.y = v2.y - v0.y\n//        e2.z = v2.z - v0.z\n//\n//        pvec.setCross(rd, e2)\n//        val det = dot(e1, pvec)\n//\n//        // Ray is parallel to plane\n//        if (det < EPS && det > -EPS) {\n//            continue\n//        }\n//\n//        val inv_det = 1.0f / det\n//\n//        tvec.x = ro.x - v0.x\n//        tvec.y = ro.y - v0.y\n//        tvec.z = ro.z - v0.z\n//\n//        val u = dot(tvec, pvec) * inv_det;\n//        if (u < 0.0f || u > 1.0f) {\n//            continue\n//        }\n//\n//        qvec.setCross(tvec, e1)\n//\n//        val v = dot(rd, qvec) * inv_det;\n//        if (v < 0.0f || u + v > 1.0f) {\n//            continue\n//        }\n//\n//        res.set(rd)\n//        res.normalize()\n//        res *= (dot(e2, qvec) * inv_det)\n//        res += ro\n//\n//        res.setMult(M, res)\n//        return res\n//    }\n//\n//    return res\n//}\n\nfun min(a: Float, b: Float, c: Float) = min(min(a, b), c)\nfun max(a: Float, b: Float, c: Float) = max(max(a, b), c)\n\nclass AABB {\n    val min = Vec3()\n    val max = Vec3()\n\n    fun of(v1: Vec3, v2: Vec3, v3: Vec3) {\n        min.set(min(v1.x, v2.x, v3.x), min(v1.y, v2.y, v3.y), min(v1.z, v2.z, v3.z))\n        max.set(max(v1.x, v2.x, v3.x), max(v1.y, v2.y, v3.y), max(v1.z, v2.z, v3.z))\n    }\n\n    fun of(v1: Vec3, v2: Vec3) {\n        min.set(min(v1.x, v2.x), min(v1.y, v2.y), min(v1.z, v2.z))\n        max.set(max(v1.x, v2.x), max(v1.y, v2.y), max(v1.z, v2.z))\n    }\n\n    fun of(ray: Ray) = with(ray) {\n        min.set(min(origin.x, origin.x + dir.x), min(origin.y, origin.y + dir.y), min(origin.z, origin.z + dir.z))\n        max.set(max(origin.x, origin.x + dir.x), max(origin.y, origin.y + dir.y), max(origin.z, origin.z + dir.z))\n    }\n\n    override fun toString() = \"AABB (${min.x}, ${min.y}, ${min.z}) - (${max.x}, ${max.y}, ${max.z})\"\n}\n\nfun intersects(a: AABB, b: AABB): Boolean {\n    if (a.max[0] < b.min[0] || a.min[0] > b.max[0]) return false;\n    if (a.max[1] < b.min[1] || a.min[1] > b.max[1]) return false;\n    if (a.max[2] < b.min[2] || a.min[2] > b.max[2]) return false;\n    return true\n}\n\n/*non optimized version - intersecting ray with transformed entity */\nfun intersectNonOptimizedNearest(ray: Ray, mesh: Mesh, modelMat: Mat4, maxDist: Float = 1E6f): Vec3 {\n\n    val M = Mat4()\n    M.assign(modelMat)\n\n    val nearestIntersection = Vec3()\n    nearestIntersection.setNaN()\n    var nearestDist = 1E20f\n\n    val vertsCount = mesh.posBuf.length() / 3\n    val trisCount = vertsCount / 3\n\n    val EPS = 1e-8f\n\n    val e1 = Vec3(0f, 0f, 0f)\n    val e2 = Vec3(0f, 0f, 0f)\n\n    val pvec = Vec3(0f, 0f, 0f)\n    val tvec = Vec3(0f, 0f, 0f)\n    val qvec = Vec3(0f, 0f, 0f)\n\n    val dirNormalized = Vec3()\n    dirNormalized.set(ray.dir)\n    dirNormalized.normalize()\n\n    val v0 = Vec3()\n    val v1 = Vec3()\n    val v2 = Vec3()\n\n    val res = Vec3()\n    res.setZero()\n\n    val triAABB = AABB()\n    val rayAABB = AABB()\n\n    for (tri in 0 until trisCount) {\n\n        v0.x = mesh.posBuf[tri * 9 + 0]\n        v0.y = mesh.posBuf[tri * 9 + 1]\n        v0.z = mesh.posBuf[tri * 9 + 2]\n\n        v1.x = mesh.posBuf[tri * 9 + 3]\n        v1.y = mesh.posBuf[tri * 9 + 4]\n        v1.z = mesh.posBuf[tri * 9 + 5]\n\n        v2.x = mesh.posBuf[tri * 9 + 6]\n        v2.y = mesh.posBuf[tri * 9 + 7]\n        v2.z = mesh.posBuf[tri * 9 + 8]\n\n        v0.setMult(M, v0)\n        v1.setMult(M, v1)\n        v2.setMult(M, v2)\n\n        triAABB.of(v0, v1, v2)\n        rayAABB.of(ray)\n        PERF_TRACKER.track(\"earlyRT\")\n//        if (!intersects(triAABB, rayAABB)) continue\n//        PERF_TRACKER.track(\"lateRT\")\n\n//        println(v0)\n//        println(v1)\n//        println(v2)\n\n        e1.setDiff(v1, v0)\n        e2.setDiff(v2, v0)\n\n        pvec.setCross(dirNormalized, e2)\n        val det = dot(e1, pvec)\n\n        //   \n        if (det < EPS && det > -EPS) {\n            res.setNaN()\n            continue\n        }\n\n        val inv_det = 1.0f / det\n\n        tvec.setDiff(ray.origin, v0)\n\n        val u = dot(tvec, pvec) * inv_det;\n        if (u < 0.0f || u > 1.0f) {\n            res.setNaN()\n            continue\n        }\n\n        qvec.setCross(tvec, e1)\n\n        val v = dot(dirNormalized, qvec) * inv_det;\n        if (v < 0.0f || u + v > 1.0f) {\n            res.setNaN()\n            continue\n        }\n\n        res.set(dirNormalized)\n        res *= (dot(e2, qvec) * inv_det)\n        res += ray.origin\n\n        if (res.isNotNaN() && distSq(ray.origin, res) <= ray.dir.normSq()) {\n\n//            if (!intersects(triAABB, rayAABB)) {\n//                println(\"why aabb not working here\")\n//                val iii = intersects(triAABB, rayAABB)\n//            }\n\n            val d = dist(ray.origin, res)\n            if (d < nearestDist) {\n                nearestIntersection.set(res)\n                nearestDist = d\n            }\n        }\n    }\n\n//    if(nearestIntersection.isNotNaN()) {\n//        val inters = intersects(triAABB, rayAABB)\n//        println(inters)\n//    }\n\n\n    return nearestIntersection\n}\n\nclass Sphere(var r: Float = 0.03f, val pos: Vec3 = Vec3(0.0f, 0.0f, 0.0f)) {\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    override fun toString(): String {\n        return \"Sphere r=${r}, pos=${pos}\"\n    }\n}\n\nclass Plane(val origin: Vec3, val a: Vec3, val b: Vec3) {\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val n = Vec3().apply { setCross(a, b) }\n}\n\n\nprivate val origin_pos_tmp_intersect = Vec3()\nfun Vec3.intersect(ray: Ray, sphere: Sphere) {\n\n    val a = ray.dir.normSq()\n\n    val origin_pos = origin_pos_tmp_intersect\n    origin_pos.setDiff(ray.origin, sphere.pos)\n\n    val b = 2.0f * dot(ray.dir, origin_pos)\n    val c = distSq(ray.origin, sphere.pos) - sq(sphere.r)\n\n    val d = sq(b) - 4.0f * a * c\n\n    if (d >= 0.0f) {\n        val t = (-b - sqrt(d)) / 2.0f / a\n\n        this.setZero()\n        this.add(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        setNaN()\n    }\n}\n\nprivate val origin_pos_tmp_intersect2 = Vec3()\n\nfun Vec3.intersect(ray: Ray, sphere: Sphere, mat: Mat4) {\n\n    val a = ray.dir.normSq()\n\n    val origin_pos = origin_pos_tmp_intersect2\n\n    val r00 = Vec3()\n    r00.setMultFree(mat, Vec3(sphere.r, 0f, 0f))\n    val r = r00.norm()\n\n    val p = Vec3()\n\n    p.setMult(mat, sphere.pos)\n    origin_pos.setDiff(ray.origin, p)\n\n    val b = 2.0f * dot(ray.dir, origin_pos)\n    val c = distSq(ray.origin, p) - sq(r)\n\n    val d = sq(b) - 4.0f * a * c\n\n    if (d >= 0.0f) {\n        val t = (-b - sqrt(d)) / 2.0f / a\n\n        this.setZero()\n        this.add(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        setNaN()\n    }\n\n}\n\nfun Vec3.intersect(ray: Ray, plane: Plane) {\n    val rox = ray.origin.x\n    val roy = ray.origin.y\n    val roz = ray.origin.z\n\n    val rdx = ray.dir.x\n    val rdy = ray.dir.y\n    val rdz = ray.dir.z\n\n    val pox = plane.origin.x\n    val poy = plane.origin.y\n    val poz = plane.origin.z\n\n    val pax = plane.a.x\n    val pay = plane.a.y\n    val paz = plane.a.z\n\n    val pbx = plane.b.x\n    val pby = plane.b.y\n    val pbz = plane.b.z\n\n    val t = -(pbx * (pay * (roz - poz) - paz * roy + paz * poy) + pax * (pby * (poz - roz) + pbz * roy - pbz * poy) + (paz * pby - pay * pbz) * rox + (pay * pbz - paz * pby) * pox) /\n            (pax * (pbz * rdy - pby * rdz) + pbx * (pay * rdz - paz * rdy) + (paz * pby - pay * pbz) * rdx)\n\n\n    if (t >= 0.0f) {\n        this.set(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        return setNaN()\n    }\n}\n\nfun Vec3.intersect(ray: Ray, plane: Plane, m: Mat4) {\n    val rox = ray.origin.x\n    val roy = ray.origin.y\n    val roz = ray.origin.z\n\n    val rdx = ray.dir.x\n    val rdy = ray.dir.y\n    val rdz = ray.dir.z\n\n    val po = Vec3()\n    po.setMult(m, plane.origin)\n\n    val pa = Vec3()\n    pa.setMultFree(m, plane.a)\n\n    val pb = Vec3()\n    pb.setMultFree(m, plane.b)\n\n    val pox = po.x\n    val poy = po.y\n    val poz = po.z\n\n    val pax = pa.x\n    val pay = pa.y\n    val paz = pa.z\n\n    val pbx = pb.x\n    val pby = pb.y\n    val pbz = pb.z\n\n    val t = -(pbx * (pay * (roz - poz) - paz * roy + paz * poy) + pax * (pby * (poz - roz) + pbz * roy - pbz * poy) + (paz * pby - pay * pbz) * rox + (pay * pbz - paz * pby) * pox) /\n            (pax * (pbz * rdy - pby * rdz) + pbx * (pay * rdz - paz * rdy) + (paz * pby - pay * pbz) * rdx)\n\n    if (t >= 0.0f) {\n        this.set(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        return setNaN()\n    }\n}\n\nfun Vec3.intersect3(ray: Ray, plane: Plane) {\n\n    val rox = ray.origin.x\n    val roy = ray.origin.y\n    val roz = ray.origin.z\n\n    val rdx = ray.dir.x\n    val rdy = ray.dir.y\n    val rdz = ray.dir.z\n\n    val pox = plane.origin.x\n    val poy = plane.origin.y\n    val poz = plane.origin.z\n\n    val pax = plane.a.x\n    val pay = plane.a.y\n    val paz = plane.a.z\n\n    val pbx = plane.b.x\n    val pby = plane.b.y\n    val pbz = plane.b.z\n\n    val t = -(pbx * (pay * (roz - poz) - paz * roy + paz * poy) + pax * (pby * (poz - roz) + pbz * roy - pbz * poy) + (paz * pby - pay * pbz) * rox + (pay * pbz - paz * pby) * pox) /\n            (pax * (pbz * rdy - pby * rdz) + pbx * (pay * rdz - paz * rdy) + (paz * pby - pay * pbz) * rdx)\n\n\n    if (t >= 0.0f) {\n        this.set(ray.origin)\n        this.addMult(t, ray.dir)\n    } else {\n        return setNaN()\n    }\n}\n","package kmptemplate.input\n\nimport kmptemplate.ui.UiEvent\n\nexpect class Key\n\nexpect val KEY_Q: Key\nexpect val KEY_W: Key\nexpect val KEY_E: Key\nexpect val KEY_R: Key\nexpect val KEY_T: Key\nexpect val KEY_Y: Key\nexpect val KEY_U: Key\nexpect val KEY_I: Key\nexpect val KEY_O: Key\nexpect val KEY_P: Key\n\nexpect val KEY_A: Key\nexpect val KEY_S: Key\nexpect val KEY_D: Key\nexpect val KEY_F: Key\nexpect val KEY_G: Key\nexpect val KEY_H: Key\nexpect val KEY_J: Key\nexpect val KEY_K: Key\nexpect val KEY_L: Key\n\nexpect val KEY_Z: Key\nexpect val KEY_X: Key\nexpect val KEY_C: Key\nexpect val KEY_V: Key\nexpect val KEY_B: Key\nexpect val KEY_N: Key\nexpect val KEY_M: Key\n\nexpect val KEY_ARROW_UP: Key\nexpect val KEY_ARROW_DOWN: Key\nexpect val KEY_ARROW_LEFT: Key\nexpect val KEY_ARROW_RIGHT: Key\n\nexpect val KEY_ENTER: Key\nexpect val KEY_SPACE: Key\nexpect val KEY_BACKSPACE: Key\n\n\nabstract class Keyboard {\n\n    companion object {\n        val ALL_KEYS = arrayOf(\n            KEY_Q,\n            KEY_W,\n            KEY_E,\n            KEY_R,\n            KEY_T,\n            KEY_Y,\n            KEY_U,\n            KEY_I,\n            KEY_O,\n            KEY_P,\n\n            KEY_A,\n            KEY_S,\n            KEY_D,\n            KEY_F,\n            KEY_G,\n            KEY_H,\n            KEY_J,\n            KEY_K,\n            KEY_L,\n\n            KEY_Z,\n            KEY_X,\n            KEY_C,\n            KEY_V,\n            KEY_B,\n            KEY_N,\n            KEY_M,\n\n            KEY_ARROW_UP,\n            KEY_ARROW_DOWN,\n            KEY_ARROW_LEFT,\n            KEY_ARROW_RIGHT,\n\n            KEY_ENTER,\n            KEY_SPACE,\n            KEY_BACKSPACE\n        )\n    }\n\n    abstract fun pressed(key: Key): Boolean\n    abstract fun justPressed(key: Key): Boolean\n    abstract fun justReleased(key: Key): Boolean\n    abstract fun pollKeyboard()\n\n    abstract fun pollMouse()\n    abstract fun mousePressed(btn: Int): Boolean\n    abstract fun mouseCoords(): Pair<Double, Double>\n    abstract fun mouseJustPressed(btn: Int): Boolean\n    abstract fun mouseJustReleased(btn: Int): Boolean\n\n    abstract fun anyKeyJustPressed(): Boolean\n\n    val events = ArrayList<UiEvent>()\n    fun notifyEvent(event: UiEvent) {\n        events.add(event)\n    }\n\n    fun forEvents(codeblock: (UiEvent) -> Unit) {\n        for (event in events) {\n            if (!event.consumed) {\n                codeblock(event)\n            }\n        }\n    }\n\n    fun forTouchedPointers(codeblock: (x: Float, y: Float, pid: Int) -> Unit) {\n\n        var countTouched = 0\n        for (pointerId in coordX.indices) {\n            if (!coordX[pointerId].isNaN()) {\n                codeblock(coordX[pointerId], coordY[pointerId], pointerId)\n//                print(\"touched ${pointerId}\")\n                countTouched++\n            }\n        }\n\n//        if (countTouched > 0) {\n//            println()\n//        }\n    }\n\n    private var coordX = FloatArray(10) { Float.NaN }\n    private var coordY = FloatArray(10) { Float.NaN }\n\n    private var mouseX = 0f\n    private var mouseY = 0f\n\n    fun translateEventsToState() {\n        forEvents { event ->\n\n//            println(event)\n//            G_CONSOLE.println { event.toString() }\n\n            if (event.type == UiEvent.MOUSE_DOWN) {\n                mouseX = event.x\n                mouseY = event.y\n            }\n\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                mouseX = event.x\n                mouseY = event.y\n            }\n\n            if (event.type == UiEvent.MOUSE_UP) {\n                mouseX = event.x\n                mouseY = event.y\n            }\n\n            if (event.type == UiEvent.TOUCH_DOWN) {\n                coordX[event.pointerId] = event.x\n                coordY[event.pointerId] = event.y\n            }\n\n            if (event.type == UiEvent.POINTER_DOWN) {\n                coordX[event.pointerId] = event.x\n                coordY[event.pointerId] = event.y\n            }\n\n            if (event.type == UiEvent.POINTER_MOVE) {\n                coordX[event.pointerId] = event.x\n                coordY[event.pointerId] = event.y\n            }\n\n            if (event.type == UiEvent.POINTER_UP) {\n                coordX[event.pointerId] = Float.NaN\n                coordY[event.pointerId] = Float.NaN\n            }\n\n            if (event.type == UiEvent.TOUCH_UP) {\n                coordX[event.pointerId] = Float.NaN\n                coordY[event.pointerId] = Float.NaN\n\n                if (coordX.any { !it.isNaN() } || coordY.any { !it.isNaN() }) {\n                    println(\"warning: TOUCH_UP event but some pointer coords existing\")\n                }\n            }\n        }\n    }\n\n    fun dumpState() {\n        for (i in 0 until coordX.size) {\n            print(\"coords: \")\n            print(coordX[i])\n            print(\",\")\n            print(coordY[i])\n            print(\"    \")\n        }\n        println()\n    }\n\n    fun clearEvents() {\n        events.clear()\n    }\n}\n",null,"package kmptemplate.loading\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.launch\n\ninterface Loader {\n    suspend fun add(codeblock: suspend () -> Unit)\n    suspend fun join()\n}\n\nclass ParallelLoader(val scope: CoroutineScope) : Loader {\n    private val jobs = ArrayList<Job>()\n    override suspend fun add(codeblock: suspend () -> Unit) {\n        val job = scope.launch {\n            codeblock()\n        }\n\n        jobs.add(job)\n    }\n\n    override suspend fun join() {\n        for (job in jobs) {\n            job.join()\n        }\n    }\n}\n\nclass SequentialLoader : Loader {\n    val jobs = ArrayList<Job>()\n    override suspend fun add(codeblock: suspend () -> Unit) {\n        codeblock()\n    }\n\n    override suspend fun join() {\n    }\n}","package kmptemplate.math\n\nimport kotlin.math.cos\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sin\n\nconst val F_PI = 3.1415927f\nconst val F_2PI = 6.2831855f\nconst val F_PI_DIV2 = 1.5707964f\n\nfun clamp(t: Float, a: Float, b: Float): Float {\n    val min = min(a, b)\n    val max = max(a, b)\n\n    return if (t < min) min\n    else if (t > max) max\n    else t\n}\n\nfun smoothStep(t: Float, edge0: Float, edge1: Float): Float {\n    val x = clamp((t - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n    return x * x * (3f - 2f * x);\n}\n\nfun smoothStep(t: Float, t1: Float, v1: Float, t2: Float, v2: Float): Float {\n    val x = clamp((t - t1) / (t2 - t1), 0.0f, 1.0f)\n    val q = x * x * (3f - 2f * x)\n    return v1 + (v2 - v1) * q\n}\n\nfun sqPeak(t: Float) = max(0f, 1f - sq(t - 1f))\n\nfun sqPeak(t: Float, t0: Float, w: Float, a: Float) = a * sqPeak((t - t0) * 2.0f / w)\n\nfun sq(t: Float) = t * t\n\nfun qd(t: Float) = sq(sq(t))\n\nfun degToRad(deg: Float) = deg * F_PI / 180f\n\nfun sn(t: Double): Double {\n    return 0.5 * sin(t) + 0.5\n}\n\nfun cs(t: Double): Double {\n    return 0.5 * cos(t) + 0.5\n}\n\nfun cs(t: Float): Float {\n    return 0.5f * cos(t) + 0.5f\n}\n\nfun sn(t: Float): Float {\n    return 0.5f * sin(t) + 0.5f\n}\n\n\nfun frac(t: Double): Double {\n    return t % 1.0\n}\n\nfun frac(t: Float): Float {\n    return t % 1f\n}\n\ninline fun Float.linearMap(from1: Float, from2: Float, to1: Float, to2: Float): Float {\n    return to1 + (to2 - to1) * (this - from1) / (from2 - from1)\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.sqrt\nimport kotlin.math.tan\n\nclass Mat4 {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    companion object {\n        const val SZ = 4\n\n        val IDENT = Mat4().apply { setIdentity() }\n    }\n\n    val data = FloatArray(SZ * SZ)\n\n    fun assign(m: Mat4) {\n        m.data.copyInto(data)\n    }\n\n    fun setZero() {\n        data.fill(0.0f)\n    }\n\n    fun setIdentity() {\n        data.fill(0.0f)\n        var pos = 0\n        for (i in 0 until SZ) {\n            data[pos] = 1.0f\n            pos += SZ + 1\n        }\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun get(col: Int, row: Int): Float {\n        return data[col * SZ + row]\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun set(col: Int, row: Int, v: Float) {\n        data[col * SZ + row] = v\n    }\n\n    fun setTranslate(tx: Float, ty: Float, tz: Float) {\n        setIdentity()\n        data[12] = tx\n        data[13] = ty\n        data[14] = tz\n    }\n\n    fun setTranslate(t: Vec3) {\n        setTranslate(t[0], t[1], t[2])\n    }\n\n    //https://wikimedia.org/api/rest_v1/media/math/render/svg/7dc67eaa6d74f6629767726f854a5ff8bf7e5477\n    fun setRotate(a: Float, x: Float, y: Float, z: Float) {\n        setIdentity()\n\n        val s = sin(a)\n        val c = cos(a)\n        val oc = 1.0f - c\n\n        data[0] = c + oc * x * x\n        data[1] = oc * y * x + s * z\n        data[2] = oc * z * x - s * y\n\n        data[4] = oc * x * y - s * z\n        data[5] = c + oc * y * y\n        data[6] = oc * z * y + s * x\n\n        data[8] = oc * x * z + s * y\n        data[9] = oc * y * z - s * x\n        data[10] = c + oc * z * z\n    }\n\n    fun setRotate(a: Float, v: Vec3) {\n        setRotate(a, v.x, v.y, v.z)\n    }\n\n    fun setScale(sx: Float, sy: Float, sz: Float) {\n        setIdentity()\n        data[0] = sx\n        data[5] = sy\n        data[10] = sz\n        data[15] = 1.0f\n    }\n\n    fun setScale(s: Float) = setScale(s, s, s)\n\n    /**\n     *     this = A*B\n     *     this can be A and/or B\n     */\n    fun setMult(A: Mat4, B: Mat4) {\n        val a = A.data\n        val b = B.data\n\n        //doing like this saves from allocating array and alsow allows A and/or B to be the same as this\n        val c0 = b[3] * a[12] + b[2] * a[8] + b[1] * a[4] + a[0] * b[0]\n        val c1 = b[3] * a[13] + b[2] * a[9] + b[1] * a[5] + b[0] * a[1]\n        val c2 = b[3] * a[14] + b[2] * a[10] + b[1] * a[6] + b[0] * a[2]\n        val c3 = b[3] * a[15] + b[2] * a[11] + b[1] * a[7] + b[0] * a[3]\n        val c4 = b[7] * a[12] + b[6] * a[8] + a[4] * b[5] + a[0] * b[4]\n        val c5 = b[7] * a[13] + b[6] * a[9] + a[5] * b[5] + a[1] * b[4]\n        val c6 = b[7] * a[14] + b[6] * a[10] + b[5] * a[6] + a[2] * b[4]\n        val c7 = b[7] * a[15] + b[6] * a[11] + b[5] * a[7] + a[3] * b[4]\n        val c8 = b[11] * a[12] + a[8] * b[10] + a[4] * b[9] + a[0] * b[8]\n        val c9 = b[11] * a[13] + a[9] * b[10] + a[5] * b[9] + a[1] * b[8]\n        val c10 = b[11] * a[14] + a[10] * b[10] + a[6] * b[9] + a[2] * b[8]\n        val c11 = b[11] * a[15] + b[10] * a[11] + a[7] * b[9] + a[3] * b[8]\n        val c12 = a[12] * b[15] + a[8] * b[14] + a[4] * b[13] + a[0] * b[12]\n        val c13 = a[13] * b[15] + a[9] * b[14] + a[5] * b[13] + a[1] * b[12]\n        val c14 = a[14] * b[15] + a[10] * b[14] + a[6] * b[13] + a[2] * b[12]\n        val c15 = a[15] * b[15] + a[11] * b[14] + a[7] * b[13] + a[3] * b[12]\n\n        val c = this.data\n\n        c[0] = c0\n        c[1] = c1\n        c[2] = c2\n        c[3] = c3\n        c[4] = c4\n        c[5] = c5\n        c[6] = c6\n        c[7] = c7\n        c[8] = c8\n        c[9] = c9\n        c[10] = c10\n        c[11] = c11\n        c[12] = c12\n        c[13] = c13\n        c[14] = c14\n        c[15] = c15\n    }\n\n    fun setLookAt(eye: Vec3, center: Vec3, up: Vec3) {\n        // f = normalize(center - eye)\n        var fX = center.x - eye.x\n        var fY = center.y - eye.y\n        var fZ = center.z - eye.z\n        var inv = 1f / sqrt(fX * fX + fY * fY + fZ * fZ)\n        fX *= inv\n        fY *= inv\n        fZ *= inv\n\n        // s = normalize(cross(f, up))\n        var sX = fY * up.z - up.y * fZ\n        var sY = fZ * up.x - up.z * fX\n        var sZ = fX * up.y - up.x * fY\n        inv = 1f / sqrt(sX * sX + sY * sY + sZ * sZ)\n        sX *= inv\n        sY *= inv\n        sZ *= inv\n\n        // u = cross(s, f)\n        val uX = sY * fZ - fY * sZ\n        val uY = sZ * fX - fZ * sX\n        val uZ = sX * fY - fX * sY\n\n        this.setIdentity()\n\n        this[0, 0] = sX\n        this[1, 0] = sY\n        this[2, 0] = sZ\n\n        this[0, 1] = uX\n        this[1, 1] = uY\n        this[2, 1] = uZ\n\n        this[0, 2] = -fX\n        this[1, 2] = -fY\n        this[2, 2] = -fZ\n\n//        res[3,0] =-dot(s, eye)\n        this[3, 0] = -(sX * eye.x + sY * eye.y + sZ * eye.z)\n\n//        res[3,1] =-dot(u, eye)\n        this[3, 1] = -(uX * eye.x + uY * eye.y + uZ * eye.z)\n\n//        res[3,2] = dot(f, eye)\n        this[3, 2] = fX * eye.x + fY * eye.y + fZ * eye.z\n    }\n\n    fun setPerspective(fovY: Float, aspect: Float, near: Float, far: Float) {\n        val tanHalfFovy = tan(fovY / 2f)\n        setZero()\n\n        this[0, 0] = 1f / (aspect * tanHalfFovy)\n        this[1, 1] = 1f / (tanHalfFovy)\n        this[2, 2] = -(far + near) / (far - near)\n        this[2, 3] = -1f\n        this[3, 2] = -(2f * far * near) / (far - near)\n    }\n\n    fun setOrtho(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) {\n        setZero()\n\n        this[0, 0] = 2f / (right - left)\n        this[1, 1] = 2f / (top - bottom)\n        this[2, 2] = 2f / (near - far)\n        this[3, 3] = 1f\n\n//        this[0, 3] = (left + right) / (left - right)\n//        this[1, 3] = (bottom + top) / (bottom - top)\n//        this[2, 3] = (near + far) / (near - far)\n\n        this[3, 0] = (left + right) / (left - right)\n        this[3, 1] = (bottom + top) / (bottom - top)\n        this[3, 2] = (near + far) / (near - far)\n\n\n    }\n\n    fun dump() {\n        for (row in 0 until SZ) {\n            for (col in 0 until SZ) {\n                print(\"${this[col, row]}\\t\\t\\t\")\n            }\n            println()\n        }\n    }\n\n}\n\nclass Mat3 {\n\n    companion object {\n        const val SZ = 3\n    }\n\n    val data = FloatArray(SZ * SZ)\n\n    fun setIdentity() {\n        data.fill(0.0f)\n        var pos = 0\n        for (i in 0 until SZ) {\n            data[pos] = 1.0f\n            pos += SZ + 1\n        }\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun get(col: Int, row: Int): Float {\n        return data[col * SZ + row]\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun set(col: Int, row: Int, v: Float) {\n        data[col * SZ + row] = v\n    }\n}\n\nclass Mat2 {\n\n    companion object {\n        const val SZ = 2\n    }\n\n    val data = FloatArray(SZ * SZ)\n\n    fun setIdentity() {\n        data.fill(0.0f)\n        var pos = 0\n        for (i in 0 until SZ) {\n            data[pos] = 1.0f\n            pos += SZ + 1\n        }\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun get(col: Int, row: Int): Float {\n        return data[col * SZ + row]\n    }\n\n    /**\n     * @param col is the number of column of \"real\" math matrix\n     * @param row is the number of row of \"real\" math matrix\n     */\n    operator fun set(col: Int, row: Int, v: Float) {\n        data[col * SZ + row] = v\n    }\n}\n\n\n/**\nv can be this\n */\nfun Vec3.setMult(m: Mat4, v: Vec3) {\n    val a = m.data\n    val newX = a[12] + v[2] * a[8] + v[1] * a[4] + a[0] * v[0]\n    val newY = a[13] + v[2] * a[9] + v[1] * a[5] + v[0] * a[1]\n    val newZ = a[14] + v[2] * a[10] + v[1] * a[6] + v[0] * a[2]\n    set(newX, newY, newZ)\n}\n\nfun Vec3.setMultFree(m: Mat4, v: Vec3) {\n    val a = m.data\n    val newX = v[2] * a[8] + v[1] * a[4] + a[0] * v[0]\n    val newY = v[2] * a[9] + v[1] * a[5] + v[0] * a[1]\n    val newZ = v[2] * a[10] + v[1] * a[6] + v[0] * a[2]\n    set(newX, newY, newZ)\n}\n\nfun inversed(res: Mat4, m: Mat4): Mat4 {\n\n    val c00 = m[2, 2] * m[3, 3] - m[3, 2] * m[2, 3]\n    val c02 = m[1, 2] * m[3, 3] - m[3, 2] * m[1, 3]\n    val c03 = m[1, 2] * m[2, 3] - m[2, 2] * m[1, 3]\n\n    val c04 = m[2, 1] * m[3, 3] - m[3, 1] * m[2, 3]\n    val c06 = m[1, 1] * m[3, 3] - m[3, 1] * m[1, 3]\n    val c07 = m[1, 1] * m[2, 3] - m[2, 1] * m[1, 3]\n\n    val c08 = m[2, 1] * m[3, 2] - m[3, 1] * m[2, 2]\n    val c10 = m[1, 1] * m[3, 2] - m[3, 1] * m[1, 2]\n    val c11 = m[1, 1] * m[2, 2] - m[2, 1] * m[1, 2]\n\n    val c12 = m[2, 0] * m[3, 3] - m[3, 0] * m[2, 3]\n    val c14 = m[1, 0] * m[3, 3] - m[3, 0] * m[1, 3]\n    val c15 = m[1, 0] * m[2, 3] - m[2, 0] * m[1, 3]\n\n    val c16 = m[2, 0] * m[3, 2] - m[3, 0] * m[2, 2]\n    val c18 = m[1, 0] * m[3, 2] - m[3, 0] * m[1, 2]\n    val c19 = m[1, 0] * m[2, 2] - m[2, 0] * m[1, 2]\n\n    val c20 = m[2, 0] * m[3, 1] - m[3, 0] * m[2, 1]\n    val c22 = m[1, 0] * m[3, 1] - m[3, 0] * m[1, 1]\n    val c23 = m[1, 0] * m[2, 1] - m[2, 0] * m[1, 1]\n\n    val i00 = +(m[1, 1] * c00 - m[1, 2] * c04 + m[1, 3] * c08)\n    val i01 = -(m[0, 1] * c00 - m[0, 2] * c04 + m[0, 3] * c08)\n    val i02 = +(m[0, 1] * c02 - m[0, 2] * c06 + m[0, 3] * c10)\n    val i03 = -(m[0, 1] * c03 - m[0, 2] * c07 + m[0, 3] * c11)\n\n    val i10 = -(m[1, 0] * c00 - m[1, 2] * c12 + m[1, 3] * c16)\n    val i11 = +(m[0, 0] * c00 - m[0, 2] * c12 + m[0, 3] * c16)\n    val i12 = -(m[0, 0] * c02 - m[0, 2] * c14 + m[0, 3] * c18)\n    val i13 = +(m[0, 0] * c03 - m[0, 2] * c15 + m[0, 3] * c19)\n\n    val i20 = +(m[1, 0] * c04 - m[1, 1] * c12 + m[1, 3] * c20)\n    val i21 = -(m[0, 0] * c04 - m[0, 1] * c12 + m[0, 3] * c20)\n    val i22 = +(m[0, 0] * c06 - m[0, 1] * c14 + m[0, 3] * c22)\n    val i23 = -(m[0, 0] * c07 - m[0, 1] * c15 + m[0, 3] * c23)\n\n    val i30 = -(m[1, 0] * c08 - m[1, 1] * c16 + m[1, 2] * c20)\n    val i31 = +(m[0, 0] * c08 - m[0, 1] * c16 + m[0, 2] * c20)\n    val i32 = -(m[0, 0] * c10 - m[0, 1] * c18 + m[0, 2] * c22)\n    val i33 = +(m[0, 0] * c11 - m[0, 1] * c19 + m[0, 2] * c23)\n\n    val oneOverDet = 1.0f / (m[0, 0] * i00 + m[0, 1] * i10 + m[0, 2] * i20 + m[0, 3] * i30)\n\n    res[0, 0] = i00 * oneOverDet\n    res[0, 1] = i01 * oneOverDet\n    res[0, 2] = i02 * oneOverDet\n    res[0, 3] = i03 * oneOverDet\n\n    res[1, 0] = i10 * oneOverDet\n    res[1, 1] = i11 * oneOverDet\n    res[1, 2] = i12 * oneOverDet\n    res[1, 3] = i13 * oneOverDet\n\n    res[2, 0] = i20 * oneOverDet\n    res[2, 1] = i21 * oneOverDet\n    res[2, 2] = i22 * oneOverDet\n    res[2, 3] = i23 * oneOverDet\n\n    res[3, 0] = i30 * oneOverDet\n    res[3, 1] = i31 * oneOverDet\n    res[3, 2] = i32 * oneOverDet\n    res[3, 3] = i33 * oneOverDet\n\n    return res\n}\n\nfun Mat4.rebase(v1: Vec3, v2: Vec3, v3: Vec3, w1: Vec3, w2: Vec3, w3: Vec3, p: Vec3, q: Vec3) {\n    val V = Mat4()\n    val W = Mat4()\n\n    V.data[0] = v1.x\n    V.data[1] = v1.y\n    V.data[2] = v1.z\n    V.data[3] = 0f\n\n    V.data[4] = v2.x\n    V.data[5] = v2.y\n    V.data[6] = v2.z\n    V.data[7] = 0f\n\n    V.data[8] = v3.x\n    V.data[9] = v3.y\n    V.data[10] = v3.z\n    V.data[11] = 0f\n\n    V.data[12] = p.x\n    V.data[13] = p.y\n    V.data[14] = p.z\n    V.data[15] = 1f\n\n\n    W.data[0] = w1.x\n    W.data[1] = w1.y\n    W.data[2] = w1.z\n    W.data[3] = 0f\n\n    W.data[4] = w2.x\n    W.data[5] = w2.y\n    W.data[6] = w2.z\n    W.data[7] = 0f\n\n    W.data[8] = w3.x\n    W.data[9] = w3.y\n    W.data[10] = w3.z\n    W.data[11] = 0f\n\n    W.data[12] = q.x\n    W.data[13] = q.y\n    W.data[14] = q.z\n    W.data[15] = 1f\n\n    inversed(V, V)\n\n    setMult(W, V)\n}",null,"package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.sqrt\n\nclass Quaternion(x: Float, y: Float, z: Float, w: Float) {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val data = FloatArray(4)\n\n    inline var x: Float\n        get() = this.data[0]\n        set(v) {\n            this.data[0] = v\n        }\n\n    inline var y: Float\n        get() = this.data[1]\n        set(v) {\n            this.data[1] = v\n        }\n\n    inline var z: Float\n        get() = this.data[2]\n        set(v) {\n            this.data[2] = v\n        }\n\n    inline var w: Float\n        get() = this.data[3]\n        set(v) {\n            this.data[3] = v\n        }\n\n    init {\n        this.x = x\n        this.y = y\n        this.z = z\n        this.w = w\n    }\n\n    fun set(x: Float, y: Float, z: Float, w: Float) {\n        this.x = x\n        this.y = y\n        this.z = z\n        this.w = w\n    }\n\n    fun setMult(a: Quaternion, b: Quaternion) {\n        val resX = ((((a.y * b.z) - (a.z * b.y)) + (a.w * b.x)) + (b.w * a.x))\n        val resY = ((((a.z * b.x) - (a.x * b.z)) + (a.w * b.y)) + (b.w * a.y))\n        val resZ = ((((a.x * b.y) - (a.y * b.x)) + (a.w * b.z)) + (b.w * a.z))\n        val resW = ((a.w * b.w) - ((a.x * b.x) + (a.y * b.y) + (a.z * b.z)))\n\n        x = resX\n        y = resY\n        z = resZ\n        w = resW\n    }\n\n    fun normSq() = x * x + y * y + z * z + w * w\n\n    fun norm() = sqrt(normSq())\n\n    fun normalize() {\n        val n = norm()\n        x /= n\n        y /= n\n        z /= n\n        w /= n\n    }\n\n    /**\n     *  after that operation quaternion is already normalized\n     */\n    fun setAxisAndRotation(v: Vec3, a: Float) {\n        val n = v.norm()\n        val s = sin(0.5f * a)\n        val c = cos(0.5f * a)\n\n        x = v.x / n * s\n        y = v.y / n * s\n        z = v.z / n * s\n        w = c\n        //after that quaternion is already normalized\n    }\n\n    override fun toString(): String {\n        return \"Q[${x}, ${y}, ${z}, ${w}]\"\n    }\n\n    fun add(q: Quaternion) {\n        x += q.x\n        y += q.y\n        z += q.z\n        w += q.w\n    }\n\n    fun set(q: Quaternion) {\n        x = q.x\n        y = q.y\n        z = q.z\n        w = q.w\n    }\n}\n\nfun Vec3.setRotate(v: Vec3, q: Quaternion) {\n    val newX = q.y * v.z - q.z * v.y + q.w * v.x\n    val newY = q.z * v.x - q.x * v.z + q.w * v.y\n    val newZ = q.x * v.y - q.y * v.x + q.w * v.z\n    val newW = -(q.x * v.x + q.y * v.y + q.z * v.z)\n\n    val resX = newY * (-1 * q.z) - newZ * (-1 * q.y) + newW * (-1 * q.x) + q.w * newX\n    val resY = newZ * (-1 * q.x) - newX * (-1 * q.z) + newW * (-1 * q.y) + q.w * newY\n    val resZ = newX * (-1 * q.y) - newY * (-1 * q.x) + newW * (-1 * q.z) + q.w * newZ\n\n    val normSq = q.normSq()\n\n    x = resX / normSq\n    y = resY / normSq\n    z = resZ / normSq\n}\n\nfun Mat4.setQuaternion(q: Quaternion) {\n    val s = 2.0f / q.norm()\n\n    val x2 = q.x * s\n    val y2 = q.y * s\n    val z2 = q.z * s\n\n    val xx = q.x * x2\n    val xy = q.x * y2\n    val xz = q.x * z2\n    val yy = q.y * y2\n    val yz = q.y * z2\n    val zz = q.z * z2\n    val wx = q.w * x2\n    val wy = q.w * y2\n    val wz = q.w * z2\n\n    val m = this\n    m.setIdentity()\n\n    m[0, 0] = 1.0f - (yy + zz);\n    m[1, 0] = xy - wz;\n    m[2, 0] = xz + wy;\n\n    m[0, 1] = xy + wz;\n    m[1, 1] = 1.0f - (xx + zz);\n    m[2, 1] = yz - wx;\n\n    m[0, 2] = xz - wy;\n    m[1, 2] = yz + wx;\n    m[2, 2] = 1.0f - (xx + yy);\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\n\nclass Ray {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val origin: Vec3 = Vec3(0f, 0f, 0f)\n    val dir: Vec3 = Vec3(1f, 0f, 0f)\n\n    fun set(o: Vec3, d: Vec3) {\n        origin.assign(o)\n        dir.assign(d)\n    }\n\n    override fun toString(): String {\n        return \"Ray(origin=$origin, dir=$dir)\"\n    }\n}","package kmptemplate.math\n\nimport kmptemplate.PERF_TRACKER\n\nopen class Vec4(x: Float, y: Float, z: Float, w: Float) {\n\n    init {\n        PERF_TRACKER.trackVec()\n    }\n\n    val data = FloatArray(4)\n\n    var x: Float\n        get() = this.data[0]\n        set(v) {\n            this.data[0] = v\n        }\n\n    var y: Float\n        get() = this.data[1]\n        set(v) {\n            this.data[1] = v\n        }\n\n    var z: Float\n        get() = this.data[2]\n        set(v) {\n            this.data[2] = v\n        }\n\n    var w: Float\n        get() = this.data[3]\n        set(v) {\n            this.data[3] = v\n        }\n\n    init {\n        data[0] = x\n        data[1] = y\n        data[2] = z\n        data[3] = w\n    }\n\n    fun assign(v: Vec4) {\n        x = v.x\n        y = v.y\n        z = v.z\n        w = v.w\n    }\n\n    fun toVec3(): Vec3 {\n        return Vec3(x / w, y / w, z / w)\n    }\n\n    override fun toString(): String {\n        return \"Vec4(${data})\"\n    }\n}\n\n",null,"package kmptemplate.pool\n\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\n\nobject VecPool {\n\n    val size: Int = 4096\n\n    private val rays = Array(size) { Ray() }\n    private val arr3 = Array(size) { Vec3() }\n    private var i3 = 0\n    private var r = 0\n\n    fun obtainVec3(): Vec3 {\n        return arr3[i3++]\n    }\n\n    fun obtainVec3(v: Vec3): Vec3 {\n        val res = arr3[i3++]\n        res.set(v)\n        return res\n    }\n\n    fun reset() {\n//        println(\"rays obtained: ${r}\")\n//        println(\"vec3 obtained: ${i3}\")\n\n        i3 = 0\n        r = 0\n    }\n\n    fun obtainVec3(x: Float, y: Float, z: Float): Vec3 {\n        val res = arr3[i3++]\n        res.set(x, y, z)\n        return res\n    }\n\n    fun obtainRay(): Ray {\n        return rays[r++]\n    }\n}","package kmptemplate.sound\n\nabstract class SoundBuffer {\n}\n\nclass Playback(val start: Long, val soundBuffer: SoundBuffer)\n\nabstract class SoundManager() {\n    abstract fun play(sound: SoundBuffer): Playback\n\n    abstract fun stop(playback: Playback)\n    abstract suspend fun loadSoundBuf(path: String): SoundBuffer\n}","package kmptemplate.storage\n\nabstract class Storage {\n    abstract fun set(k: String, v: String)\n    abstract fun get(k: String): String?\n\n    abstract fun remove(k: String)\n    abstract fun clear()\n\n    fun setLong(k: String, v: Long) {\n        set(k, v.toString())\n    }\n\n    fun getLong(k: String, defValue: Long): Long {\n        return get(k)?.toLongOrNull() ?: defValue\n    }\n\n    fun setInt(k: String, v: Int) {\n        set(k, v.toString())\n    }\n\n    fun getInt(k: String, defValue: Int): Int {\n        return get(k)?.toIntOrNull() ?: defValue\n    }\n\n    fun setBoolean(k: String, v: Boolean) {\n        set(k, v.toString())\n    }\n\n    fun getBoolean(k: String, defValue: Boolean): Boolean {\n        return get(k)?.toBooleanStrictOrNull() ?: defValue\n    }\n\n    fun setIntList(k: String, list: List<Int>) {\n        val v = list.joinToString(separator = \",\")\n        set(k, v)\n    }\n\n    fun getIntList(k: String): List<Int> {\n        val v = get(k)\n        return v?.split(',')?.map { it.toInt() } ?: emptyList()\n    }\n}","package kmptemplate.tetris\n\nabstract class Ads {\n    abstract fun showInterstitial()\n    abstract fun showRewarded(\n        onReward: () -> Unit,\n        onOpen: () -> Unit = {},\n        onClose: () -> Unit = {},\n        onError: (Any) -> Unit = {}\n    )\n}\n\nclass NoAds : Ads() {\n    override fun showInterstitial() {\n    }\n\n    override fun showRewarded(onReward: () -> Unit, onOpen: () -> Unit, onClose: () -> Unit, onError: (Any) -> Unit) {\n    }\n}\n\nclass PrintAds : Ads() {\n    override fun showInterstitial() {\n        println(\"Showing interstitial ads\")\n    }\n\n    override fun showRewarded(onReward: () -> Unit, onOpen: () -> Unit, onClose: () -> Unit, onError: (Any) -> Unit) {\n        println(\"Showing rewarded ads\")\n        onReward()\n    }\n}","package kmptemplate.triangulator\n\nimport kotlin.math.abs\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sign\n\nclass KFloatArray {\n    var items: FloatArray\n    var size = 0\n    var ordered: Boolean\n\n    /** Creates an ordered array with the specified capacity.  */\n    constructor(capacity: Int) : this(true, capacity) {}\n    /** @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a\n     * memory copy.\n     * @param capacity Any elements added beyond this will cause the backing array to be grown.\n     */\n    /** Creates an ordered array with a capacity of 16.  */\n    constructor(ordered: Boolean = true, capacity: Int = 16) {\n        this.ordered = ordered\n        items = FloatArray(capacity)\n    }\n\n    /** Creates a new array containing the elements in the specific array. The new array will be ordered if the specific array is\n     * ordered. The capacity is set to the number of elements, so any subsequent elements added will cause the backing array to be\n     * grown.  */\n    constructor(array: KFloatArray) {\n        ordered = array.ordered\n        size = array.size\n        items = FloatArray(size)\n        System_arraycopy(array.items, 0, items, 0, size)\n    }\n\n    /** Creates a new ordered array containing the elements in the specified array. The capacity is set to the number of elements,\n     * so any subsequent elements added will cause the backing array to be grown.  */\n    constructor(array: FloatArray) : this(true, array, 0, array.size) {}\n\n    /** Creates a new array containing the elements in the specified array. The capacity is set to the number of elements, so any\n     * subsequent elements added will cause the backing array to be grown.\n     * @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a\n     * memory copy.\n     */\n    constructor(ordered: Boolean, array: FloatArray, startIndex: Int, count: Int) : this(ordered, count) {\n        size = count\n        System_arraycopy(array, startIndex, items, 0, count)\n    }\n\n    fun add(value: Float) {\n        var items = items\n        if (size == items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        items[size++] = value\n    }\n\n    fun add(value1: Float, value2: Float) {\n        var items = items\n        if (size + 1 >= items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        items[size] = value1\n        items[size + 1] = value2\n        size += 2\n    }\n\n    fun add(value1: Float, value2: Float, value3: Float) {\n        var items = items\n        if (size + 2 >= items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        items[size] = value1\n        items[size + 1] = value2\n        items[size + 2] = value3\n        size += 3\n    }\n\n    fun add(value1: Float, value2: Float, value3: Float, value4: Float) {\n        var items = items\n        if (size + 3 >= items.size) items = resize(max(8, (size * 1.8f).toInt())) // 1.75 isn't enough when size=5.\n        items[size] = value1\n        items[size + 1] = value2\n        items[size + 2] = value3\n        items[size + 3] = value4\n        size += 4\n    }\n\n    fun addAll(array: KFloatArray) {\n        addAll(array.items, 0, array.size)\n    }\n\n    fun addAll(array: KFloatArray, offset: Int, length: Int) {\n        if (offset + length > array.size) throw IllegalArgumentException(\"offset + length must be <= size: \" + offset + \" + \" + length + \" <= \" + array.size)\n        addAll(array.items, offset, length)\n    }\n\n    fun addAll(vararg array: Float) {\n        addAll(array, 0, array.size)\n    }\n\n    fun addAll(array: FloatArray, offset: Int, length: Int) {\n        var items = items\n        val sizeNeeded = size + length\n        if (sizeNeeded > items.size) items = resize(max(max(8, sizeNeeded), (size * 1.75f).toInt()))\n        System_arraycopy(array, offset, items, size, length)\n        size += length\n    }\n\n    operator fun get(index: Int): Float {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        return items[index]\n    }\n\n    operator fun set(index: Int, value: Float) {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        items[index] = value\n    }\n\n    fun incr(index: Int, value: Float) {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        items[index] += value\n    }\n\n    fun incr(value: Float) {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            items[i] += value\n            i++\n        }\n    }\n\n    fun mul(index: Int, value: Float) {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        items[index] *= value\n    }\n\n    fun mul(value: Float) {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            items[i] *= value\n            i++\n        }\n    }\n\n    fun insert(index: Int, value: Float) {\n        if (index > size) throw IndexOutOfBoundsException(\"index can't be > size: $index > $size\")\n        var items = items\n        if (size == items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        if (ordered) System_arraycopy(items, index, items, index + 1, size - index) else items[size] = items[index]\n        size++\n        items[index] = value\n    }\n\n    /** Inserts the specified number of items at the specified index. The new items will have values equal to the values at those\n     * indices before the insertion.  */\n    fun insertRange(index: Int, count: Int) {\n        if (index > size) throw IndexOutOfBoundsException(\"index can't be > size: $index > $size\")\n        val sizeNeeded = size + count\n        if (sizeNeeded > items.size) items = resize(max(max(8, sizeNeeded), (size * 1.75f).toInt()))\n        System_arraycopy(items, index, items, index + count, size - index)\n        size = sizeNeeded\n    }\n\n    fun swap(first: Int, second: Int) {\n        if (first >= size) throw IndexOutOfBoundsException(\"first can't be >= size: $first >= $size\")\n        if (second >= size) throw IndexOutOfBoundsException(\"second can't be >= size: $second >= $size\")\n        val items = items\n        val firstValue = items[first]\n        items[first] = items[second]\n        items[second] = firstValue\n    }\n\n    operator fun contains(value: Float): Boolean {\n        var i = size - 1\n        val items = items\n        while (i >= 0) if (items[i--] == value) return true\n        return false\n    }\n\n    fun indexOf(value: Float): Int {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            if (items[i] == value) return i\n            i++\n        }\n        return -1\n    }\n\n    fun lastIndexOf(value: Float): Int {\n        val items = items\n        for (i in size - 1 downTo 0) if (items[i] == value) return i\n        return -1\n    }\n\n    fun removeValue(value: Float): Boolean {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            if (items[i] == value) {\n                removeIndex(i)\n                return true\n            }\n            i++\n        }\n        return false\n    }\n\n    /** Removes and returns the item at the specified index.  */\n    fun removeIndex(index: Int): Float {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        val items = items\n        val value = items[index]\n        size--\n        if (ordered) System_arraycopy(items, index + 1, items, index, size - index) else items[index] = items[size]\n        return value\n    }\n\n    /** Removes the items between the specified indices, inclusive.  */\n    fun removeRange(start: Int, end: Int) {\n        val n = size\n        if (end >= n) throw IndexOutOfBoundsException(\"end can't be >= size: $end >= $size\")\n        if (start > end) throw IndexOutOfBoundsException(\"start can't be > end: $start > $end\")\n        val count = end - start + 1\n        val lastIndex = n - count\n        if (ordered) System_arraycopy(items, start + count, items, start, n - (start + count)) else {\n            val i: Int = max(lastIndex, end + 1)\n            System_arraycopy(items, i, items, start, n - i)\n        }\n        size = n - count\n    }\n\n    /** Removes from this array all of elements contained in the specified array.\n     * @return true if this array was modified.\n     */\n    fun removeAll(array: KFloatArray): Boolean {\n        var size = size\n        val startSize = size\n        val items = items\n        var i = 0\n        val n = array.size\n        while (i < n) {\n            val item = array[i]\n            for (ii in 0 until size) {\n                if (item == items[ii]) {\n                    removeIndex(ii)\n                    size--\n                    break\n                }\n            }\n            i++\n        }\n        return size != startSize\n    }\n\n    /** Removes and returns the last item.  */\n    fun pop(): Float {\n        return items[--size]\n    }\n\n    /** Returns the last item.  */\n    fun peek(): Float {\n        return items[size - 1]\n    }\n\n    /** Returns the first item.  */\n    fun first(): Float {\n        check(size != 0) { \"Array is empty.\" }\n        return items[0]\n    }\n\n    /** Returns true if the array has one or more items.  */\n    fun notEmpty(): Boolean {\n        return size > 0\n    }\n\n    /** Returns true if the array is empty.  */\n    val isEmpty: Boolean\n        get() = size == 0\n\n    fun clear() {\n        size = 0\n    }\n\n    /** Reduces the size of the backing array to the size of the actual items. This is useful to release memory when many items\n     * have been removed, or if it is known that more items will not be added.\n     * @return [.items]\n     */\n    fun shrink(): FloatArray {\n        if (items.size != size) resize(size)\n        return items\n    }\n\n    /** Increases the size of the backing array to accommodate the specified number of additional items. Useful before adding many\n     * items to avoid multiple backing array resizes.\n     * @return [.items]\n     */\n    fun ensureCapacity(additionalCapacity: Int): FloatArray {\n        if (additionalCapacity < 0) throw IllegalArgumentException(\"additionalCapacity must be >= 0: $additionalCapacity\")\n        val sizeNeeded = size + additionalCapacity\n        if (sizeNeeded > items.size) resize(max(max(8, sizeNeeded), (size * 1.75f).toInt()))\n        return items\n    }\n\n    /** Sets the array size, leaving any values beyond the current size undefined.\n     * @return [.items]\n     */\n    fun setSize(newSize: Int): FloatArray {\n        if (newSize < 0) throw IllegalArgumentException(\"newSize must be >= 0: $newSize\")\n        if (newSize > items.size) resize(max(8, newSize))\n        size = newSize\n        return items\n    }\n\n    protected fun resize(newSize: Int): FloatArray {\n        val newItems = FloatArray(newSize)\n        val items = items\n        System_arraycopy(items, 0, newItems, 0, min(size, newItems.size))\n        this.items = newItems\n        return newItems\n    }\n\n    fun sort() {\n        items.sort()\n    }\n\n    fun reverse() {\n        val items = items\n        var i = 0\n        val lastIndex = size - 1\n        val n = size / 2\n        while (i < n) {\n            val ii = lastIndex - i\n            val temp = items[i]\n            items[i] = items[ii]\n            items[ii] = temp\n            i++\n        }\n    }\n\n\n    /** Reduces the size of the array to the specified size. If the array is already smaller than the specified size, no action is\n     * taken.  */\n    fun truncate(newSize: Int) {\n        if (size > newSize) size = newSize\n    }\n\n\n    fun toArray(): FloatArray {\n        val array = FloatArray(size)\n        System_arraycopy(items, 0, array, 0, size)\n        return array\n    }\n\n    override fun hashCode(): Int {\n        if (!ordered) return super.hashCode()\n        val items = items\n        var h = 1\n        var i = 0\n        val n = size\n        while (i < n) {\n            h = h * 31 + (items[i].toRawBits())\n            i++\n        }\n        return h\n    }\n\n    /** Returns false if either array is unordered.  */\n    override fun equals(`object`: Any?): Boolean {\n        if (`object` === this) return true\n        if (!ordered) return false\n        if (`object` !is KFloatArray) return false\n        val array = `object`\n        if (!array.ordered) return false\n        val n = size\n        if (n != array.size) return false\n        val items1 = items\n        val items2 = array.items\n        for (i in 0 until n) if (items1[i] != items2[i]) return false\n        return true\n    }\n\n    /** Returns false if either array is unordered.  */\n    fun equals(obj: Any, epsilon: Float): Boolean {\n        if (obj === this) return true\n        if (obj !is KFloatArray) return false\n        val array = obj\n        val n = size\n        if (n != array.size) return false\n        if (!ordered) return false\n        if (!array.ordered) return false\n        val items1 = items\n        val items2 = array.items\n        for (i in 0 until n) if (abs(items1[i] - items2[i]) > epsilon) return false\n        return true\n    }\n\n    override fun toString(): String {\n        if (size == 0) return \"[]\"\n        val items = items\n        val buffer: StringBuilder = StringBuilder(32)\n        buffer.append('[')\n        buffer.append(items[0])\n        for (i in 1 until size) {\n            buffer.append(\", \")\n            buffer.append(items[i])\n        }\n        buffer.append(']')\n        return buffer.toString()\n    }\n\n    fun toString(separator: String?): String {\n        if (size == 0) return \"\"\n        val items = items\n        val buffer: StringBuilder = StringBuilder(32)\n        buffer.append(items[0])\n        for (i in 1 until size) {\n            buffer.append(separator)\n            buffer.append(items[i])\n        }\n        return buffer.toString()\n    }\n\n}\n\nclass KIntArray {\n    var items: IntArray\n    var size = 0\n    var ordered: Boolean\n\n    /** Creates an ordered array with the specified capacity.  */\n    constructor(capacity: Int) : this(true, capacity) {}\n    /** @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a\n     * memory copy.\n     * @param capacity Any elements added beyond this will cause the backing array to be grown.\n     */\n    /** Creates an ordered array with a capacity of 16.  */\n    constructor(ordered: Boolean = true, capacity: Int = 16) {\n        this.ordered = ordered\n        items = IntArray(capacity)\n    }\n\n    /** Creates a new array containing the elements in the specific array. The new array will be ordered if the specific array is\n     * ordered. The capacity is set to the number of elements, so any subsequent elements added will cause the backing array to be\n     * grown.  */\n    constructor(array: KIntArray) {\n        ordered = array.ordered\n        size = array.size\n        items = IntArray(size)\n        System_arraycopy(array.items, 0, items, 0, size)\n    }\n\n    /** Creates a new ordered array containing the elements in the specified array. The capacity is set to the number of elements,\n     * so any subsequent elements added will cause the backing array to be grown.  */\n    constructor(array: IntArray) : this(true, array, 0, array.size) {}\n\n    /** Creates a new array containing the elements in the specified array. The capacity is set to the number of elements, so any\n     * subsequent elements added will cause the backing array to be grown.\n     * @param ordered If false, methods that remove elements may change the order of other elements in the array, which avoids a\n     * memory copy.\n     */\n    constructor(ordered: Boolean, array: IntArray, startIndex: Int, count: Int) : this(ordered, count) {\n        size = count\n        System_arraycopy(array, startIndex, items, 0, count)\n    }\n\n    fun add(value: Int) {\n        var items = items\n        if (size == items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        items[size++] = value\n    }\n\n    fun add(value1: Int, value2: Int) {\n        var items = items\n        if (size + 1 >= items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        items[size] = value1\n        items[size + 1] = value2\n        size += 2\n    }\n\n    fun add(value1: Int, value2: Int, value3: Int) {\n        var items = items\n        if (size + 2 >= items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        items[size] = value1\n        items[size + 1] = value2\n        items[size + 2] = value3\n        size += 3\n    }\n\n    fun add(value1: Int, value2: Int, value3: Int, value4: Int) {\n        var items = items\n        if (size + 3 >= items.size) items = resize(max(8, (size * 1.8f).toInt())) // 1.75 isn't enough when size=5.\n        items[size] = value1\n        items[size + 1] = value2\n        items[size + 2] = value3\n        items[size + 3] = value4\n        size += 4\n    }\n\n    fun addAll(array: KIntArray) {\n        addAll(array.items, 0, array.size)\n    }\n\n    fun addAll(array: KIntArray, offset: Int, length: Int) {\n        if (offset + length > array.size) throw IllegalArgumentException(\"offset + length must be <= size: \" + offset + \" + \" + length + \" <= \" + array.size)\n        addAll(array.items, offset, length)\n    }\n\n    fun addAll(vararg array: Int) {\n        addAll(array, 0, array.size)\n    }\n\n    fun addAll(array: IntArray, offset: Int, length: Int) {\n        var items = items\n        val sizeNeeded = size + length\n        if (sizeNeeded > items.size) items = resize(max(max(8, sizeNeeded), (size * 1.75f).toInt()))\n        System_arraycopy(array, offset, items, size, length)\n        size += length\n    }\n\n    operator fun get(index: Int): Int {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        return items[index]\n    }\n\n    operator fun set(index: Int, value: Int) {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        items[index] = value\n    }\n\n    fun incr(index: Int, value: Int) {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        items[index] += value\n    }\n\n    fun incr(value: Int) {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            items[i] += value\n            i++\n        }\n    }\n\n    fun mul(index: Int, value: Int) {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        items[index] *= value\n    }\n\n    fun mul(value: Int) {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            items[i] *= value\n            i++\n        }\n    }\n\n    fun insert(index: Int, value: Int) {\n        if (index > size) throw IndexOutOfBoundsException(\"index can't be > size: $index > $size\")\n        var items = items\n        if (size == items.size) items = resize(max(8, (size * 1.75f).toInt()))\n        if (ordered) System_arraycopy(items, index, items, index + 1, size - index) else items[size] = items[index]\n        size++\n        items[index] = value\n    }\n\n    /** Inserts the specified number of items at the specified index. The new items will have values equal to the values at those\n     * indices before the insertion.  */\n    fun insertRange(index: Int, count: Int) {\n        if (index > size) throw IndexOutOfBoundsException(\"index can't be > size: $index > $size\")\n        val sizeNeeded = size + count\n        if (sizeNeeded > items.size) items = resize(max(max(8, sizeNeeded), (size * 1.75f).toInt()))\n        System_arraycopy(items, index, items, index + count, size - index)\n        size = sizeNeeded\n    }\n\n    fun swap(first: Int, second: Int) {\n        if (first >= size) throw IndexOutOfBoundsException(\"first can't be >= size: $first >= $size\")\n        if (second >= size) throw IndexOutOfBoundsException(\"second can't be >= size: $second >= $size\")\n        val items = items\n        val firstValue = items[first]\n        items[first] = items[second]\n        items[second] = firstValue\n    }\n\n    operator fun contains(value: Int): Boolean {\n        var i = size - 1\n        val items = items\n        while (i >= 0) if (items[i--] == value) return true\n        return false\n    }\n\n    fun indexOf(value: Int): Int {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            if (items[i] == value) return i\n            i++\n        }\n        return -1\n    }\n\n    fun lastIndexOf(value: Int): Int {\n        val items = items\n        for (i in size - 1 downTo 0) if (items[i] == value) return i\n        return -1\n    }\n\n    fun removeValue(value: Int): Boolean {\n        val items = items\n        var i = 0\n        val n = size\n        while (i < n) {\n            if (items[i] == value) {\n                removeIndex(i)\n                return true\n            }\n            i++\n        }\n        return false\n    }\n\n    /** Removes and returns the item at the specified index.  */\n    fun removeIndex(index: Int): Int {\n        if (index >= size) throw IndexOutOfBoundsException(\"index can't be >= size: $index >= $size\")\n        val items = items\n        val value = items[index]\n        size--\n        if (ordered) System_arraycopy(items, index + 1, items, index, size - index) else items[index] = items[size]\n        return value\n    }\n\n    /** Removes the items between the specified indices, inclusive.  */\n    fun removeRange(start: Int, end: Int) {\n        val n = size\n        if (end >= n) throw IndexOutOfBoundsException(\"end can't be >= size: $end >= $size\")\n        if (start > end) throw IndexOutOfBoundsException(\"start can't be > end: $start > $end\")\n        val count = end - start + 1\n        val lastIndex = n - count\n        if (ordered) System_arraycopy(items, start + count, items, start, n - (start + count)) else {\n            val i: Int = max(lastIndex, end + 1)\n            System_arraycopy(items, i, items, start, n - i)\n        }\n        size = n - count\n    }\n\n    /** Removes from this array all of elements contained in the specified array.\n     * @return true if this array was modified.\n     */\n    fun removeAll(array: KIntArray): Boolean {\n        var size = size\n        val startSize = size\n        val items = items\n        var i = 0\n        val n = array.size\n        while (i < n) {\n            val item = array[i]\n            for (ii in 0 until size) {\n                if (item == items[ii]) {\n                    removeIndex(ii)\n                    size--\n                    break\n                }\n            }\n            i++\n        }\n        return size != startSize\n    }\n\n    /** Removes and returns the last item.  */\n    fun pop(): Int {\n        return items[--size]\n    }\n\n    /** Returns the last item.  */\n    fun peek(): Int {\n        return items[size - 1]\n    }\n\n    /** Returns the first item.  */\n    fun first(): Int {\n        check(size != 0) { \"Array is empty.\" }\n        return items[0]\n    }\n\n    /** Returns true if the array has one or more items.  */\n    fun notEmpty(): Boolean {\n        return size > 0\n    }\n\n    /** Returns true if the array is empty.  */\n    val isEmpty: Boolean\n        get() = size == 0\n\n    fun clear() {\n        size = 0\n    }\n\n    /** Reduces the size of the backing array to the size of the actual items. This is useful to release memory when many items\n     * have been removed, or if it is known that more items will not be added.\n     * @return [.items]\n     */\n    fun shrink(): IntArray {\n        if (items.size != size) resize(size)\n        return items\n    }\n\n    /** Increases the size of the backing array to accommodate the specified number of additional items. Useful before adding many\n     * items to avoid multiple backing array resizes.\n     * @return [.items]\n     */\n    fun ensureCapacity(additionalCapacity: Int): IntArray {\n        if (additionalCapacity < 0) throw IllegalArgumentException(\"additionalCapacity must be >= 0: $additionalCapacity\")\n        val sizeNeeded = size + additionalCapacity\n        if (sizeNeeded > items.size) resize(max(max(8, sizeNeeded), (size * 1.75f).toInt()))\n        return items\n    }\n\n    /** Sets the array size, leaving any values beyond the current size undefined.\n     * @return [.items]\n     */\n    fun setSize(newSize: Int): IntArray {\n        if (newSize < 0) throw IllegalArgumentException(\"newSize must be >= 0: $newSize\")\n        if (newSize > items.size) resize(max(8, newSize))\n        size = newSize\n        return items\n    }\n\n    protected fun resize(newSize: Int): IntArray {\n        val newItems = IntArray(newSize)\n        val items = items\n        System_arraycopy(items, 0, newItems, 0, min(size, newItems.size))\n        this.items = newItems\n        return newItems\n    }\n\n    fun sort() {\n        items.sort()\n    }\n\n    fun reverse() {\n        val items = items\n        var i = 0\n        val lastIndex = size - 1\n        val n = size / 2\n        while (i < n) {\n            val ii = lastIndex - i\n            val temp = items[i]\n            items[i] = items[ii]\n            items[ii] = temp\n            i++\n        }\n    }\n\n\n    /** Reduces the size of the array to the specified size. If the array is already smaller than the specified size, no action is\n     * taken.  */\n    fun truncate(newSize: Int) {\n        if (size > newSize) size = newSize\n    }\n\n\n    fun toArray(): IntArray {\n        val array = IntArray(size)\n        System_arraycopy(items, 0, array, 0, size)\n        return array\n    }\n\n    override fun hashCode(): Int {\n        if (!ordered) return super.hashCode()\n        val items = items\n        var h = 1\n        var i = 0\n        val n = size\n        while (i < n) {\n            h = h * 31 + items[i]\n            i++\n        }\n        return h\n    }\n\n    override fun equals(`object`: Any?): Boolean {\n        if (`object` === this) return true\n        if (!ordered) return false\n        if (`object` !is KIntArray) return false\n        val array = `object`\n        if (!array.ordered) return false\n        val n = size\n        if (n != array.size) return false\n        val items1 = items\n        val items2 = array.items\n        for (i in 0 until n) if (items1[i] != items2[i]) return false\n        return true\n    }\n\n    override fun toString(): String {\n        if (size == 0) return \"[]\"\n        val items = items\n        val buffer: StringBuilder = StringBuilder(32)\n        buffer.append('[')\n        buffer.append(items[0])\n        for (i in 1 until size) {\n            buffer.append(\", \")\n            buffer.append(items[i])\n        }\n        buffer.append(']')\n        return buffer.toString()\n    }\n\n    fun toString(separator: String?): String {\n        if (size == 0) return \"\"\n        val items = items\n        val buffer: StringBuilder = StringBuilder(32)\n        buffer.append(items[0])\n        for (i in 1 until size) {\n            buffer.append(separator)\n            buffer.append(items[i])\n        }\n        return buffer.toString()\n    }\n//\n//    companion object {\n//        /** @see .KIntArray\n//         */\n//        fun with(vararg array: Int): KIntArray {\n//            return KIntArray(array)\n//        }\n//    }\n}\n\n\nprivate fun System_arraycopy(src: FloatArray, srcPos: Int, dest: FloatArray, destPos: Int, length: Int) {\n    src.copyInto(dest, destPos, srcPos, srcPos + length)\n}\n\nprivate fun System_arraycopy(src: IntArray, srcPos: Int, dest: IntArray, destPos: Int, length: Int) {\n    src.copyInto(dest, destPos, srcPos, srcPos + length)\n}\n\n/*Based on LibGDX EarClippingTriangulator*/\nclass Triangulator {\n    private val indicesArray = KIntArray()\n    private lateinit var indices: IntArray\n    private lateinit var vertices: FloatArray\n    private var vertexCount = 0\n    private val vertexTypes = KIntArray()\n    private val triangles = KIntArray()\n\n    /** @see .computeTriangles\n     */\n    fun computeTriangles(vertices: KFloatArray): KIntArray {\n        return computeTriangles(vertices.items, 0, vertices.size)\n    }\n\n    /** @see .computeTriangles\n     */\n    fun computeTriangles(vertices: FloatArray): KIntArray {\n        return computeTriangles(vertices, 0, vertices.size)\n    }\n\n    /** Triangulates the given (convex or concave) simple polygon to a list of triangle vertices.\n     * @param vertices pairs describing vertices of the polygon, in either clockwise or counterclockwise order.\n     * @return triples of triangle indices in clockwise order. Note the returned array is reused for later calls to the same\n     * method.\n     */\n    fun computeTriangles(vertices: FloatArray, offset: Int, count: Int): KIntArray {\n        this.vertices = vertices\n        vertexCount = count / 2\n        val vertexCount = vertexCount\n        val vertexOffset = offset / 2\n        val indicesArray: KIntArray = indicesArray\n        indicesArray.clear()\n        indicesArray.ensureCapacity(vertexCount)\n        indicesArray.size = vertexCount\n        this.indices = indicesArray.items\n        val indices = this.indices\n        if (isClockwise(vertices, offset, count)) {\n            for (i in 0 until vertexCount) indices[i] = vertexOffset + i\n        } else {\n            var i = 0\n            val n = vertexCount - 1\n            while (i < vertexCount) {\n                indices[i] = vertexOffset + n - i // Reversed.\n                i++\n            }\n        }\n        val vertexTypes = vertexTypes\n        vertexTypes.clear()\n        vertexTypes.ensureCapacity(vertexCount)\n        var i = 0\n        val n = vertexCount\n        while (i < n) {\n            vertexTypes.add(classifyVertex(i))\n            ++i\n        }\n\n        // A polygon with n vertices has a triangulation of n-2 triangles.\n        val triangles: KIntArray = triangles\n        triangles.clear()\n        triangles.ensureCapacity(max(0, vertexCount - 2) * 3)\n        triangulate()\n        return triangles\n    }\n\n    private fun triangulate() {\n        val vertexTypes = vertexTypes.items\n        while (vertexCount > 3) {\n            val earTipIndex = findEarTip()\n            cutEarTip(earTipIndex)\n\n            // The type of the two vertices adjacent to the clipped vertex may have changed.\n            val previousIndex = previousIndex(earTipIndex)\n            val nextIndex = if (earTipIndex == vertexCount) 0 else earTipIndex\n            vertexTypes[previousIndex] = classifyVertex(previousIndex)\n            vertexTypes[nextIndex] = classifyVertex(nextIndex)\n        }\n        if (vertexCount == 3) {\n            val triangles: KIntArray = triangles\n            val indices = this.indices\n            triangles.add(indices[0])\n            triangles.add(indices[1])\n            triangles.add(indices[2])\n        }\n    }\n\n    /** @return [.CONCAVE] or [.CONVEX]\n     */\n    private fun classifyVertex(index: Int): Int {\n        val indices = this.indices\n        val previous = indices[previousIndex(index)] * 2\n        val current = indices[index] * 2\n        val next = indices[nextIndex(index)] * 2\n        val vertices = vertices\n        return computeSpannedAreaSign(\n            vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1],\n            vertices[next], vertices[next + 1]\n        )\n    }\n\n    private fun findEarTip(): Int {\n        val vertexCount = vertexCount\n        for (i in 0 until vertexCount) if (isEarTip(i)) return i\n\n        // Desperate mode: if no vertex is an ear tip, we are dealing with a degenerate polygon (e.g. nearly collinear).\n        // Note that the input was not necessarily degenerate, but we could have made it so by clipping some valid ears.\n\n        // Idea taken from Martin Held, \"FIST: Fast industrial-strength triangulation of polygons\", Algorithmica (1998),\n        // http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.115.291\n\n        // Return a convex or tangential vertex if one exists.\n        val vertexTypes = vertexTypes.items\n        for (i in 0 until vertexCount) if (vertexTypes[i] != CONCAVE) return i\n        return 0 // If all vertices are concave, just return the first one.\n    }\n\n    private fun isEarTip(earTipIndex: Int): Boolean {\n        val vertexTypes = vertexTypes.items\n        if (vertexTypes[earTipIndex] == CONCAVE) return false\n        val previousIndex = previousIndex(earTipIndex)\n        val nextIndex = nextIndex(earTipIndex)\n        val indices = this.indices\n        val p1 = indices[previousIndex] * 2\n        val p2 = indices[earTipIndex] * 2\n        val p3 = indices[nextIndex] * 2\n        val vertices = vertices\n        val p1x = vertices[p1]\n        val p1y = vertices[p1 + 1]\n        val p2x = vertices[p2]\n        val p2y = vertices[p2 + 1]\n        val p3x = vertices[p3]\n        val p3y = vertices[p3 + 1]\n\n        // Check if any point is inside the triangle formed by previous, current and next vertices.\n        // Only consider vertices that are not part of this triangle, or else we'll always find one inside.\n        var i = nextIndex(nextIndex)\n        while (i != previousIndex) {\n\n            // Concave vertices can obviously be inside the candidate ear, but so can tangential vertices\n            // if they coincide with one of the triangle's vertices.\n            if (vertexTypes[i] != CONVEX) {\n                val v = indices[i] * 2\n                val vx = vertices[v]\n                val vy = vertices[v + 1]\n                // Because the polygon has clockwise winding order, the area sign will be positive if the point is strictly inside.\n                // It will be 0 on the edge, which we want to include as well.\n                // note: check the edge defined by p1->p3 first since this fails _far_ more then the other 2 checks.\n                if (computeSpannedAreaSign(p3x, p3y, p1x, p1y, vx, vy) >= 0) {\n                    if (computeSpannedAreaSign(p1x, p1y, p2x, p2y, vx, vy) >= 0) {\n                        if (computeSpannedAreaSign(p2x, p2y, p3x, p3y, vx, vy) >= 0) return false\n                    }\n                }\n            }\n            i = nextIndex(i)\n        }\n        return true\n    }\n\n    private fun cutEarTip(earTipIndex: Int) {\n        val indices = this.indices\n        val triangles: KIntArray = triangles\n        triangles.add(indices[previousIndex(earTipIndex)])\n        triangles.add(indices[earTipIndex])\n        triangles.add(indices[nextIndex(earTipIndex)])\n        indicesArray.removeIndex(earTipIndex)\n        vertexTypes.removeIndex(earTipIndex)\n        vertexCount--\n    }\n\n    private fun previousIndex(index: Int): Int {\n        return (if (index == 0) vertexCount else index) - 1\n    }\n\n    private fun nextIndex(index: Int): Int {\n        return (index + 1) % vertexCount\n    }\n\n    private fun isClockwise(polygon: FloatArray, offset: Int, count: Int): Boolean {\n        if (count <= 2) return false;\n        var area = 0.0f\n        val last = offset + count - 2;\n        var x1 = polygon[last]\n        var y1 = polygon[last + 1];\n\n        for (i in offset..last step 2) {\n            val x2 = polygon[i]\n            val y2 = polygon[i + 1]\n            area += x1 * y2 - x2 * y1;\n            x1 = x2;\n            y1 = y2;\n        }\n        return area < 0;\n    }\n\n    companion object {\n        private const val CONCAVE = -1\n        private const val CONVEX = 1\n        private fun computeSpannedAreaSign(p1x: Float, p1y: Float, p2x: Float, p2y: Float, p3x: Float, p3y: Float): Int {\n            var area = p1x * (p3y - p2y)\n            area += p2x * (p1y - p3y)\n            area += p3x * (p2y - p1y)\n            return sign(area).toInt()\n        }\n    }\n}","package kmptemplate.ui\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.color.COLOR_MAGENTA\nimport kmptemplate.color.COLOR_RED\nimport kmptemplate.color.COLOR_WHITE\nimport kmptemplate.color.Color\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.gloo.Cam\nimport kmptemplate.gloo.Texture2D\nimport kmptemplate.gloo.fonts.SdfFont\nimport kmptemplate.gloo.fonts.calcHeight\nimport kmptemplate.gloo.fonts.calcWidth\nimport kmptemplate.gloo.immediate.ImmediateMode\nimport kmptemplate.gloo.immediate.ImmediateMode.Companion.ALIGN_CENTER\nimport kmptemplate.gloo.primitives.rayTriangleIntersect\nimport kmptemplate.math.Mat4\nimport kmptemplate.math.Ray\nimport kmptemplate.math.Vec3\nimport kmptemplate.math.isNotNaN\nimport kmptemplate.nodes.Node\nimport kotlin.math.max\n\ntypealias UiEventType = Int\n\ndata class UiEvent(var x: Float, var y: Float, var type: UiEventType, var pointerId: Int, var button: Int, var dropped: List<String>?, var consumed: Boolean, var dx: Float = 0.0f, var dy: Float = 0.0f, var droppedImage: DroppedImage? = null) {\n\n    init {\n        PERF_TRACKER.trackUiEvent()\n    }\n\n    companion object {\n        val MOUSE_DOWN = 1\n        val MOUSE_UP = 2\n        val MOUSE_MOVE = 3\n\n        val MOUSE_BUTTON_LEFT = 1\n        val MOUSE_BUTTON_RIGHT = 2\n        val MOUSE_BUTTON_MIDDLE = 3\n\n        val TOUCH_DOWN = 4\n        val POINTER_DOWN = 5\n        val POINTER_MOVE = 6\n        val POINTER_UP = 7\n        val TOUCH_UP = 8\n\n        val FOCUSED = 10\n        val UNFOCUSED = 11\n\n        val FILE_DROPPED = 12\n\n        val MOUSE_ENTER = 13\n        val MOUSE_LEAVE = 14\n\n        val SCROLL = 15\n\n        fun eventTypeToString(type: UiEventType) = when (type) {\n            MOUSE_DOWN -> \"MOUSE_DOWN\"\n            MOUSE_UP -> \"MOUSE_UP\"\n            MOUSE_MOVE -> \"MOUSE_MOVE\"\n\n            TOUCH_DOWN -> \"TOUCH_DOWN\"\n            POINTER_DOWN -> \"POINTER_DOWN\"\n            POINTER_MOVE -> \"MOVE\"\n            POINTER_UP -> \"POINTER_UP\"\n            TOUCH_UP -> \"TOUCH_UP\"\n\n            FOCUSED -> \"FOCUSED\"\n            UNFOCUSED -> \"UNFOCUSED\"\n\n            FILE_DROPPED -> \"FILE_DROPPED\"\n\n            MOUSE_ENTER -> \"MOUSE_ENTER\"\n            MOUSE_LEAVE -> \"MOUSE_LEAVE\"\n\n            SCROLL -> \"SCROLL\"\n\n            else -> type.toString()\n        }\n    }\n\n    fun consume() {\n        consumed = true\n    }\n\n    override fun toString(): String {\n        return \"UiEvent(${eventTypeToString(type)}, x=${x.toInt()}, y=${y.toInt()}, ptr=$pointerId)\"\n    }\n}\n\n\nobject UiEventPool {\n    val size: Int = 2048\n\n    private val arr = Array(size) { UiEvent(0f, 0f, 0, 0, 0, null, false) }\n    private var i = 0\n\n    fun obtain(x: Float, y: Float, type: UiEventType, pointerId: Int, button: Int, dropped: List<String>? = null, dx: Float = 0.0f, dy: Float = 0.0f, droppedImage: DroppedImage? = null): UiEvent {\n        val event = arr[i++]\n        event.x = x\n        event.y = y\n        event.type = type\n        event.pointerId = pointerId\n        event.button = button\n        event.dropped = dropped\n        event.consumed = false\n        event.dx = dx\n        event.dy = dy\n        event.droppedImage = droppedImage\n        return event\n    }\n\n    fun reset() {\n        i = 0\n    }\n}\n\nabstract class Widget {\n\n    var matrix = Node(Mat4().apply { setIdentity() })\n\n    var width: Float = 0f\n    var height: Float = 0f\n\n    /** x center of the widget*/\n    var x: Float = 0.0f\n\n    /** y center of the widget*/\n    var y: Float = 0.0f\n\n    val bgColor = Node(COLOR_MAGENTA)\n\n    var renderOutline = false\n\n    var drawBg = false\n\n    var visible = Node(true)\n\n    abstract fun measureSelf()\n\n    open fun layoutChilds() {}\n\n    open fun render(im: ImmediateMode, cam: Cam) {\n        if (drawBg) {\n            renderBg(im, cam)\n        }\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n\n    fun renderOutline(im: ImmediateMode, cam: Cam) {\n        im.clear()\n        im.color.set(COLOR_MAGENTA)\n\n        im.line(x - width / 2f, y - height / 2f, 0f, x + width / 2f, y - height / 2f, 0f)\n        im.line(x + width / 2f, y - height / 2f, 0f, x + width / 2f, y + height / 2f, 0f)\n        im.line(x + width / 2f, y + height / 2f, 0f, x - width / 2f, y + height / 2f, 0f)\n        im.line(x - width / 2f, y + height / 2f, 0f, x - width / 2f, y - height / 2f, 0f)\n\n        im.renderColoredLines(cam)\n    }\n\n    val renderBgColor1 = Node(Color(0.95f, 1f, 1f, 1f))\n    val renderBgColor2 = Node(Color(1f, 1f, 1f, 1f))\n    val cornerR = Node(0.3f)\n\n\n    fun renderBg(im: ImmediateMode, cam: Cam) {\n        im.clear()\n        im.renderCardNew(x - width / 2f, y - height / 2f, x + width / 2f, y + height / 2f, cornerR.value, 0.2f, renderBgColor2.value, renderBgColor1.value, cam)\n    }\n\n\n    override fun toString(): String {\n        return \"${this::class.simpleName}(width=$width, height=$height, x=$x, y=$y)\"\n    }\n\n    private val intersection1_tmp_inside = Vec3()\n    private val intersection2_tmp_inside = Vec3()\n    private val v1_tmp_inside = Vec3()\n    private val v2_tmp_inside = Vec3()\n    private val v3_tmp_inside = Vec3()\n    private val v4_tmp_inside = Vec3()\n    private val ray_tmp_inside = Ray()\n\n    fun inside(eventX: Float, eventY: Float, cam: Cam): Boolean {\n        val ray = ray_tmp_inside\n        cam.rayThrough(ray, eventX, eventY)\n\n        val intersection1 = intersection1_tmp_inside\n        val intersection2 = intersection2_tmp_inside\n\n        val v1 = v1_tmp_inside\n        val v2 = v2_tmp_inside\n        val v3 = v3_tmp_inside\n        val v4 = v4_tmp_inside\n\n        v1.set(x - width / 2f, y - height / 2f, 0f)\n        v2.set(x + width / 2f, y - height / 2f, 0f)\n        v3.set(x + width / 2f, y + height / 2f, 0f)\n        v4.set(x - width / 2f, y + height / 2f, 0f)\n\n        intersection1.rayTriangleIntersect(ray, v1, v2, v3)\n        intersection2.rayTriangleIntersect(ray, v1, v3, v4)\n\n        return intersection1.isNotNaN() || intersection2.isNotNaN()\n\n//        return x > this.x - width / 2 && x < this.x + width / 2\n//                && y > this.y - height / 2 && x < this.y + height / 2\n    }\n\n\n    open fun handleEvent(event: UiEvent, cam: Cam) {\n        val inside = inside(event.x, event.y, cam)\n        if (inside) {\n\n            if (event.type == UiEvent.TOUCH_DOWN) {\n                onTouchDown?.invoke(event)\n                event.consume()\n            }\n\n            if (event.type == UiEvent.MOUSE_DOWN) {\n                onMouseDown?.invoke(event)\n                event.consume()\n            }\n\n            if (event.type == UiEvent.TOUCH_UP) {\n                onTouchUp?.invoke(event)\n            }\n\n            if (event.type == UiEvent.MOUSE_UP) {\n                onMouseUp?.invoke(event)\n            }\n\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                onMouseEnter?.invoke(event)\n            }\n        } else {\n            if (event.type == UiEvent.MOUSE_MOVE) {\n                onMouseLeave?.invoke(event)\n            }\n        }\n    }\n\n    var onTouchDown: ((UiEvent) -> Unit)? = null\n    var onTouchUp: ((UiEvent) -> Unit)? = null\n\n    var onMouseDown: ((UiEvent) -> Unit)? = null\n    var onMouseUp: ((UiEvent) -> Unit)? = null\n    var onMouseMove: ((UiEvent) -> Unit)? = null\n\n    var onMouseEnter: ((UiEvent) -> Unit)? = null\n    var onMouseLeave: ((UiEvent) -> Unit)? = null\n\n}\n\nabstract class Compound : Widget() {\n    val widgets = ArrayList<Widget>()\n\n    fun add(widget: Widget) {\n        widgets.add(widget)\n    }\n\n    override fun handleEvent(event: UiEvent, cam: Cam) {\n        for (widget in widgets) {\n            widget.handleEvent(event, cam)\n        }\n        super.handleEvent(event, cam)\n    }\n}\n\nclass Row : Compound() {\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        for (widget in widgets) {\n            widget.measureSelf()\n\n            width += widget.width\n            height = max(height, widget.height)\n        }\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        if (!visible.value) return\n\n        super.render(im, cam)\n\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n    }\n\n    override fun layoutChilds() {\n        val dir = +1 //left to right\n\n        var lx = x - dir * width / 2f\n        val ly = y\n        for (widget in widgets) {\n            widget.x = lx + dir * widget.width / 2f\n            widget.y = ly\n            lx += dir * widget.width\n            widget.layoutChilds()\n        }\n    }\n}\n\n\nfun row(content: (Row.() -> Unit)? = null): Row {\n    val widget = Row()\n    content?.invoke(widget)\n    return widget\n}\n\n\nfun Compound.row(content: (Row.() -> Unit)? = null): Row {\n    val widget = Row()\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nopen class Column : Compound() {\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        for (widget in widgets) {\n            widget.measureSelf()\n            height += widget.height\n            width = max(width, widget.width)\n        }\n    }\n\n    override fun layoutChilds() {\n        val dir = -1 //top to bottom\n\n        val lx = x\n        var ly = y - dir * height / 2f\n        for (widget in widgets) {\n            widget.x = lx\n            widget.y = ly + dir * widget.height / 2f\n            ly += dir * widget.height\n\n            widget.layoutChilds()\n        }\n    }\n\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n\n        super.render(im, cam)\n\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n}\n\nopen class Box : Compound() {\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        for (widget in widgets) {\n            widget.measureSelf()\n            height = max(height, widget.height)\n            width = max(width, widget.width)\n        }\n    }\n\n    override fun layoutChilds() {\n        val lx = x\n        var ly = y\n        for (widget in widgets) {\n            widget.x = lx\n            widget.y = ly\n\n            widget.layoutChilds()\n        }\n    }\n\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n\n        super.render(im, cam)\n\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n}\n\nclass Grid : Compound() {\n\n    var columns = 2\n    var rows = -1\n\n    private var cellWidth = 0.0f\n    private var cellHeight = 0.0f\n\n    override fun measureSelf() {\n        width = 0f\n        height = 0f\n        rows = 0\n\n        for ((i, widget) in widgets.withIndex()) {\n            val newRow = i % columns == 0\n            if (newRow) {\n                rows++\n            }\n\n            widget.measureSelf()\n\n            cellWidth = max(cellWidth, widget.width)\n            cellHeight = max(cellHeight, widget.height)\n        }\n\n\n        width = cellWidth * columns\n        height = cellHeight * rows\n    }\n\n    override fun layoutChilds() {\n        val verDir = -1 //top to bottom\n\n        val horDir = 1 //left to right\n\n        val lx = x - horDir * width / 2f\n        var ly = y - verDir * height / 2f\n\n        for ((i, widget) in widgets.withIndex()) {\n\n            val col = i % columns\n            val row = i / columns\n\n            widget.x = lx + horDir * col * cellWidth + horDir * cellWidth / 2f\n            widget.y = ly + verDir * row * cellHeight + verDir * cellHeight / 2f\n\n            widget.layoutChilds()\n        }\n    }\n\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        for (widget in widgets) {\n            widget.render(im, cam)\n        }\n    }\n}\n\n\nfun column(content: (Column.() -> Unit)? = null): Column {\n    val widget = Column()\n    content?.invoke(widget)\n    return widget\n}\n\nfun Compound.column(content: (Column.() -> Unit)? = null): Column {\n    val widget = Column()\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\n\nfun Compound.box(content: (Box.() -> Unit)? = null): Box {\n    val widget = Box()\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nfun Compound.grid(content: (Grid.() -> Unit)? = null): Grid {\n    val g = Grid()\n    content?.invoke(g)\n    add(g)\n    return g\n}\n\nfun grid(content: (Grid.() -> Unit)? = null): Grid {\n    val g = Grid()\n    content?.invoke(g)\n    return g\n}\n\nclass Space(w: Float, h: Float) : Widget() {\n    init {\n        width = w\n        height = h\n    }\n\n    override fun measureSelf() {\n    }\n\n    override fun layoutChilds() {\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        super.render(im, cam)\n    }\n\n}\n\nfun Compound.space(w: Float, h: Float = w, content: (Space.() -> Unit)? = null): Space {\n    val widget = Space(w, h)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\n\nclass Padding(val left: Float, val right: Float, val top: Float, val bottom: Float) : Compound() {\n    override fun measureSelf() {\n\n        require(widgets.size == 1) { \"Padding supports only one and single widget inside\" }\n        val widget = widgets[0]\n        widget.measureSelf()\n\n        width = widget.width + left + right\n        height = widget.height + top + bottom\n    }\n\n    override fun layoutChilds() {\n        require(widgets.size == 1) { \"Padding supports only single widget inside\" }\n        val widget = widgets[0]\n\n        widget.x = x - width / 2f + left + widget.width / 2f\n        widget.y = y - height / 2f + bottom + widget.height / 2f\n\n        widget.layoutChilds()\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        super.render(im, cam)\n        widgets[0].render(im, cam)\n    }\n}\n\nfun Compound.padding(left: Float, right: Float, top: Float, bottom: Float, content: (Padding.() -> Unit)? = null): Padding {\n    val widget = Padding(left, right, top, bottom)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nfun Compound.padding(p: Float, content: (Padding.() -> Unit)? = null) = padding(p, p, p, p, content)\n\nclass TextWidget(var text: Node<String>, val font: SdfFont, var fontSize: Float = 8f) : Widget() {\n    var color = Node(COLOR_WHITE)\n    var outlineColor = Node<Color?>(null)\n\n    var compress = 0.65f\n\n    constructor(text: String, font: SdfFont, fontSize: Float = 8f) :\n            this(Node(text), font, fontSize)\n\n    override fun measureSelf() {\n        width = calcWidth(text.value, fontSize, compress)\n        height = calcHeight(text.value, fontSize)\n    }\n\n    override fun layoutChilds() {\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        im.clear()\n\n        super.render(im, cam)\n\n        im.clear()\n        im.renderText(text.value, font, x, y, fontSize, color.value, cam, horAlign = ALIGN_CENTER, verAlign = ALIGN_CENTER, weight = 0.52f, compress = compress, outlineColor = outlineColor.value)\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n\n        if (DEBUG_RENDERING) {\n            im.clear()\n            im.color.set(COLOR_RED)\n            im.pivot(x, y, 0f, 1.0f)\n            im.renderColoredLines(cam)\n        }\n    }\n\n    override fun toString(): String {\n        return super.toString() + \" (text='$text', font=$font, fontSize=$fontSize)\"\n    }\n\n    companion object {\n        val DEBUG_RENDERING = false\n    }\n\n\n}\n\nfun Compound.text(text: Node<String>, font: SdfFont, fontSize: Float, content: (TextWidget.() -> Unit)? = null): TextWidget {\n    val widget = TextWidget(text, font, fontSize)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nfun Compound.text(text: String, font: SdfFont, fontSize: Float, content: (TextWidget.() -> Unit)? = null): TextWidget {\n    val widget = TextWidget(text, font, fontSize)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n\nclass ImageWidget(texture: Texture2D, w: Float, var h: Float) : Widget() {\n    var texture = Node(texture)\n    var color = Node(COLOR_WHITE)\n\n    var compress = 0.65f\n\n    init {\n        width = w\n        height = h\n    }\n\n    override fun measureSelf() {\n    }\n\n    override fun layoutChilds() {\n    }\n\n    override fun render(im: ImmediateMode, cam: Cam) {\n        if (!visible.value) return\n\n        im.clear()\n\n        im.pos(x - width / 2f, y - width / 2f, 0f)\n        im.pos(x + width / 2f, y - width / 2f, 0f)\n        im.pos(x + width / 2f, y + width / 2f, 0f)\n        im.texCoord(0f, 1f)\n        im.texCoord(1f, 1f)\n        im.texCoord(1f, 0f)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.pos(x - width / 2f, y - width / 2f, 0f)\n        im.pos(x + width / 2f, y + width / 2f, 0f)\n        im.pos(x - width / 2f, y + width / 2f, 0f)\n        im.texCoord(0f, 1f)\n        im.texCoord(1f, 0f)\n        im.texCoord(0f, 0f)\n\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n        im.color(COLOR_WHITE)\n\n        im.renderTex(texture.value, cam, matrix.value)\n\n        if (renderOutline) {\n            renderOutline(im, cam)\n        }\n    }\n}\n\nfun Compound.img(texture: Texture2D, w: Float, h: Float, content: (ImageWidget.() -> Unit)? = null): ImageWidget {\n    val widget = ImageWidget(texture, w, h)\n    content?.invoke(widget)\n    add(widget)\n    return widget\n}\n","package kmptemplate.analytics\n\nimport kotlinx.browser.window\nimport kotlin.js.json\n\nclass JsYaMetricaAnalytics(val id: String) : Analytics() {\n\n    override fun sendEvent(event: String, map: Map<String, Any>) {\n        val w = window.asDynamic()\n\n        val arrayOfPairs = map.entries.map { Pair(it.key, it.value) }.toTypedArray()\n        val jsMap = json(*arrayOfPairs)\n\n        w.ym(id, \"reachGoal\", event, jsMap)\n    }\n}","package kmptemplate.asteroids\n\nimport kotlinx.browser.window\n\nactual val platformName: String = \"js\"\n\nprivate val mobilePlatforms = listOf(\"iPhone\", \"iPod\", \"iPad\", \"Android\", \"IEmobile\", \"Blackberry\", \"WebOS\", \"Opera Mini\", \"Opera Mobile\")\n\nfun hasTouchUi() = mobilePlatforms.any { platform ->\n    window.navigator.userAgent.contains(platform, ignoreCase = true)\n}\n\nactual fun hasHardwareKeyboard() = !hasTouchUi()\n","package kmptemplate.browser\n\nimport kotlinx.browser.document\nimport org.w3c.dom.HTMLElement\n\nfun downloadContent(content: String, filename: String) {\n\n    val pom = document.createElement(\"a\") as HTMLElement\n    pom.setAttribute(\"href\", \"data:text/plain;charset=utf-8,\" + encodeURIComponent(content));\n    pom.setAttribute(\"download\", filename)\n\n    pom.click()\n}\n\nfun downloadData(dataUrl: String, filename: String) {\n    val pom = document.createElement(\"a\") as HTMLElement\n    pom.setAttribute(\"href\", dataUrl);\n    pom.setAttribute(\"download\", filename)\n\n    pom.click()\n}\n\nexternal fun encodeURIComponent(content: String): String","package kmptemplate.data\n\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.get\nimport org.khronos.webgl.set\n\nactual class FloatArr actual constructor(actual val size: Int) {\n    val data = Float32Array(size)\n    actual operator fun get(index: Int): Float {\n        return data[index]\n    }\n    actual operator fun set(index: Int, value: Float) {\n        data[index] = value\n    }\n\n    actual fun copyInto(newarr: FloatArr) {\n        for(i in 0 until size) {\n            newarr[i] = data[i]\n        }\n    }\n}","package kmptemplate.entities\n\nimport org.w3c.dom.Image\n\nactual class DroppedImage(val img: Image)","package kmptemplate.entities\n\nimport kmptemplate.analytics.Analytics\nimport kmptemplate.analytics.CombinedAnalytics\nimport kmptemplate.analytics.JsYaMetricaAnalytics\nimport kmptemplate.analytics.PrintAnalytics\nimport kmptemplate.gloo.Camera\nimport kmptemplate.gloo.GLOO\nimport kmptemplate.gloo.PlainCamera\nimport kmptemplate.gloo.Viewport\nimport kmptemplate.gloo.WebGL\nimport kmptemplate.input.JsKeyboard\nimport kmptemplate.loading.ParallelLoader\nimport kmptemplate.pool.VecPool\nimport kmptemplate.sound.HowlerSoundManager\nimport kmptemplate.sound.SoundManager\nimport kmptemplate.storage.JsLocalStorage\nimport kmptemplate.storage.Storage\nimport kmptemplate.storage.YaGamesSafeStorage\nimport kmptemplate.tetris.YaGamesAds\nimport kmptemplate.time.currentTimeSeconds\nimport kmptemplate.ui.UiEvent.Companion.FILE_DROPPED\nimport kmptemplate.ui.UiEventPool\nimport kmptemplate.yagames.YaGamesLeaderBoard\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport kotlinx.coroutines.GlobalScope\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.w3c.dom.HTMLCanvasElement\nimport org.w3c.dom.Image\nimport org.w3c.files.File\nimport org.w3c.files.FileReader\n\nclass YaGamesJsPlayer(\n    val yaMetricaId: String,\n    val leaderBoardName: String,\n    val loader: ParallelLoader = ParallelLoader(GlobalScope),\n    val soundman: SoundManager = HowlerSoundManager(),\n    val ads: YaGamesAds = YaGamesAds(),\n    val storage: Storage = if (window.asDynamic().yaGamesSafeStorage == undefined) JsLocalStorage() else YaGamesSafeStorage(),\n    val analytics: Analytics = CombinedAnalytics(JsYaMetricaAnalytics(yaMetricaId), PrintAnalytics()),\n    val leaderBoard: YaGamesLeaderBoard = YaGamesLeaderBoard(leaderBoardName)\n) {\n\n    private var tPrev = Double.NaN\n    private lateinit var keyboard: JsKeyboard\n\n    suspend fun start(entity: Entity) {\n        val canvas = document.getElementById(\"glcanvas\") as HTMLCanvasElement\n\n        val webglContext = canvas.getContext(\"webgl\", mapOf(\"premultipliedAlpha\" to false, \"alpha\" to false, \"antialias\" to false)) as WebGLRenderingContext\n\n        keyboard = JsKeyboard(canvas)\n\n        canvas.ondrop = { e ->\n            e.stopPropagation()\n            e.preventDefault()\n            e.dataTransfer?.files?.let { filelist ->\n                println(filelist)\n                for (i in 0 until filelist.length) {\n\n                    val fileItem = filelist.item(i)!!\n                    val imageFile = fileItem.name.endsWith(\".png\", true) || fileItem.name.endsWith(\".jpg\", true) || fileItem.name.endsWith(\".jpeg\", true)\n                    println(\"dropped file: ${fileItem.name}\")\n                    if (imageFile) {\n                        println(\"image file dropped\")\n                        onImageFileDropped(fileItem)\n                    }\n                }\n            }\n            true\n        }\n        //ondrop not working without it\n        canvas.ondragover = { e ->\n            e.stopPropagation()\n            e.preventDefault()\n            println(\"dragging\")\n        }\n\n        val gl = WebGL(webglContext)\n        gl.viewPort(0, 0, webglContext.canvas.clientWidth, webglContext.canvas.clientHeight)\n\n//        webglContext.pixelStorei(WebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1); // -        \n\n        val soundman = HowlerSoundManager()\n        soundman.init()\n\n        val gloo = GLOO(gl)\n        entity.loadResources(gloo)\n\n        loader.join()\n\n        var lastFrameTime = -100000000.0\n\n        val FRAME_PERIOD = 0.0\n\n        var frameFunc: (Double) -> Unit = { }\n\n        var focused = true\n\n        val unusedCam1 = Camera()\n        val unusedCam2 = PlainCamera()\n\n        gl.enable(kmptemplate.gloo.GL.GL_DEPTH_TEST)\n\n        gl.enable(kmptemplate.gloo.GL.GL_CULL_FACE)\n        gl.cullFace(kmptemplate.gloo.GL.GL_BACK)\n\n        gl.enable(kmptemplate.gloo.GL.GL_BLEND)\n        gl.blendFunc(kmptemplate.gloo.GL.GL_SRC_ALPHA, kmptemplate.gloo.GL.GL_ONE_MINUS_SRC_ALPHA)\n\n        entity.initHierarchy(gloo)\n\n        val viewport = Viewport(100, 100)\n        frameFunc = { now: Double ->\n            val frameTime = now - lastFrameTime\n            if (frameTime > FRAME_PERIOD) {\n                lastFrameTime = now\n\n                val w = (window.innerWidth * window.devicePixelRatio).toInt()\n                val h = (window.innerHeight * window.devicePixelRatio).toInt()\n                canvas.width = w\n                canvas.height = h\n\n                viewport.w = w\n                viewport.h = h\n\n                keyboard.pollKeyboard()\n                keyboard.pollMouse()\n                keyboard.translateEventsToState()\n\n                val t = currentTimeSeconds()\n                if (!tPrev.isNaN()) {\n                    val dt = (t - tPrev).coerceIn(1.0 / 200.0, 1.0 / 30.0)\n                    entity.preUpdateHierarchy(dt, t, keyboard)\n                    entity.updateHierarchy(dt, t, keyboard)\n                }\n                tPrev = t\n\n                entity.renderHierarchy(viewport, unusedCam1, unusedCam2)\n            }\n\n            keyboard.clearEvents()\n            VecPool.reset()\n            UiEventPool.reset()\n\n            if (focused) {\n                window.requestAnimationFrame(frameFunc)\n            }\n        }\n\n        //https://stackoverflow.com/a/3478759/1075978\n        window.addEventListener(\"focus\", {\n            println(\"winow focused\")\n            focused = true\n            window.requestAnimationFrame(frameFunc)\n        }, false)\n        window.addEventListener(\"blur\", {\n            println(\"winow unfocused\")\n            focused = false\n        }, false)\n\n        js(\"\"\"console.log(\"first frame timing: \" + (performance.now()/1000.0 - window.loadingStartTime))\"\"\")\n\n        window.requestAnimationFrame(frameFunc)\n    }\n\n    private fun onImageFileDropped(item: File) {\n        val imgReader = FileReader()\n        imgReader.onload = { e ->\n            val img = Image()\n\n            img.onload = { onloadEvent ->\n                println(\"img.onload ${img.width}x${img.height}\")\n                onImageDropped(DroppedImage(img))\n            }\n\n            img.src = e.asDynamic().target.result as String\n\n\n            println(\"imgReader.onload\")\n            Unit\n        }\n        imgReader.readAsDataURL(item)\n    }\n\n    private fun onImageDropped(img: DroppedImage) {\n        keyboard.notifyEvent(UiEventPool.obtain(0f, 0f, FILE_DROPPED, 0, 0, droppedImage = img))\n    }\n}","package kmptemplate.gloo\n\nactual fun createScreenFramebufferHandle(): FramebufferHandle {\n    return FramebufferHandle(null)\n}","package kmptemplate.gloo\n\nimport kmptemplate.PERF_TRACKER\nimport kmptemplate.browser.downloadData\nimport kmptemplate.entities.DroppedImage\nimport kmptemplate.gloo.Texture2D.Companion.POWERS_OF_TWO\nimport kmptemplate.toFloat32Array\nimport kotlinx.browser.document\nimport org.khronos.webgl.Uint8Array\nimport org.khronos.webgl.WebGLBuffer\nimport org.khronos.webgl.WebGLFramebuffer\nimport org.khronos.webgl.WebGLProgram\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.khronos.webgl.WebGLShader\nimport org.khronos.webgl.WebGLTexture\nimport org.khronos.webgl.WebGLUniformLocation\nimport org.w3c.dom.Image\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.suspendCoroutine\n\nclass WebGL(val gl: WebGLRenderingContext) : GL() {\n\n    private var viewportX = 0\n    private var viewportY = 0\n    private var viewportW = 32\n    private var viewportH = 32\n    override fun clear() {\n//        println(\"WebGL.clear\")\n        gl.clear(WebGLRenderingContext.COLOR_BUFFER_BIT or WebGLRenderingContext.DEPTH_BUFFER_BIT)\n    }\n\n    override fun clearColor(r: Float, g: Float, b: Float, a: Float) {\n//        println(\"WebGL.clearColor\")\n        gl.clearColor(r, g, b, a)\n    }\n\n    override fun viewPort(x: Int, y: Int, width: Int, height: Int) {\n//        println(\"WebGL.viewPort\")\n        gl.viewport(x, y, width, height)\n        viewportX = x\n        viewportY = y\n        viewportW = width\n        viewportH = height\n    }\n\n    override fun createShader(type: ShaderType): ShaderHandle {\n//        println(\"WebGL.createShader\")\n        return ShaderHandle(gl.createShader(type.value)!!)\n    }\n\n    override fun shaderSource(shader: ShaderHandle, code: String) {\n//        println(\"WebGL.shaderSource\")\n        gl.shaderSource(shader.value as WebGLShader, code)\n    }\n\n    override fun compileShader(shader: ShaderHandle) {\n//        println(\"WebGL.compileShader\")\n        gl.compileShader(shader.value as WebGLShader)\n    }\n\n    override fun createProgram(): ProgramHandle {\n//        println(\"WebGL.createProgram\")\n        return ProgramHandle(gl.createProgram()!!)\n    }\n\n    override fun attachShader(program: ProgramHandle, shader: ShaderHandle) {\n//        println(\"WebGL.attachShader\")\n        gl.attachShader(program.value as WebGLProgram, shader.value as WebGLShader)\n    }\n\n    override fun linkProgram(program: ProgramHandle) {\n//        println(\"WebGL.linkProgram\")\n        gl.linkProgram(program.value as WebGLProgram)\n    }\n\n\n    override fun useProgram(program: ProgramHandle) {\n//        println(\"WebGL.useProgram\")\n        gl.useProgram(program.value as WebGLProgram)\n    }\n\n    override fun getUniformLocation(program: ProgramHandle, uniformName: String): UniformLocation {\n//        println(\"WebGL.getUniformLocation\")\n        val location = gl.getUniformLocation(program.value as WebGLProgram, uniformName) ?: throw RuntimeException(\"Uniform ${uniformName} not found (or not used in shader code and optimized by compiler)\")\n        return UniformLocation(location)\n    }\n\n    override fun glUniform1f(location: UniformLocation, x: Float) {\n//        println(\"WebGL.glUniform1f\")\n        gl.uniform1f(location.value as WebGLUniformLocation, x)\n    }\n\n    override fun glUniform2f(location: UniformLocation, x: Float, y: Float) {\n//        println(\"WebGL.glUniform2f\")\n        gl.uniform2f(location.value as WebGLUniformLocation, x, y)\n    }\n\n    override fun glUniform3f(location: UniformLocation, x: Float, y: Float, z: Float) {\n//        println(\"WebGL.glUniform3f\")\n        gl.uniform3f(location.value as WebGLUniformLocation, x, y, z)\n    }\n\n    override fun glUniform4f(location: UniformLocation, x: Float, y: Float, z: Float, w: Float) {\n//        println(\"WebGL.glUniform4f\")\n        gl.uniform4f(location.value as WebGLUniformLocation, x, y, z, w)\n    }\n\n    override fun glUniformMat2f(location: UniformLocation, data: FloatArray) {\n//        println(\"WebGL.glUniformMat2f\")\n        gl.uniformMatrix2fv(location.value as WebGLUniformLocation, false, data.toFloat32Array())\n    }\n\n    override fun glUniformMat3f(location: UniformLocation, data: FloatArray) {\n//        println(\"WebGL.glUniformMat3f\")\n        gl.uniformMatrix3fv(location.value as WebGLUniformLocation, false, data.toFloat32Array())\n    }\n\n    override fun glUniformMat4f(location: UniformLocation, data: FloatArray) {\n//        println(\"WebGL.glUniformMat4f\")\n        gl.uniformMatrix4fv(location.value as WebGLUniformLocation, false, data.toFloat32Array())\n    }\n\n    override fun glUniform1i(location: UniformLocation, v: Int) {\n//        println(\"WebGL.glUniform1i\")\n        gl.uniform1i(location.value as WebGLUniformLocation, v)\n    }\n\n    override fun getAttribLocation(program: ProgramHandle, attribName: String): AttribLocation {\n//        println(\"WebGL.getAttribLocation\")\n        return AttribLocation(gl.getAttribLocation(program.value as WebGLProgram, attribName))\n    }\n\n    override fun vertexAttribPointer(location: AttribLocation, coordsPerVertex: Int, type: DataType, normalized: Boolean, stride: Int, pointer: Int) {\n//        println(\"WebGL.vertexAttribPointer\")\n        gl.vertexAttribPointer(location.value, coordsPerVertex, type.value, normalized, stride, pointer)\n    }\n\n    override fun drawArrays(mode: DrawMode, first: Int, countVerts: Int) {\n//        println(\"WebGL.drawArrays\")\n        PERF_TRACKER.trackDrawCall(countVerts)\n        gl.drawArrays(mode.value, first, countVerts)\n    }\n\n    override fun createBuffer(): BufferHandle {\n//        println(\"WebGL.createBuffer\")\n        return BufferHandle(gl.createBuffer()!!)\n    }\n\n    override fun bufferData(target: BufferTarget, data: FloatBuffer, usage: BufferUsage) {\n//        println(\"WebGL.bufferData\")\n        gl.bufferData(target.value, data.typedArr.data, usage.value)\n    }\n\n    override fun bindBuffer(target: BufferTarget, buffer: BufferHandle) {\n//        println(\"WebGL.bindBuffer\")\n        gl.bindBuffer(target.value, buffer.value as WebGLBuffer)\n    }\n\n    override fun glEnableVertexAttribArray(location: AttribLocation) {\n//        println(\"WebGL.glEnableVertexAttribArray\")\n        gl.enableVertexAttribArray(location.value)\n    }\n\n    override fun glGetShaderInfoLog(shader: ShaderHandle): String {\n//        println(\"WebGL.glGetShaderInfoLog\")\n        return gl.getShaderInfoLog(shader.value as WebGLShader).orEmpty()\n    }\n\n    override fun glGetProgramInfoLog(program: ProgramHandle): String {\n//        println(\"WebGL.glGetProgramInfoLog\")\n        return gl.getProgramInfoLog(program.value as WebGLProgram).orEmpty()\n    }\n\n    override fun glGetError(): Int {\n//        println(\"WebGL.glGetError\")\n        return gl.getError()\n    }\n\n    override fun createTexture(): TextureHandle {\n//        println(\"WebGL.createTexture\")\n        return TextureHandle(gl.createTexture()!!)\n    }\n\n    override fun texParameteri(target: Int, param: Int, value: Int) {\n//        println(\"WebGL.texParameteri\")\n        gl.texParameteri(target, param, value)\n    }\n\n    override fun activeTexture(texture: Int) {\n//        println(\"WebGL.activeTexture\")\n        gl.activeTexture(texture)\n    }\n\n    override fun bindTexture(target: Int, handle: TextureHandle) {\n//        println(\"WebGL.bindTexture\")\n        gl.bindTexture(target, handle.value as WebGLTexture)\n    }\n\n    override suspend fun texImage2D(textureHandle: TextureHandle, path: String) = suspendCoroutine<Pair<Int, Int>> { cont ->\n        val img = Image()\n\n        img.onload = {\n            bindTexture(GL_TEXTURE_2D, textureHandle)\n            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, img)\n\n            // Poor filtering. Needed !\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n\n            if (POWERS_OF_TWO.contains(img.width) && POWERS_OF_TWO.contains(img.height)) {\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n            } else {\n                // Clamp to edge is only option for non power of 2  textures.\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n                texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n            }\n\n            checkErrors()\n            println(\"img.onload ${img.width}x${img.height}\")\n            cont.resume(Pair(img.width, img.height))\n        }\n\n        img.src = path\n    }\n\n    override fun texImage2D(textureHandle: TextureHandle, droppedImage: DroppedImage): Pair<Int, Int> {\n        val img = droppedImage.img\n\n        bindTexture(GL_TEXTURE_2D, textureHandle)\n        gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE, img)\n\n        // Poor filtering. Needed !\n        texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n        texParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n\n        if (POWERS_OF_TWO.contains(img.width) && POWERS_OF_TWO.contains(img.height)) {\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n        } else {\n            // Clamp to edge is only option for non power of 2  textures.\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n            texParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n        }\n\n        checkErrors()\n        println(\"img.onload ${img.width}x${img.height}\")\n        return Pair(img.width, img.height)\n    }\n\n    override fun enable(capability: Int) {\n//        println(\"WebGL.enable\")\n        gl.enable(capability)\n    }\n\n    override fun disable(capability: Int) {\n//        println(\"WebGL.disable\")\n        gl.disable(capability)\n    }\n\n    override fun cullFace(mode: Int) {\n//        println(\"WebGL.cullFace\")\n        gl.cullFace(mode)\n    }\n\n    override fun frontFace(mode: Int) {\n//        println(\"WebGL.frontFace\")\n        gl.frontFace(mode)\n    }\n\n    override fun blendFunc(sfactor: Int, dfactor: Int) {\n//        println(\"WebGL.blendFunc\")\n        gl.blendFunc(sfactor, dfactor)\n    }\n\n    override fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, offset: Int) {\n        gl.texImage2D(target, level, internalformat, width, height, border, format, type, null)\n    }\n\n    override fun scissor(x: Int, y: Int, w: Int, h: Int) {\n        gl.scissor(x, y, w, h)\n    }\n\n    override fun genFramebuffer(): FramebufferHandle {\n        return FramebufferHandle(gl.createFramebuffer())\n    }\n\n    override fun bindFramebuffer(target: Int, handle: FramebufferHandle) {\n        gl.bindFramebuffer(target, handle.value as WebGLFramebuffer?)\n    }\n\n    override fun framebufferTexture2D(target: Int, attachment: Int, texTarget: Int, texture: TextureHandle, level: Int) {\n        gl.framebufferTexture2D(target, attachment, texTarget, texture.value as WebGLTexture, level)\n    }\n\n    override fun readPixels(x: Int, y: Int, w: Int, h: Int, format: Int, type: Int, data: FloatArray) {\n        //TODO(\"not implemented yet\")\n    }\n\n    override fun screenshot(path: String) {\n        //based on this solution: https://stackoverflow.com/a/18804083/1075978\n        println(\"screenshot: ${path}\")\n\n        val w = viewportW\n        val h = viewportH\n\n        val data = Uint8Array(w * h * 4)\n\n        gl.readPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, data)\n\n        val canvas = document.createElement(\"canvas\")\n        val dynCanvas = canvas.asDynamic()\n        dynCanvas.width = w\n        dynCanvas.height = h\n        val context = dynCanvas.getContext(\"2d\")\n\n        val imageData = context.createImageData(w, h)\n        imageData.data.set(data)\n        context.putImageData(imageData, 0, 0)\n\n        val flippedDataUrl = dynCanvas.toDataURL().toString()\n\n        val horScale = 1f\n        val verScale = -1f\n\n        val horTranslate = 0f\n        val verTranslate = h\n\n        val flippedImage = Image()\n        flippedImage.onload = {\n            context.transform(horScale, 0f, 0f, verScale, horTranslate, verTranslate)\n            context.drawImage(flippedImage, 0, 0)\n\n            val dataUrl = dynCanvas.toDataURL().toString()\n\n            downloadData(dataUrl, \"warper.png\")\n            canvas.remove()\n        }\n        flippedImage.src = flippedDataUrl\n    }\n\n    override fun checkFramebufferStatus(target: Int): Int {\n        return gl.checkFramebufferStatus(target)\n    }\n}\n","package kmptemplate.input\n\nimport kmptemplate.asteroids.hasHardwareKeyboard\nimport kmptemplate.ui.UiEvent\nimport kmptemplate.ui.UiEventPool\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport org.w3c.dom.HTMLElement\nimport org.w3c.dom.TouchEvent\nimport org.w3c.dom.events.KeyboardEvent\nimport org.w3c.dom.events.MouseEvent\nimport org.w3c.dom.events.WheelEvent\nimport org.w3c.dom.get\n\nactual typealias Key = String\n\nactual val KEY_Q = \"KeyQ\"\nactual val KEY_W = \"KeyW\"\nactual val KEY_E = \"KeyE\"\nactual val KEY_R = \"KeyR\"\nactual val KEY_T = \"KeyT\"\nactual val KEY_Y = \"KeyY\"\nactual val KEY_U = \"KeyU\"\nactual val KEY_I = \"KeyI\"\nactual val KEY_O = \"KeyO\"\nactual val KEY_P = \"KeyP\"\n\nactual val KEY_A = \"KeyA\"\nactual val KEY_S = \"KeyS\"\nactual val KEY_D = \"KeyD\"\nactual val KEY_F = \"KeyF\"\nactual val KEY_G = \"KeyG\"\nactual val KEY_H = \"KeyH\"\nactual val KEY_J = \"KeyJ\"\nactual val KEY_K = \"KeyK\"\nactual val KEY_L = \"KeyL\"\n\nactual val KEY_Z = \"KeyZ\"\nactual val KEY_X = \"KeyX\"\nactual val KEY_C = \"KeyC\"\nactual val KEY_V = \"KeyV\"\nactual val KEY_B = \"KeyB\"\nactual val KEY_N = \"KeyN\"\nactual val KEY_M = \"KeyM\"\n\nactual val KEY_ARROW_UP = \"ArrowUp\"\nactual val KEY_ARROW_DOWN = \"ArrowDown\"\nactual val KEY_ARROW_LEFT = \"ArrowLeft\"\nactual val KEY_ARROW_RIGHT = \"ArrowRight\"\n\nactual val KEY_ENTER = \"Enter\"\nactual val KEY_SPACE = \"Space\"\nactual val KEY_BACKSPACE = \"Backspace\"\n\nclass JsKeyboard(val element: HTMLElement) : Keyboard() {\n\n    private val keyBuf = HashSet<Key>()\n    private val curKeys = HashSet<Key>()\n    private val prevKeys = HashSet<Key>()\n\n    private var x = 0.0\n    private var y = 0.0\n\n    private val prevMouseBtns = BooleanArray(8)\n    private val curMouseBtns = BooleanArray(8)\n    private val eventMouseBtns = BooleanArray(8)\n\n\n    init {\n        document.addEventListener(\"keydown\", { event ->\n            event as KeyboardEvent\n            keyBuf.add(event.code)\n        }, true)\n\n        document.addEventListener(\"keyup\", { event ->\n            event as KeyboardEvent\n            keyBuf.remove(event.code)\n        }, true)\n\n        document.addEventListener(\"wheel\", { event ->\n            event as WheelEvent\n            println(event.deltaX)\n            println(event.deltaY)\n            println(event.deltaZ)\n            println(event.deltaMode)\n            val wheelSens = -1f / 64f\n            notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.SCROLL, -1, -1, dx = event.deltaX.toFloat() * wheelSens, dy = event.deltaY.toFloat() * wheelSens))\n        }, true)\n\n        if (hasHardwareKeyboard()) {\n            element.addEventListener(\"mousemove\", { event ->\n                event as MouseEvent\n                val dp = window.devicePixelRatio\n\n                x = event.offsetX * dp\n                y = event.offsetY * dp\n\n                val uiEvent = UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.MOUSE_MOVE, 0, 0)\n                notifyEvent(uiEvent)\n\n//                println(\"mousemove ${x} ${y}\")\n            })\n\n            element.addEventListener(\"mouseup\", { event ->\n                event as MouseEvent\n\n//                println(\"mouseup ${event.button}\")\n\n                val dp = window.devicePixelRatio\n\n                x = event.offsetX * dp\n                y = event.offsetY * dp\n\n                val mouseBtn = translateMouseButton(event)\n\n                eventMouseBtns[mouseBtn] = false\n                notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.MOUSE_UP, 0, mouseBtn))\n            })\n\n            element.addEventListener(\"mousedown\", { event ->\n                event as MouseEvent\n                //println(\"mousedown ${event.button}\")\n\n                val mouseBtn = translateMouseButton(event)\n\n                val dp = window.devicePixelRatio\n\n                x = event.offsetX * dp\n                y = event.offsetY * dp\n\n                eventMouseBtns[mouseBtn] = true\n                notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.MOUSE_DOWN, 0, mouseBtn))\n            })\n        } else {\n            element.addEventListener(\"touchstart\", { event ->\n                event as TouchEvent\n\n                val dp = window.devicePixelRatio\n\n                val touchList = event.changedTouches\n                for (i in 0 until touchList.length) {\n                    val touch = touchList[i]!!\n\n                    val x = (touch.pageX.toDouble() - element.offsetLeft) * dp\n                    val y = (touch.pageY.toDouble() - element.offsetTop) * dp\n//                    println(\"touch_down ${touch.identifier}\")\n\n                    notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.TOUCH_DOWN, touch.identifier, 0))\n                }\n            })\n\n            element.addEventListener(\"touchmove\", { event ->\n                event as TouchEvent\n\n                val dp = window.devicePixelRatio\n\n                val touchList = event.changedTouches\n                for (i in 0 until touchList.length) {\n                    val touch = touchList[i]!!\n                    val x = (touch.pageX.toDouble() - element.offsetLeft) * dp\n                    val y = (touch.pageY.toDouble() - element.offsetTop) * dp\n//                    println(\"touchmove ${touch.identifier}\")\n\n                    notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.POINTER_MOVE, touch.identifier, 0))\n                }\n            })\n\n            element.addEventListener(\"touchend\", { event ->\n                event as TouchEvent\n                val dp = window.devicePixelRatio\n\n\n                val touchList = event.changedTouches\n                for (i in 0 until touchList.length) {\n                    val touch = touchList[i]!!\n                    val x = (touch.pageX.toDouble() - element.offsetLeft) * dp\n                    val y = (touch.pageY.toDouble() - element.offsetTop) * dp\n\n//                    println(\"touchend ${touch.identifier}\")\n                    notifyEvent(UiEventPool.obtain(x.toFloat(), y.toFloat(), UiEvent.TOUCH_UP, touch.identifier, 0))\n                }\n            })\n        }\n\n        //https://stackoverflow.com/a/3478759/1075978\n        window.addEventListener(\"focus\", {\n            notifyEvent(UiEventPool.obtain(0f, 0f, UiEvent.FOCUSED, 0, 0))\n        }, false)\n        window.addEventListener(\"blur\", {\n            notifyEvent(UiEventPool.obtain(0f, 0f, UiEvent.UNFOCUSED, 0, 0))\n        }, false)\n\n    }\n\n    override fun pressed(key: Key): Boolean {\n        return curKeys.contains(key)\n    }\n\n    override fun pollKeyboard() {\n        prevKeys.clear()\n        prevKeys.addAll(curKeys)\n\n        curKeys.clear()\n        curKeys.addAll(keyBuf)\n    }\n\n    override fun justPressed(key: Key): Boolean {\n        return curKeys.contains(key) && !prevKeys.contains(key)\n    }\n\n    override fun justReleased(key: Key): Boolean {\n        return !curKeys.contains(key) && prevKeys.contains(key)\n    }\n\n    override fun pollMouse() {\n//        println(\"before\")\n//        println(this)\n\n//        println(\"copy cur to prev\")\n        curMouseBtns.copyInto(prevMouseBtns)\n//        println(this)\n\n//        println(\"copy events to cur\")\n        eventMouseBtns.copyInto(curMouseBtns)\n//        println(this)\n    }\n\n    override fun mousePressed(btn: Int): Boolean {\n        return curMouseBtns[btn]\n    }\n\n    override fun mouseCoords(): Pair<Double, Double> {\n        return Pair(x, y)\n    }\n\n    override fun mouseJustPressed(btn: Int): Boolean {\n        return curMouseBtns[btn] && !prevMouseBtns[btn]\n    }\n\n    override fun mouseJustReleased(btn: Int): Boolean {\n        return !curMouseBtns[btn] && prevMouseBtns[btn]\n    }\n\n    override fun anyKeyJustPressed() = ALL_KEYS.any { justPressed(it) }\n\n    override fun toString(): String {\n        return \"evnt: ${eventMouseBtns.toList()}\\ncur:${curMouseBtns.toList()}\\nprev:${prevMouseBtns.toList()}\"\n    }\n\n    private fun translateMouseButton(event: MouseEvent) =\n        when (event.button.toInt()) {\n            0 -> UiEvent.MOUSE_BUTTON_LEFT\n            1 -> UiEvent.MOUSE_BUTTON_MIDDLE\n            2 -> UiEvent.MOUSE_BUTTON_RIGHT\n            else -> -1\n        }\n}\n","package kmptemplate.sound\n\nclass HowlerSoundBuffer(val howl: dynamic) : SoundBuffer()\n\nprivate external class Howl(cfg: dynamic)\n\nclass HowlerSoundManager : SoundManager() {\n\n    fun init() {\n    }\n\n    override fun play(sound: SoundBuffer): Playback {\n        sound as HowlerSoundBuffer\n        sound.howl.play()\n        return Playback(0, sound)\n    }\n\n    override fun stop(playback: Playback) {\n        println(\"HowlerSoundManager.stop not implemented yet\")\n    }\n\n    override suspend fun loadSoundBuf(path: String): SoundBuffer {\n        val cfg = Any().asDynamic()\n        cfg.src = arrayOf(path)\n\n        return HowlerSoundBuffer(Howl(cfg))\n    }\n\n}","package kmptemplate.storage\n\nimport kotlinx.browser.window\nimport org.w3c.dom.get\nimport org.w3c.dom.set\n\nclass JsLocalStorage : Storage() {\n\n    private val storage = window.localStorage\n\n    init {\n        println(\"using JsLocalStorage\")\n    }\n\n    override fun set(k: String, v: String) {\n        storage.setItem(k, v)\n    }\n\n    override fun get(k: String): String? {\n        return storage.getItem(k)\n    }\n\n    override fun remove(k: String) {\n        storage.removeItem(k)\n    }\n\n    override fun clear() {\n        storage.clear()\n    }\n}","package kmptemplate.storage\n\nimport kotlinx.browser.window\n\nclass YaGamesSafeStorage : Storage() {\n\n    private val storage = window.asDynamic().yaGamesSafeStorage\n\n    init {\n        println(\"using YaGamesSafeStorage\")\n    }\n\n    override fun set(k: String, v: String) {\n        storage.setItem(k, v)\n    }\n\n    override fun get(k: String): String? {\n        return storage.getItem(k) as? String\n    }\n\n    override fun remove(k: String) {\n        storage.removeItem(k)\n    }\n\n    override fun clear() {\n        storage.clear()\n    }\n}","package kmptemplate.tetris\n\nimport kotlinx.browser.window\n\n//https://yandex.ru/dev/games/doc/dg/sdk/sdk-adv.html#recommendations\nclass YaGamesAds : Ads() {\n\n    //    ,    5      -    \n    //     ,      \n    private var lastAdsTryTimeMillis = -1E30\n    private val MIN_ADS_TIME_MS = 10000\n\n    private val yaGamesSdk = window.asDynamic().ysdk\n\n    override fun showInterstitial() {\n        val now = window.performance.now()\n        if (now - lastAdsTryTimeMillis < MIN_ADS_TIME_MS) {\n            println(\"Showing interstitial too often (time left: ${(lastAdsTryTimeMillis + MIN_ADS_TIME_MS - now) / 1000.0}s)\")\n            return\n        }\n        lastAdsTryTimeMillis = now\n\n        val jsCode = \"\"\"\nysdk.adv.showFullscreenAdv({\n          callbacks: {\n          onClose: function(wasShown) {\n                console.log('on ads close. wasShown: ' + wasShown)\n          },\n          onError: function(error) {\n                console.log('on ads error' + error)\n        }\n    }\n})\n\"\"\"\n        try {\n            js(jsCode)\n        } catch (t: Throwable) {\n            println(\"YaGamesAds: failed to execute js code\")\n            t.printStackTrace()\n        }\n    }\n\n    override fun showRewarded(onReward: () -> Unit, onOpen: () -> Unit, onClose: () -> Unit, onError: (Any) -> Unit) {\n        val callbacks = object {\n            val callbacks = object {\n                val onRewarded = {\n                    val now = window.performance.now()\n                    lastAdsTryTimeMillis = now\n\n                    onReward()\n                }\n\n                val onOpen = {\n                    println(\"Rewarded ads opened\")\n                    onOpen()\n                }\n\n                val onClose = {\n                    println(\"Rewarded ads closed\")\n                    onClose()\n                }\n\n                val onError = { e: Any ->\n                    println(\"Rewarded ads error\")\n                    println(e)\n                    onError(e)\n                }\n            }\n        }\n\n        println(\"showing rewarded ads\")\n        yaGamesSdk.adv.showRewardedVideo(callbacks)\n    }\n}\n\n","package kmptemplate.time\n\nimport kotlinx.browser.window\n\nactual fun currentTimeSeconds(): Double {\n    return window.performance.now() / 1000.0\n}","package kmptemplate.yagames\n\nimport kmptemplate.games.leaderboard.LeaderBoard\nimport kotlinx.browser.window\nimport kotlinx.coroutines.await\nimport kotlin.js.Promise\n\n//https://yandex.ru/dev/games/doc/dg/sdk/sdk-leaderboard.html#sdk-leaderboard\n/*\n     .    .\n\n     ,\n    ysdk.isAvailableMethod('leaderboards.setLeaderboardScore'),\n  Promise<Boolean>,\n      .\n */\nclass YaGamesLeaderBoard(val id: String) : LeaderBoard {\n\n    private val yaGamesSdk = window.asDynamic().ysdk\n    private val yaGamesLeaderBoard = window.asDynamic().yaGamesLeaderBoard\n\n    override suspend fun isAvailable(): Boolean {\n        val availablePromise = yaGamesSdk.isAvailableMethod(\"leaderboards.setLeaderboardScore\").unsafeCast<Promise<Boolean>>()\n        return availablePromise.await()\n    }\n\n    override fun setScore(score: Long) {\n        yaGamesLeaderBoard.setLeaderboardScore(id, score.toDouble())\n    }\n}","package kmptemplate\n\nimport kmptemplate.asteroids.GridSampleRender\nimport kmptemplate.gloo.WebGL\nimport kmptemplate.input.JsKeyboard\nimport kmptemplate.sound.WebAudioSoundManager\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport org.khronos.webgl.Float32Array\nimport org.khronos.webgl.WebGLRenderingContext\nimport org.w3c.dom.HTMLCanvasElement\n\n\ninline fun FloatArray.toFloat32Array(): Float32Array {\n    return this.asDynamic() as Float32Array\n}\n\nsuspend fun racingMain() {\n\n//    println(\"Asteroids 0.0.4\")\n\n//    document.writeln(\"Asteroids 0.0.4\")\n\n    console.log(\"log1\")\n    val arr1 = FloatArray(10)\n    console.log(\"log2\")\n    val arr2 = Float32Array(16)\n\n    console.log(\"log3: ${arr1.size}\")\n    console.log(\"log4: ${arr2.length}\")\n    console.log(\"log5: ${arr1.toFloat32Array().length}\")\n\n    val canvas = document.getElementById(\"glcanvas\") as HTMLCanvasElement\n    val webglContext = canvas.getContext(\"webgl\", mapOf(\"premultipliedAlpha\" to false)) as WebGLRenderingContext\n\n    val keyboard = JsKeyboard(canvas)\n\n    val gl = WebGL(webglContext)\n    gl.viewPort(0, 0, webglContext.canvas.width, webglContext.canvas.height)\n\n    webglContext.enable(WebGLRenderingContext.BLEND);\n    webglContext.blendFunc(WebGLRenderingContext.SRC_ALPHA, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA);\n    //gl.pixelStorei(WebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n\n    val soundman = WebAudioSoundManager()\n    soundman.init()\n\n    val renderer = GridSampleRender(gl, keyboard, soundman)\n\n    renderer.init()\n    renderer.onSizeChanged(canvas.width, canvas.height)\n\n    fun requestAnimation() {\n        window.requestAnimationFrame {\n            renderer.render()\n            requestAnimation()\n        }\n    }\n\n    requestAnimation()\n}\n","package kmptemplate.random\n\nimport kotlin.random.Random\n\nfun Random.nextFloat2() = nextFloat() * 2.0f - 1f\nfun Random.nextDouble2() = nextDouble() * 2.0 - 1.0\n\nfun Random.nextFloat(a: Float, b: Float) = a + nextFloat() * (b - a)\nfun Random.nextDouble(a: Double, b: Double) = a + nextDouble() * (b - a)","package kmptemplate.svg\n\nprivate val SUPPORTED_SVG_COMMANDS = arrayOf(\"m\", \"M\", \"z\", \"Z\", \"h\", \"v\", \"l\", \"H\", \"V\", \"L\")\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\nfun svgPath(d: String, line: (x1: Double, y1: Double, y2: Double, y3: Double) -> Unit) {\n    val CMD_MOVE_REL = 'm'\n    val CMD_MOVE_ABS = 'M'\n\n    val CMD_LINE_REL = 'l'\n    val CMD_LINE_ABS = 'L'\n\n    val CMD_HOR_LINE_REL = 'h'\n    val CMD_HOR_LINE_ABS = 'H'\n\n    val CMD_VER_LINE_REL = 'v'\n    val CMD_VER_LINE_ABS = 'V'\n\n    val CMD_CLOSE = 'z'\n\n    val tokens = d.split(' ')\n    var cmd = CMD_MOVE_REL\n\n    var xCur = 0.0\n    var yCur = 0.0\n\n    var xStart = 0.0\n    var yStart = 0.0\n\n    var idx = 0\n\n    for (token in tokens) {\n        val alphaToken = token[0] in 'a'..'z' || token[0] in 'A'..'Z'\n        if (alphaToken && token !in SUPPORTED_SVG_COMMANDS) {\n            throw RuntimeException(\"svg command ${token} not supported yet\")\n        }\n\n        if (token.equals(\"m\")) {\n            cmd = CMD_MOVE_REL\n            continue\n        }\n\n        if (token.equals(\"M\")) {\n            cmd = CMD_MOVE_ABS\n            continue\n        }\n\n        if (token.equals(\"z\") || token.equals(\"Z\")) {\n            cmd = CMD_CLOSE\n            line(xCur, yCur, xStart, yStart)\n            xCur = xStart\n            yCur = yStart\n            continue\n        }\n\n        if (token.equals(\"h\")) {\n            cmd = CMD_HOR_LINE_REL\n            continue\n        }\n        if (token.equals(\"H\")) {\n            cmd = CMD_HOR_LINE_ABS\n        }\n\n        if (token.equals(\"v\")) {\n            cmd = CMD_VER_LINE_REL\n            continue\n        }\n        if (token.equals(\"V\")) {\n            cmd = CMD_VER_LINE_ABS\n            continue\n        }\n\n        if (token.equals(\"l\")) {\n            cmd = CMD_LINE_REL\n            continue\n        }\n\n        if (token.equals(\"L\")) {\n            cmd = CMD_LINE_ABS\n            continue\n        }\n\n\n        if (!alphaToken) {\n            val coords = token.split(',')\n            val x = coords.getOrNull(0)?.toDouble() ?: 0.0\n            val y = coords.getOrNull(1)?.toDouble() ?: 0.0\n\n\n            if (cmd == CMD_MOVE_REL) {\n                xCur += x\n                yCur += y\n                cmd = CMD_LINE_REL\n            } else if (cmd == CMD_MOVE_ABS) {\n                xCur = x\n                yCur = y\n                cmd = CMD_LINE_ABS\n            } else if (cmd == CMD_LINE_REL) {\n                if (idx == 0) {\n                    xStart = xCur\n                    yStart = yCur\n                }\n\n                line(xCur, yCur, xCur + x, yCur + y)\n                xCur += x\n                yCur += y\n                idx++\n            } else if (cmd == CMD_LINE_ABS) {\n                if (idx == 0) {\n                    xStart = xCur\n                    yStart = yCur\n                }\n\n                line(xCur, yCur, x, y)\n                xCur = x\n                yCur = y\n                idx++\n            } else if (cmd == CMD_HOR_LINE_REL) {\n                if (idx == 0) {\n                    xStart = xCur\n                    yStart = yCur\n                }\n\n                line(xCur, yCur, xCur + x, yCur)\n                xCur += x\n                idx++\n            } else if (cmd == CMD_HOR_LINE_ABS) {\n                if (idx == 0) {\n                    xStart = xCur\n                    yStart = yCur\n                }\n\n                line(xCur, yCur, x, yCur)\n                xCur = x\n                idx++\n            } else if (cmd == CMD_VER_LINE_REL) {\n                if (idx == 0) {\n                    xStart = xCur\n                    yStart = yCur\n                }\n\n                val y = x //in case of \"v\" command - the first and single coordinate is y\n                line(xCur, yCur, xCur, yCur + y)\n                yCur += y\n                idx++\n            } else if (cmd == CMD_VER_LINE_ABS) {\n                if (idx == 0) {\n                    xStart = xCur\n                    yStart = yCur\n                }\n\n                val y = x //in case of \"V\" command - the first and single coordinate is y\n                line(xCur, yCur, xCur, y)\n                yCur = y\n                idx++\n            } else {\n                throw RuntimeException(\"Unsupported svg path command: ${cmd}\")\n            }\n        }\n    }\n}","package kmptemplate.tetris\n\nimport kotlinx.browser.window\n\n\nfun yaGamesLoc(): Localization {\n    var lang = \"en\"\n    try {\n\n        println(\"ysdk.asDynamic() = ${window.asDynamic().ysdk}\")\n        println(\"ysdk.asDynamic().environment = ${window.asDynamic().ysdk.environment}\")\n        println(\"ysdk.asDynamic().environment.i18n = ${window.asDynamic().ysdk.environment.i18n}\")\n        println(\"ysdk.asDynamic().environment.i18n.lang = ${window.asDynamic().ysdk.environment.i18n.lang}\")\n\n        lang = window.asDynamic().ysdk.environment.i18n.lang.toString()\n    } catch (t: Throwable) {\n        println(\"failed to get lang from Yandex.Games environment\")\n    }\n\n    return when (lang) {\n        \"en\" -> En()\n        \"ru\" -> Ru()\n        else -> En()\n    }\n}\n\nfun <T> yaGamesLoc(vararg entries: Pair<String, T>): T {\n    var yaGamesLang = \"en\"\n    try {\n\n        println(\"ysdk.asDynamic() = ${window.asDynamic().ysdk}\")\n        println(\"ysdk.asDynamic().environment = ${window.asDynamic().ysdk.environment}\")\n        println(\"ysdk.asDynamic().environment.i18n = ${window.asDynamic().ysdk.environment.i18n}\")\n        println(\"ysdk.asDynamic().environment.i18n.lang = ${window.asDynamic().ysdk.environment.i18n.lang}\")\n\n        yaGamesLang = window.asDynamic().ysdk.environment.i18n.lang.toString()\n    } catch (t: Throwable) {\n        println(\"failed to get lang from Yandex.Games environment\")\n    }\n\n    var en: T? = null\n    for ((lang, loc) in entries) {\n        if (lang == \"en\") en = loc\n        if (lang == yaGamesLang) return loc\n    }\n\n    return en!!\n}","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (5) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 5));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 5) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js.internal\n\n@JsName(\"DoubleCompanionObject\")\ninternal object DoubleCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Double = 4.9E-324\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Double = 1.7976931348623157E308\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Double = 1.0 / 0.0\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Double = -1.0 / 0.0\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Double = -(0.0 / 0.0)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"FloatCompanionObject\")\ninternal  object FloatCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Float = 1.4E-45F\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Float = 3.4028235E38F\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Float = 1.0F / 0.0F\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Float = -1.0F / 0.0F\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Float = -(0.0F / 0.0F)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"IntCompanionObject\")\ninternal  object IntCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Int = -2147483647 - 1\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Int = 2147483647\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"LongCompanionObject\")\ninternal  object LongCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Long = js(\"Kotlin.Long.MIN_VALUE\")\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Long = js(\"Kotlin.Long.MAX_VALUE\")\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"ShortCompanionObject\")\ninternal  object ShortCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Short = -32768\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Short = 32767\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\n@JsName(\"ByteCompanionObject\")\ninternal  object ByteCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Byte = -128\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Byte = 127\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 1\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 8\n}\n\n@JsName(\"CharCompanionObject\")\ninternal  object CharCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    public const val MIN_VALUE: Char = '\\u0000'\n\n    @JsName(\"MAX_VALUE\")\n    public const val MAX_VALUE: Char = '\\uFFFF'\n\n    @JsName(\"MIN_HIGH_SURROGATE\")\n    public const val MIN_HIGH_SURROGATE: Char = '\\uD800'\n\n    @JsName(\"MAX_HIGH_SURROGATE\")\n    public const val MAX_HIGH_SURROGATE: Char = '\\uDBFF'\n\n    @JsName(\"MIN_LOW_SURROGATE\")\n    public const val MIN_LOW_SURROGATE: Char = '\\uDC00'\n\n    @JsName(\"MAX_LOW_SURROGATE\")\n    public const val MAX_LOW_SURROGATE: Char = '\\uDFFF'\n\n    @JsName(\"MIN_SURROGATE\")\n    public const val MIN_SURROGATE: Char = MIN_HIGH_SURROGATE\n\n    @JsName(\"MAX_SURROGATE\")\n    public const val MAX_SURROGATE: Char = MAX_LOW_SURROGATE\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\ninternal  object StringCompanionObject {}\n\ninternal  object BooleanCompanionObject {}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return any { it == element }\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return any { it == element }\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\", hiddenSince = \"1.7\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Double>.max(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Float>.max(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.max(): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.max(): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.max(): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.max(): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.max(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.max(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.max(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Double>.min(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Array<out Float>.min(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.min(): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.min(): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.min(): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.min(): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.min(): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.min(): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.min(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.firstOrNull(): Int? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.firstOrNull(): Long? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the first element, or `null` if the progression is empty.\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.firstOrNull(): Char? {\n    return if (isEmpty()) null else this.first\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Progression $this is empty.\")\n    return this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun IntProgression.lastOrNull(): Int? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun LongProgression.lastOrNull(): Long? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns the last element, or `null` if the progression is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.7\")\npublic fun CharProgression.lastOrNull(): Char? {\n    return if (isEmpty()) null else this.last\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * The returned set is serializable (JVM).\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * The returned set is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element.\n * \n * @throws NoSuchElementException if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.max(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.max(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Double>.min(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Iterable<Float>.min(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.convertToSetForSetOperation()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.convertToSetForSetOperation()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Double>.max(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Float>.max(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Double>.min(): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Sequence<Float>.min(): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the first character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.max(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"maxWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.min(): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minByOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator].\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.7\")\n@kotlin.jvm.JvmName(\"minWithOrThrow\")\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char {\n    if (isEmpty()) throw NoSuchElementException()\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\n@kotlin.js.JsPolyfill(\"\"\"\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\n\"\"\")\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\n@kotlin.js.JsPolyfill(\"\"\"\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n\"\"\")\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@Deprecated(\"Use String.plus() instead\", ReplaceWith(\"this + str\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@Deprecated(\"Use Regex.findAll() instead or invoke matches() on String dynamically: this.asDynamic().match(regex)\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n/**\n * Compares two strings lexicographically, optionally ignoring case differences.\n *\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        for (index in 0 until min) {\n            var thisChar = this[index]\n            var otherChar = other[index]\n\n            if (thisChar != otherChar) {\n                thisChar = thisChar.uppercaseChar()\n                otherChar = otherChar.uppercaseChar()\n\n                if (thisChar != otherChar) {\n                    thisChar = thisChar.lowercaseChar()\n                    otherChar = otherChar.lowercaseChar()\n\n                    if (thisChar != otherChar) {\n                        return thisChar.compareTo(otherChar)\n                    }\n                }\n            }\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n *\n * If the program that calls this function is written in a way that only valid [code] is passed as the argument,\n * using the overload that takes a [UShort] argument is preferable (`Char(intValue.toUShort())`).\n * That overload doesn't check validity of the argument, and may improve program performance when the function is called routinely inside a loop.\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun Char(code: Int): Char {\n    if (code < Char.MIN_VALUE.code || code > Char.MAX_VALUE.code) {\n        throw IllegalArgumentException(\"Invalid Char code: $code\")\n    }\n    return code.toChar()\n}\n\n/**\n * Creates a Char with the specified [code].\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun Char(code: UShort): Char\n\n/**\n * Returns the code of this Char.\n *\n * Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.\n *\n * @sample samples.text.Chars.code\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline val Char.code: Int get() = this.toInt()\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.*\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n *\n * The type can store duration values up to 146 years with nanosecond precision,\n * and up to 146 million years with millisecond precision.\n * If a duration-returning operation provided in `kotlin.time` produces a duration value that doesn't fit into the above range,\n * the returned `Duration` is infinite.\n *\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        if (durationAssertionsEnabled) {\n            if (isInNanos()) {\n                if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n            } else {\n                if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n                if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n            }\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        @ExperimentalTime\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        // Duration construction extension properties in Duration companion scope\n\n        /** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of nanoseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of microseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of milliseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of seconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] equal to this [Long] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of minutes.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] equal to this [Int] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] equal to this [Long] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of hours.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.days get() = toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] equal to this [Long] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.days get() = toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of days.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n        // deprecated static factory functions\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in any of the supported formats.\n         * @sample samples.time.Durations.parse\n         */\n        public fun parse(value: String): Duration = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in ISO-8601 format.\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoString(value: String): Duration = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid ISO duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in any of the supported formats.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *   @sample samples.time.Durations.parse\n         */\n        public fun parseOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in ISO-8601 format.\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoStringOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] days, or [Long.MIN_VALUE] days (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (days: Long, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeDays, hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] hours, or [Long.MIN_VALUE] hours (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (hours: Long, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeHours, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] minutes, or [Long.MIN_VALUE] minutes (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (minutes: Long, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeMinutes, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] seconds, or [Long.MIN_VALUE] seconds (depending on the sign of infinity),\n     *   and zero nanoseconds.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately 292 years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately 292 million years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value\n     * expressed as a combination of numeric components, each in its own unit.\n     *\n     * Each component is a number followed by the unit abbreviated name: `d`, `h`, `m`, `s`:\n     * `5h`, `1d 12h`, `1h 0m 30.340s`.\n     * The last component, usually seconds, can be a number with a fractional part.\n     *\n     * If the duration is less than a second, it is represented as a single number\n     * with one of sub-second units: `ms` (milliseconds), `us` (microseconds), or `ns` (nanoseconds):\n     * `140.884ms`, `500us`, `24ns`.\n     *\n     * A negative duration is prefixed with `-` sign and, if it consists of multiple components, surrounded with parentheses:\n     * `-12m` and `-(1h 30m)`.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * It's recommended to use [toIsoString] that uses more strict ISO-8601 format instead of this `toString`\n     * when you want to convert a duration to a string in cases of serialization, interchange, etc.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val isNegative = isNegative()\n            buildString {\n                if (isNegative) append('-')\n                absoluteValue.toComponents { days, hours, minutes, seconds, nanoseconds ->\n                    val hasDays = days != 0L\n                    val hasHours = hours != 0\n                    val hasMinutes = minutes != 0\n                    val hasSeconds = seconds != 0 || nanoseconds != 0\n                    var components = 0\n                    if (hasDays) {\n                        append(days).append('d')\n                        components++\n                    }\n                    if (hasHours || (hasDays && (hasMinutes || hasSeconds))) {\n                        if (components++ > 0) append(' ')\n                        append(hours).append('h')\n                    }\n                    if (hasMinutes || (hasSeconds && (hasHours || hasDays))) {\n                        if (components++ > 0) append(' ')\n                        append(minutes).append('m')\n                    }\n                    if (hasSeconds) {\n                        if (components++ > 0) append(' ')\n                        when {\n                            seconds != 0 || hasDays || hasHours || hasMinutes ->\n                                appendFractional(seconds, nanoseconds, 9, \"s\", isoZeroes = false)\n                            nanoseconds >= 1_000_000 ->\n                                appendFractional(nanoseconds / 1_000_000, nanoseconds % 1_000_000, 6, \"ms\", isoZeroes = false)\n                            nanoseconds >= 1_000 ->\n                                appendFractional(nanoseconds / 1_000, nanoseconds % 1_000, 3, \"us\", isoZeroes = false)\n                            else ->\n                                append(nanoseconds).append(\"ns\")\n                        }\n                    }\n                    if (isNegative && components > 1) insert(1, '(').append(')')\n                }\n            }\n        }\n    }\n\n    private fun StringBuilder.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean) {\n        append(whole)\n        if (fractional != 0) {\n            append('.')\n            val fracString = fractional.toString().padStart(fractionalSize, '0')\n            val nonZeroDigits = fracString.indexOfLast { it != '0' } + 1\n            when {\n                !isoZeroes && nonZeroDigits < 3 -> appendRange(fracString, 0, nonZeroDigits)\n                else -> appendRange(fracString, 0, ((nonZeroDigits + 2) / 3) * 3)\n            }\n        }\n        append(unit)\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * @param decimals the number of digits after decimal point to show. The value must be non-negative.\n     * No more than 12 decimals will be shown, even if a larger number is requested.\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return formatToExactDecimals(number, decimals.coerceAtMost(12)) + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * The infinite duration is represented as `\"PT9999999999999H\"` which is larger than any possible finite duration in Kotlin.\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        this@Duration.absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            @Suppress(\"NAME_SHADOWING\")\n            var hours = hours\n            if (isInfinite()) {\n                // use large enough value instead of Long.MAX_VALUE\n                hours = 9_999_999_999_999\n            }\n            val hasHours = hours != 0L\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                appendFractional(seconds, nanoseconds, 9, \"S\", isoZeroes = true)\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.roundToLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).roundToLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// deprecated extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n\nprivate fun parseDuration(value: String, strictIso: Boolean): Duration {\n    var length = value.length\n    if (length == 0) throw IllegalArgumentException(\"The string is empty\")\n    var index = 0\n    var result = Duration.ZERO\n    val infinityString = \"Infinity\"\n    when (value[index]) {\n        '+', '-' -> index++\n    }\n    val hasSign = index > 0\n    val isNegative = hasSign && value.startsWith('-')\n    when {\n        length <= index ->\n            throw IllegalArgumentException(\"No components\")\n        value[index] == 'P' -> {\n            if (++index == length) throw IllegalArgumentException()\n            val nonDigitSymbols = \"+-.\"\n            var isTimeComponent = false\n            var prevUnit: DurationUnit? = null\n            while (index < length) {\n                if (value[index] == 'T') {\n                    if (isTimeComponent || ++index == length) throw IllegalArgumentException()\n                    isTimeComponent = true\n                    continue\n                }\n                val component = value.substringWhile(index) { it in '0'..'9' || it in nonDigitSymbols }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitChar = value.getOrElse(index) { throw IllegalArgumentException(\"Missing unit for value $component\") }\n                index++\n                val unit = durationUnitByIsoChar(unitChar, isTimeComponent)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (unit == DurationUnit.SECONDS && dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += parseOverLongIsoComponent(whole).toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                } else {\n                    result += parseOverLongIsoComponent(component).toDuration(unit)\n                }\n            }\n        }\n        strictIso ->\n            throw IllegalArgumentException()\n        value.regionMatches(index, infinityString, 0, length = maxOf(length - index, infinityString.length), ignoreCase = true) -> {\n            result = Duration.INFINITE\n        }\n        else -> {\n            // parse default string format\n            var prevUnit: DurationUnit? = null\n            var afterFirst = false\n            var allowSpaces = !hasSign\n            if (hasSign && value[index] == '(' && value.last() == ')') {\n                allowSpaces = true\n                if (++index == --length) throw IllegalArgumentException(\"No components\")\n            }\n            while (index < length) {\n                if (afterFirst && allowSpaces) {\n                    index = value.skipWhile(index) { it == ' ' }\n                }\n                afterFirst = true\n                val component = value.substringWhile(index) { it in '0'..'9' || it == '.' }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitName = value.substringWhile(index) { it in 'a'..'z' }\n                index += unitName.length\n                val unit = durationUnitByShortName(unitName)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += whole.toLong().toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                    if (index < length) throw IllegalArgumentException(\"Fractional component must be last\")\n                } else {\n                    result += component.toLong().toDuration(unit)\n                }\n            }\n        }\n    }\n    return if (isNegative) -result else result\n}\n\n\nprivate fun parseOverLongIsoComponent(value: String): Long {\n    val length = value.length\n    var startIndex = 0\n    if (length > 0 && value[0] in \"+-\") startIndex++\n    if ((length - startIndex) > 16 && (startIndex..value.lastIndex).all { value[it] in '0'..'9' }) {\n        // all chars are digits, but more than ceiling(log10(MAX_MILLIS / 1000)) of them\n        return if (value[0] == '-') Long.MIN_VALUE else Long.MAX_VALUE\n    }\n    // TODO: replace with just toLong after min JDK becomes 8\n    return if (value.startsWith(\"+\")) value.drop(1).toLong() else value.toLong()\n}\n\n\n\nprivate inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String =\n    substring(startIndex, skipWhile(startIndex, predicate))\n\nprivate inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int {\n    var i = startIndex\n    while (i < length && predicate(this[i])) i++\n    return i\n}\n\n\n\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\nprivate fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\nprivate fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\nprivate fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\nprivate fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\nprivate fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\ninternal expect val durationAssertionsEnabled: Boolean\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\")\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array(arguments)\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    nativeFill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    @Suppress(\"DEPRECATION\")\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@Deprecated(\"Use sortWith instead\", ReplaceWith(\"this.sortWith(Comparator(comparison))\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    nativeSort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 37 ranges totally\nprivate object Digit {\n    internal val rangeStart = intArrayOf(\n        0x0030, 0x0660, 0x06f0, 0x07c0, 0x0966, 0x09e6, 0x0a66, 0x0ae6, 0x0b66, 0x0be6, 0x0c66, 0x0ce6, 0x0d66, 0x0de6, 0x0e50, 0x0ed0, 0x0f20, 0x1040, 0x1090, 0x17e0, \n        0x1810, 0x1946, 0x19d0, 0x1a80, 0x1a90, 0x1b50, 0x1bb0, 0x1c40, 0x1c50, 0xa620, 0xa8d0, 0xa900, 0xa9d0, 0xa9f0, 0xaa50, 0xabf0, 0xff10, \n    )\n}\n\n/**\n * Returns the index of the largest element in [array] smaller or equal to the specified [needle],\n * or -1 if [needle] is smaller than the smallest element in [array].\n */\ninternal fun binarySearchRange(array: IntArray, needle: Int): Int {\n    var bottom = 0\n    var top = array.size - 1\n    var middle = -1\n    var value = 0\n    while (bottom <= top) {\n        middle = (bottom + top) / 2\n        value = array[middle]\n        if (needle > value)\n            bottom = middle + 1\n        else if (needle == value)\n            return middle\n        else\n            top = middle - 1\n    }\n    return middle - (if (needle < value) 1 else 0)\n}\n\n/**\n * Returns an integer from 0..9 indicating the digit this character represents,\n * or -1 if this character is not a digit.\n */\ninternal fun Char.digitToIntImpl(): Int {\n    val ch = this.code\n    val index = binarySearchRange(Digit.rangeStart, ch)\n    val diff = ch - Digit.rangeStart[index]\n    return if (diff < 10) diff else -1\n}\n\n/**\n * Returns `true` if this character is a digit.\n */\ninternal fun Char.isDigitImpl(): Boolean {\n    return digitToIntImpl() >= 0\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 9 ranges totally\n/**\n * Returns `true` if this character is a whitespace.\n */\ninternal fun Char.isWhitespaceImpl(): Boolean {\n    val ch = this.code\n    return ch in 0x0009..0x000d\n            || ch in 0x001c..0x0020\n            || ch == 0x00a0\n            || ch > 0x1000 && (\n                ch == 0x1680\n                || ch in 0x2000..0x200a\n                || ch == 0x2028\n                || ch == 0x2029\n                || ch == 0x202f\n                || ch == 0x205f\n                || ch == 0x3000\n            )\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\nimport kotlin.js.arrayBufferIsView\n\n/**\n * Returns the array if it's not `null`, or an empty array otherwise.\n * @sample samples.collections.Arrays.Usage.arrayOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n/**\n * Returns a *typed* array containing all of the elements of this collection.\n *\n * Allocates an array of runtime type `T` having its size equal to the size of this collection\n * and populates the array with the elements of this collection.\n * @sample samples.collections.Collections.Collections.collectionToTypedArray\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableList\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableListWith\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (arrayBufferIsView(destination) && arrayBufferIsView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}\n\ninternal actual fun brittleContainsOptimizationEnabled(): Boolean = false","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @Deprecated(\"Provided so that subclasses inherit this function\", level = DeprecationLevel.HIDDEN)\n    @JsName(\"toJSON\")\n    protected fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        AbstractList.checkPositionIndex(index, size)\n\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n        final override fun remove(element: E): Boolean = removeEntry(element)\n        abstract fun removeEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    public actual constructor(initialCapacity: Int) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        if (array.size < size) {\n            return toArray() as Array<T>\n        }\n\n        (this.array as Array<T>).copyInto(array)\n\n        if (array.size > size) {\n            array[size] = null as T // null-terminate\n        }\n\n        return array\n    }\n\n    override fun toArray(): Array<Any?> {\n        return js(\"[]\").slice.call(array)\n    }\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    internal open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    internal override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n\n@SinceKotlin(\"1.6\")\npublic actual fun readln(): String = throw UnsupportedOperationException(\"readln is not supported in Kotlin/JS\")\n\n@SinceKotlin(\"1.6\")\npublic actual fun readlnOrNull(): String? = throw UnsupportedOperationException(\"readlnOrNull is not supported in Kotlin/JS\")","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeSinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeCosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeTanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeAsinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeAcosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeAtanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeHypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeExpm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeLog10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeLog2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeLog1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeTrunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeSign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeSign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeSinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeCosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeTanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeAsinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeAcosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeAtanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeHypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeExpm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeLog10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeLog2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeLog1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeSign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeSign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = nativeClz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property `Other_Uppercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property `Other_Lowercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n *\n * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull].\n */\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    char < '\\u0080' -> -1\n    char >= '\\uFF21' && char <= '\\uFF3A' -> char - '\\uFF21' + 10 // full-width latin capital letter\n    char >= '\\uFF41' && char <= '\\uFF5A' -> char - '\\uFF41' + 10 // full-width latin small letter\n    else -> char.digitToIntImpl()\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n@Deprecated(\"Use Regex.matches() instead\", ReplaceWith(\"regex.toRegex().matches(this)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun String.matches(regex: String): Boolean {\n    @Suppress(\"DEPRECATION\")\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\n/**\n * Returns `true` if this string is empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsBlank\n */\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || indices.all { this[it].isWhitespace() }\n\n/**\n * Returns `true` if this string is equal to [other], optionally ignoring character case.\n *\n * Two strings are considered to be equal if they have the same length and the same character at the same index.\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean {\n    if (this == null) return other == null\n    if (other == null) return false\n    if (!ignoreCase) return this == other\n\n    if (this.length != other.length) return false\n\n    for (index in 0 until this.length) {\n        val thisChar = this[index]\n        val otherChar = other[index]\n        if (!thisChar.equals(otherChar, ignoreCase)) {\n            return false\n        }\n    }\n\n    return true\n}\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).uppercase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).lowercase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n * @sample samples.text.Strings.repeat\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n/**\n * Returns a new string obtained by replacing all occurrences of the [oldValue] substring in this string\n * with the specified [newValue] string.\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gui\" else \"gu\"), Regex.nativeEscapeReplacement(newValue))\n\n/**\n * Returns a new string with all occurrences of [oldChar] replaced with [newChar].\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gui\" else \"gu\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"ui\" else \"u\"), Regex.nativeEscapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"ui\" else \"u\"), newChar.toString())\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns the detailed description of this throwable with its stack trace.\n *\n * The detailed description includes:\n * - the short description (see [Throwable.toString]) of this throwable;\n * - the complete stack trace;\n * - detailed descriptions of the exceptions that were [suppressed][suppressedExceptions] in order to deliver this exception;\n * - the detailed description of each throwable in the [Throwable.cause] chain.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.stackTraceToString(): String = ExceptionTraceBuilder().buildFor(this)\n\n/**\n * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to console error output.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.printStackTrace() {\n    console.error(this.stackTraceToString())\n}\n\n/**\n * Adds the specified exception to the list of exceptions that were\n * suppressed in order to deliver this exception.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.addSuppressed(exception: Throwable) {\n    if (this !== exception) {\n        val suppressed = this.asDynamic()._suppressed.unsafeCast<MutableList<Throwable>?>()\n        if (suppressed == null) {\n            this.asDynamic()._suppressed = mutableListOf(exception)\n        } else {\n            suppressed.add(exception)\n        }\n    }\n}\n\n/**\n * Returns a list of all exceptions that were suppressed in order to deliver this exception.\n */\n@SinceKotlin(\"1.4\")\npublic actual val Throwable.suppressedExceptions: List<Throwable>\n    get() {\n        return this.asDynamic()._suppressed?.unsafeCast<List<Throwable>>() ?: emptyList()\n    }\n\n\nprivate class ExceptionTraceBuilder {\n    private val target = StringBuilder()\n    private val visited = arrayOf<Throwable>()\n    private var topStack: String = \"\"\n    private var topStackStart: Int = 0\n\n    fun buildFor(exception: Throwable): String {\n        exception.dumpFullTrace(\"\", \"\")\n        return target.toString()\n    }\n\n    private fun hasSeen(exception: Throwable): Boolean = visited.any { it === exception }\n\n    private fun Throwable.dumpFullTrace(indent: String, qualifier: String) {\n        this.dumpSelfTrace(indent, qualifier) || return\n\n        var cause = this.cause\n        while (cause != null) {\n            cause.dumpSelfTrace(indent, \"Caused by: \") || return\n            cause = cause.cause\n        }\n    }\n\n    private fun Throwable.dumpSelfTrace(indent: String, qualifier: String): Boolean {\n        target.append(indent).append(qualifier)\n        val shortInfo = this.toString()\n        if (hasSeen(this)) {\n            target.append(\"[CIRCULAR REFERENCE, SEE ABOVE: \").append(shortInfo).append(\"]\\n\")\n            return false\n        }\n        visited.asDynamic().push(this)\n\n        var stack = this.asDynamic().stack as String?\n        if (stack != null) {\n            val stackStart = stack.indexOf(shortInfo).let { if (it < 0) 0 else it + shortInfo.length }\n            if (stackStart == 0) target.append(shortInfo).append(\"\\n\")\n            if (topStack.isEmpty()) {\n                topStack = stack\n                topStackStart = stackStart\n            } else {\n                stack = dropCommonFrames(stack, stackStart)\n            }\n            if (indent.isNotEmpty()) {\n                // indent stack, but avoid indenting exception message lines\n                val messageLines = if (stackStart == 0) 0 else 1 + shortInfo.count { c -> c == '\\n' }\n                stack.lineSequence().forEachIndexed { index: Int, line: String ->\n                    if (index >= messageLines) target.append(indent)\n                    target.append(line).append(\"\\n\")\n                }\n            } else {\n                target.append(stack).append(\"\\n\")\n            }\n        } else {\n            target.append(shortInfo).append(\"\\n\")\n        }\n\n        val suppressed = suppressedExceptions\n        if (suppressed.isNotEmpty()) {\n            val suppressedIndent = indent + \"    \"\n            for (s in suppressed) {\n                s.dumpFullTrace(suppressedIndent, \"Suppressed: \")\n            }\n        }\n        return true\n    }\n\n    private fun dropCommonFrames(stack: String, stackStart: Int): String {\n        var commonFrames: Int = 0\n        var lastBreak: Int = 0\n        var preLastBreak: Int = 0\n        for (pos in 0 until minOf(topStack.length - topStackStart, stack.length - stackStart)) {\n            val c = stack[stack.lastIndex - pos]\n            if (c != topStack[topStack.lastIndex - pos]) break\n            if (c == '\\n') {\n                commonFrames += 1\n                preLastBreak = lastBreak\n                lastBreak = pos\n            }\n        }\n        if (commonFrames <= 1) return stack\n        while (preLastBreak > 0 && stack[stack.lastIndex - (preLastBreak - 1)] == ' ')\n            preLastBreak -= 1\n\n        // leave 1 common frame to ease matching with the top exception stack\n        return stack.dropLast(preLastBreak) + \"... and ${commonFrames - 1} more common stack frames skipped\"\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\ninternal fun requireNonNegativeLimit(limit: Int) =\n    require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    requireNonNegativeLimit(limit)\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence to a list of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n * @sample samples.text.Strings.splitToSequence\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.splitToSequence(regex: Regex, limit: Int = 0): Sequence<String> = regex.splitToSequence(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.convertToSetForSetOperation()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.convertToSetForSetOperation())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.convertToSetForSetOperation())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.convertToSetForSetOperation()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence for the second time and the following times.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     *\n     * @sample samples.random.Randoms.nextBits\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextInt\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextLong\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + (nextInt().toLong() and 0xFFFF_FFFF)\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     *\n     * @sample samples.random.Randoms.nextBoolean\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextDouble\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextFloat\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random(), Serializable {\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        private object Serialized : Serializable {\n            private const val serialVersionUID = 0L\n\n            private fun readResolve(): Any = Random\n        }\n\n        private fun writeReplace(): Any = Serialized\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray =\n            defaultRandom.nextBytes(array, fromIndex, toIndex)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom internal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random(), Serializable {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n\n    private companion object {\n        private const val serialVersionUID: Long = 0L\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(): Int {\n    return digitOf(this, 10).also {\n        if (it < 0) throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n    }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(): Int? {\n    return digitOf(this, 10).takeIf { it >= 0 }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n    return digitOf(this, radix).takeIf { it >= 0 }\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercase(): String\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.titlecaseChar(): Char\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.titlecase()` returns `\"\\u0046\\u0066\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no title case mapping, the result of [uppercase] is returned instead.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic fun Char.titlecase(): String = titlecaseImpl()\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * Two characters are considered equal ignoring case if `Char.uppercaseChar().lowercaseChar()` on each character produces the same result.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    val thisUpper = this.uppercaseChar()\n    val otherUpper = other.uppercaseChar()\n\n    return thisUpper == otherUpper || thisUpper.lowercaseChar() == otherUpper.lowercaseChar()\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic expect val Char.category: CharCategory\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDefined(): Boolean\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetter(): Boolean\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetterOrDigit(): Boolean\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDigit(): Boolean\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property `Other_Uppercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isUpperCase(): Boolean\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property `Other_Lowercase` as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLowerCase(): Boolean\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isTitleCase(): Boolean\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isISOControl(): Boolean\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic expect fun Char.isWhitespace(): Boolean\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\")\n@JsPolyfill(\"\"\"\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n[Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array].forEach(function (TypedArray) {\n    if (typeof TypedArray.prototype.fill === \"undefined\") {\n        Object.defineProperty(TypedArray.prototype, 'fill', {\n            value: Array.prototype.fill\n        });\n    }\n})\n\"\"\")\ninternal inline fun Any.nativeFill(element: Any?, fromIndex: Int, toIndex: Int): Unit {\n    asDynamic().fill(element, fromIndex, toIndex)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.cancellation\n\n@SinceKotlin(\"1.4\")\npublic actual open class CancellationException : IllegalStateException {\n    actual constructor() : super()\n    actual constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * An interface for indexing access to a collection of key-value pairs, where type of key is [String] and type of value is [Any?][Any].\n */\npublic external interface Json {\n    /**\n     * Calls to the function will be translated to indexing operation (square brackets) on the receiver with [propertyName] as the argument.\n     *\n     * E.g. for next code:\n     * ```kotlin\n     * fun test(j: Json, p: String) = j[\"prop\"] + j.get(p)\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p) {\n     *     return j[\"prop\"] + j[p];\n     * }\n     * ```\n     */\n    operator fun get(propertyName: String): Any?\n\n    /**\n     * Calls of the function will be translated to an assignment of [value] to the receiver indexed (with square brackets/index operation) with [propertyName].\n     *\n     * E.g. for the following code:\n     * ```kotlin\n     * fun test(j: Json, p: String, newValue: Any) {\n     *     j[\"prop\"] = 1\n     *     j.set(p, newValue)\n     * }\n     * ```\n     *\n     * will be generated:\n     * ```js\n     * function test(j, p, newValue) {\n     *     j[\"prop\"] = 1;\n     *     j[p] = newValue;\n     * }\n     * }\n     * ```\n     */\n    operator fun set(propertyName: String, value: Any?): Unit\n}\n\n/**\n * Returns a simple JavaScript object (as [Json]) using provided key-value pairs as names and values of its properties.\n */\npublic fun json(vararg pairs: Pair<String, Any?>): Json {\n    val res: dynamic = js(\"({})\")\n    for ((name, value) in pairs) {\n        res[name] = value\n    }\n    return res\n}\n\n/**\n * Adds key-value pairs from [other] to [this].\n * Returns the original receiver.\n */\npublic fun Json.add(other: Json): Json {\n    val keys: Array<String> = js(\"Object\").keys(other)\n    for (key in keys) {\n        if (other.asDynamic().hasOwnProperty(key)) {\n            this[key] = other[key];\n        }\n    }\n    return this\n}\n\n/**\n * Exposes the JavaScript [JSON object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external object JSON {\n    public fun stringify(o: Any?): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: Int): String\n    public fun stringify(o: Any?, replacer: ((key: String, value: Any?) -> Any?)? = definedExternally, space: String): String\n    public fun stringify(o: Any?, replacer: Array<String>): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: Int): String\n    public fun stringify(o: Any?, replacer: Array<String>, space: String): String\n\n    public fun <T> parse(text: String): T\n    public fun <T> parse(text: String, reviver: ((key: String, value: Any?) -> Any?)): T\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MathKt\")\n\n\npackage kotlin.math\n\n\n\n// constants, can't use them from nativeMath as they are not constants there\n\n/** Ratio of the circumference of a circle to its diameter, approximately 3.14159. */\n@SinceKotlin(\"1.2\")\npublic const val PI: Double = 3.141592653589793\n/** Base of the natural logarithms, approximately 2.71828. */\n@SinceKotlin(\"1.2\")\npublic const val E: Double = 2.718281828459045\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Double): Double\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Double): Double\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Double): Double\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Double): Double\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Double): Double\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Double): Double\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Double, x: Double): Double\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Double): Double\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Double): Double\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Double): Double\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Double): Double\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Double, y: Double): Double\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Double): Double\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Double): Double\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Double): Double\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Double, base: Double): Double\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Double): Double\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Double): Double\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Double): Double\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Double): Double\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Double): Double\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Double): Double\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Double): Double\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Double): Double\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Double, b: Double): Double\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Double, b: Double): Double\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(x: Double): Double\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.pow(n: Int): Double\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.absoluteValue: Double\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.sign: Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Double): Double\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.withSign(sign: Int): Double\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Double.ulp: Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextUp(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextDown(): Double\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.nextTowards(to: Double): Double\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToInt(): Int\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Double.roundToLong(): Long\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sin(x: Float): Float\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cos(x: Float): Float\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tan(x: Float): Float\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asin(x: Float): Float\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acos(x: Float): Float\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan(x: Float): Float\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atan2(y: Float, x: Float): Float\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sinh(x: Float): Float\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun cosh(x: Float): Float\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun tanh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun asinh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun acosh(x: Float): Float\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun atanh(x: Float): Float\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\npublic expect fun hypot(x: Float, y: Float): Float\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sqrt(x: Float): Float\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun exp(x: Float): Float\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun expm1(x: Float): Float\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log(x: Float, base: Float): Float\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln(x: Float): Float\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log10(x: Float): Float\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun log2(x: Float): Float\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ln1p(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun ceil(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun floor(x: Float): Float\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun truncate(x: Float): Float\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun round(x: Float): Float\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(x: Float): Float\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun sign(x: Float): Float\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Float, b: Float): Float\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Float, b: Float): Float\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(x: Float): Float\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.pow(n: Int): Float\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.absoluteValue: Float\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect val Float.sign: Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Float): Float\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.withSign(sign: Int): Float\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToInt(): Int\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic expect fun Float.roundToLong(): Long\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Int): Int\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Int, b: Int): Int\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Int, b: Int): Int\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.absoluteValue: Int\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Int.sign: Int\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic expect fun abs(n: Long): Long\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun min(a: Long, b: Long): Long\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\npublic expect fun max(a: Long, b: Long): Long\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.absoluteValue: Long\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic expect val Long.sign: Int\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.native.concurrent.SharedImmutable\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces `StackOverflowError` because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.7\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.7\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.7\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\n@SharedImmutable\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n",null,null,"/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(466);\n"],"names":["root","factory","exports","module","define","amd","this","Entity","game","text","loc","WITH_AIM_for_ads","resources","font","color","with_aim_FOR_ADS","soundManager","buttonSound","analytics","logPlayWithAimPressed","ads","println","close","padding","drawBg","renderBgColor1","YELLOW1","renderBgColor2","YELLOW2","column","onMouseDown","onTouchDown","without_aim","logPlayWithoutAimPressed","bgColor","parent","Vec3","x","y","R","Mat4","Quaternion","Color","currentTimeSeconds","gloo","ImmediateMode","COLOR_WHITE","COLOR_BLACK","inputActive","input","event","uiCam","measureSelf","layoutChilds","gl","GL","GL_DEPTH_TEST","lvl","active","menu","distSq","l1","l2","segLengthSq","p","VecPool","obtainVec3","p_l1","l2_l1","coerceIn","dot","t","nearestPointOnSegment","nearestPoint","vec","toVec","normSq","proj","pj","normal","trimIndent","prog","OrthoCamera","Viewport","CoroutineScope","Job","Dispatchers","Default","im","createBuffer","orientation","nextFloat2","Random","normalize","vel","K","norm","k","dt","exp","q","pos","table","walls","isEmpty","element","np","wall","p1","p2","n","a","sq","reflect","ref","touchAnyWall","ballWallSound","cam","clear","shadowSize","ballShadowTexture","setQuaternion","inversed","setIdentity","PI","ph","cos","tintColor","COLOR_RED","ballShader","use","aCoord","aTexCoord","uPos","uTexture","texture","uEnvTexture","envTexture","uTint","uTranslate","uRotate","uProj","projMatrix","uView","viewMatrix","GL_TRIANGLES","frame","distToSegmentSq","time","v1_","v1","v2_","v2","pos1","pos2","code","beatBall","allBalls","allBallsStopped","sling","started","winScreen","startTimeSeconds","speedScale","indicatorSize","mapOf","level","shots","reward","IntArr2D","TOTAL_BALLS_COUNT","Ray","COLOR_GRAY","restorePrevState","gameover_SAVE_THE_BALL_for_ads","gameover_save_the_ball_FOR_ADS","showInterstitial","value","withAim","gotoMenu","game_over","beat_ball_should_not_get_in_pocket","try_again","goto_menu","ballsCount","array","i","originalLevel","LevelDescriptor","LEVELS_COUNT","reset","startContour","textureTable","loader","textIm","BallShader","left","right","bottom","top","centerX","centerY","Table","Sling","Ball","beatTexture","ballTextures","nextFloat","newBall","freeBalls","collider","Collider","beatIndicator","BeatIndicator","indicatorTexture","LevelsMenu","gameOver","GameOver","WinScreen","aimDialog","AimDialog","notEnoughStarsDialog","NotEnoughStarsDialog","tutorial","Tutorial","topBar","TopBar","iconScene","IconScene","finger","Finger","fps","FpsEntity","viewport","w","h","portrait","menuHeight","worldUp","topBarCam","BILLIARD_GREEN","show","aim","setZero","stopAllBalls","SdfFont","clothTexture","starTexture","emptyStarTexture","lockTexture","pocketTexture","woodTexture","handTexture","retryIcon","menuIcon","gameOverSound","winSound","ballInPocketSound","ballBallSound","ballCueSound","storage","records","newRecords","sort","bestShots","first","score","sortDescending","finished","i1","i2","b1","b2","s1","s0","i0","b","type","UiEvent","MOUSE_MOVE","MOUSE_UP","MOUSE_DOWN","intersect","plane","isNotNaN","MOUSE_ENTER","MOUSE_LEAVE","horizontal","handOffsetX","handOffsetY","halfHandSize","PERF_TRACKER","allocsCount","drawCallsCount","drawVertsCount","glBufUploads","glBufUploadBytes","tagsInfo","COLOR_DARK_RED","ALIGN_RIGHT","ALIGN_TOP","best","mid","Node","outlineColor","COLOR_CYAN","compress","img","cond","trueValue","falseValue","onChange","calcOnChange","res","visible","not","row","box","game_name","space","node","totalStarsNode","toString","totalScoreNode","grid","columns","lvlToStarsToUnlock","not_enough_stars_OK","disableDepthTest","enableDepthTest","totalStarsCount","totalScore","levels","starsCount","reloadStars","count","stars","s","BallPhysics","Sphere","x1","y1","x2","y2","ext","mutableListOf","Wall","Plane","Trigger","setNaN","setNode","matrix","F_PI","play_again","you_win","mouseCoords","mx","my","button","MOUSE_BUTTON_LEFT","obtainRay","ray","TOUCH_DOWN","POINTER_MOVE","dist","hasHardwareKeyboard","adjustedPos","nearestCollisionBall","minBallDistSoFar","nearestS","anotherBall","origin","dir","p2_p1","r1","r2","c","d4","d","TOUCH_UP","launchedWithTouch","launchedWithMouse","distToBall","magnitude","ball","ballPos","z","r","COLOR_YELLOW","tmpPos","YELLOW_TRANSPARENT","tableIm","woodIm","shader","TexturedShader","leaderBoard","isAvailable","printStackTrace","pockets","pocket","win","check","justTriggered","v","launch","scope","gotoGameOver","prepareBuffers","tableShader","uModel","IDENT","texCoordsBuf","aPos","linePosBuf","aColor","lineColorBuf","posFB","length","F_2PI","a1","a2","c1","c2","s2","setup","size","verts","Triangulator","indices","idx1","idx2","idx3","scale","tableColor","woodKFar","trng","woodColorMult","svgPath","path","Pocket","idx","resetSlightRandomOrientation","cornerR","isTutorialFinished","frac","ball0","D","dy","ball1","ball2","ball3","camSz","YaGamesJsPlayer","BilliardGame","player","soundman","BilliardStorage","BilliardResources","BilliardAnalytics","yaGamesLoc","En","Ru","entity","GlobalScope","it","key","Analytics","numel","raytrace","vertsCount","bytesCount","tagToCount","tag","MutableInt","joinToString","entries","values","map","emptyMap","analytic","data","codeblock","Vec4","red","green","blue","alpha","g","idCounter","Cam","FloatArr","capacity","typedArr","buf","offset","createScreenFramebufferHandle","color1","color2","childs","unused1","unused2","FAKE_VIEWPORT","width","height","recalc","newFov","newNear","newFar","newPos","newUp","newDir","center","up","degToRad","fov","aspect","near","far","l","cz","cx","cy","sz","winY","fx","fy","m","setMult","verFov","horFov","menuViewport","viewPort","f","newarr","lengthField","GL_FRAMEBUFFER","handle","ScreenHandle","GL_COLOR_ATTACHMENT0","GL_TEXTURE_2D","status","GL_FRAMEBUFFER_COMPLETE","ShaderType","BufferTarget","BufferUsage","DataType","DrawMode","ProgramQuery","ShaderQuery","compilationLog","program","linkLog","location","normalized","stride","pointer","errorChecking","glGetError","err","GL_NO_ERROR","GL_TEXTURE0","unit","checkErrors","GL_RGBA","GL_UNSIGNED_BYTE","usage","STATIC_DRAW","bind","floatBuffer","ARRAY_BUFFER","mat","texUnit","GL_FLOAT","name","Uniform1f","Uniform2f","Uniform3f","Uniform4f","UniformMat4f","UniformSampler2D","Attrib4f","Attrib3f","Attrib2f","Attrib1f","Buffer","VERTEX_SHADER","VertexShader","FRAGMENT_SHADER","FragmentShader","createProgram","vertexShaderCode","fragmentShaderCode","programHandle","vertesShader","fragmentShader","ShaderProgram","createTexture","Texture2D","textureHandle","droppedImage","Framebuffer","genFramebuffer","maxCountInLine","countInLine","btnText","lineSequence","startsWith","line","split","id","xoffset","yoffset","xadvance","page","chnl","prop","toInt","substringAfter","charmap","SdfChar","cachedColoredShader","ColoredShader","cachedLightingShader","LightingShader","cachedCardShader","CardShader","cachedTableShader","TableShader","cachedTexturedShader","cachedSdfFontShader","SdfFontShader","z1","z2","hsz","COLOR_GREEN","COLOR_BLUE","modelMat","GL_LINES","texShader","e1_tmp_rayTriangleIntersect","e2_tmp_rayTriangleIntersect","pvec_tmp_rayTriangleIntersect","tvec_tmp_rayTriangleIntersect","qvec_tmp_rayTriangleIntersect","dir_tmp_rayTriangleIntersect","res_tmp_rayTriangleIntersect","e1","v0","e2","pvec","det","tvec","invDet","u","qvec","trackVec","NaN","KEY_Q","KEY_W","KEY_E","KEY_R","KEY_T","KEY_Y","KEY_U","KEY_I","KEY_O","KEY_P","KEY_A","KEY_S","KEY_D","KEY_F","KEY_G","KEY_H","KEY_J","KEY_K","KEY_L","KEY_Z","KEY_X","KEY_C","KEY_V","KEY_B","KEY_N","KEY_M","KEY_ARROW_UP","KEY_ARROW_DOWN","KEY_ARROW_LEFT","KEY_ARROW_RIGHT","KEY_ENTER","KEY_SPACE","KEY_BACKSPACE","horAlign","ALIGN_CENTER","verAlign","weight","edge","textVertsCount","calcWidth","calcHeight","textWidth","textHeight","x0","fixX","screenX","screenX0","screenY","y0","zz","ch","sdfChar","screenW","screenH","uFontTexture","uColor","uWeight","uThreshold","renderNormals","mesh","posBuf","z0","normalsBuf","NORM_COEFF","nx0","ny0","nz0","nx1","ny1","nz1","nx2","ny2","nz2","meshColor","rnd","uLightColor","uLightPos","aNormal","shadowSz","rr","uOrigin","uSize","uShadowColor","uCornerR","uShadowSz","deg","events","consumed","countTouched","pointerId","POINTER_DOWN","POINTER_UP","print","job","join","newX","newY","newZ","calc","node1","initialValue","fill","col","tx","ty","tz","oc","sx","sy","A","B","c0","c3","c4","c5","c6","c7","c8","c9","c10","c11","c12","c13","c14","c15","fX","eye","fY","fZ","inv","sX","sY","sZ","uX","uY","uZ","fovY","tanHalfFovy","resX","resY","resZ","resW","o","invD","changed","ordered","items","src","dest","destPos","srcPos","defValue","list","emptyList","onOpen","onClose","onError","value1","value2","value3","value4","sizeNeeded","System_arraycopy","index","IndexOutOfBoundsException","second","firstValue","end","start","lastIndex","item","ii","startSize","additionalCapacity","newSize","newItems","temp","hashCode","toRawBits","items1","items2","obj","epsilon","buffer","separator","vertices","indicesArray","vertexCount","vertexOffset","vertexTypes","triangles","earTipIndex","previousIndex","nextIndex","previous","current","next","p3","p3x","p3y","p1x","p1y","vx","vy","p2x","p2y","area","polygon","last","trackUiEvent","dropped","dx","COLOR_MAGENTA","Widget","Compound","content","Padding","widget","renderOutline","simpleName","eventX","eventY","v3","v4","rayTriangleIntersect","intersection1","intersection2","consume","onTouchUp","onMouseUp","onMouseEnter","onMouseLeave","widgets","lx","ly","rows","fontSize","DEBUG_RENDERING","mobilePlatforms","window","navigator","userAgent","hasTouchUi","document","createElement","pom","setAttribute","dataUrl","filename","click","Float32Array","ParallelLoader","HowlerSoundManager","YaGamesAds","undefined","yaGamesSafeStorage","JsLocalStorage","YaGamesSafeStorage","CombinedAnalytics","JsYaMetricaAnalytics","yaMetricaId","PrintAnalytics","YaGamesLeaderBoard","leaderBoardName","e","stopPropagation","preventDefault","dataTransfer","endsWith","fileItem","imageFile","now","innerWidth","devicePixelRatio","innerHeight","pollKeyboard","pollMouse","translateEventsToState","clearEvents","requestAnimationFrame","Image","onload","DroppedImage","target","result","FramebufferHandle","texImage2D","GL_TEXTURE_MAG_FILTER","GL_LINEAR","GL_TEXTURE_MIN_FILTER","POWERS_OF_TWO","GL_TEXTURE_WRAP_S","GL_REPEAT","GL_TEXTURE_WRAP_T","GL_CLAMP_TO_EDGE","Pair","Keyboard","addEventListener","deltaX","deltaY","deltaZ","deltaMode","SCROLL","wheelSens","offsetX","dp","offsetY","uiEvent","mouseBtn","changedTouches","touchList","touch","offsetLeft","offsetTop","identifier","FOCUSED","UNFOCUSED","SoundBuffer","SoundManager","Storage","localStorage","Ads","ysdk","performance","yaGamesLeaderBoard","json","arrayOfPairs","ym","jsMap","getElementById","getContext","JsKeyboard","WebGL","webglContext","canvas","clientWidth","clientHeight","init","GLOO","frameFunc","focused","Camera","PlainCamera","GL_CULL_FACE","GL_BACK","GL_BLEND","GL_SRC_ALPHA","GL_ONE_MINUS_SRC_ALPHA","FileReader","imgReader","readAsDataURL","FILE_DROPPED","WebGLRenderingContext","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","clearColor","ShaderHandle","createShader","shaderSource","compileShader","ProgramHandle","attachShader","linkProgram","useProgram","getUniformLocation","uniformName","UniformLocation","uniform1f","uniform2f","uniform3f","uniform4f","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","uniform1i","AttribLocation","getAttribLocation","attribName","vertexAttribPointer","coordsPerVertex","countVerts","drawArrays","mode","BufferHandle","bufferData","bindBuffer","enableVertexAttribArray","getShaderInfoLog","getProgramInfoLog","getError","TextureHandle","texParameteri","param","activeTexture","bindTexture","enable","capability","disable","cullFace","frontFace","blendFunc","sfactor","dfactor","internalformat","border","format","scissor","createFramebuffer","bindFramebuffer","framebufferTexture2D","attachment","texTarget","Uint8Array","readPixels","dynCanvas","context","createImageData","imageData","set","putImageData","toDataURL","flippedImage","transform","drawImage","downloadData","remove","flippedDataUrl","checkFramebufferStatus","btn","ALL_KEYS","toList","MOUSE_BUTTON_MIDDLE","MOUSE_BUTTON_RIGHT","sound","howl","play","Playback","cfg","HowlerSoundBuffer","Howl","setItem","getItem","removeItem","adv","showRewardedVideo","callbacks","isAvailableMethod","availablePromise","setLeaderboardScore","origin_pos_tmp_intersect","sphere","origin_pos","pbx","pay","roz","poz","paz","roy","poy","pax","pby","pbz","rox","pox","rdy","rdz","rdx","c00","c04","c08","c02","c06","c03","c07","c16","c18","c19","c20","c22","c23","i00","i10","i20","i30","oneOverDet","i01","i02","i03","i11","i12","i13","i21","i22","i23","i31","i32","i33","yy","xy","wz","xz","wy","xx","yz","wx","cmd","xCur","yCur","xStart","yStart","token","alphaToken","SUPPORTED_SVG_COMMANDS","equals","getOrNull","coords","Row","Column","Box","Space","TextWidget","ImageWidget","yaGamesLang","environment","i18n","lang","en","PerformanceTracker","listOf","Kotlin","_","isBooleanArray","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","String","fromCharCode","prototype","call","primitiveArraySort","doubleCompareTo","toByte","toChar","numberToInt","Long","doubleToInt","toBoxedChar","BoxedChar","unboxChar","obj1","obj2","objType","getObjectHashCode","numberHashCode","Number","str","hash","charCodeAt","getStringHashCode","bufFloat64","bufFloat32","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","Math","random","Object","defineProperty","throwMarkerError","Error","imul","isInheritanceFromInterface","ctor","iface","metadata","$metadata$","interfaces","superPrototype","getPrototypeOf","superConstructor","constructor","identityHashCode","low_","low","high_","high","IntCache_","fromInt","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","pow","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","a48","a32","a16","a00","b48","b32","b16","c48","c32","b00","approx","shiftRight","shiftLeft","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","compareTo","typeA","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","floatToRawBits","ensureNotNull","throwNPE","searchString","position","lastIndexOf","subjectString","sign","trunc","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","TypeError","O","len","relativeStart","relativeEnd","finalValue","normalizeOffset","typedArraySlice","begin","subarray","arrays","TypedArray","slice","Function","self","callback","totalOrderComparator","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","get","isType","object","proto","kind","OBJECT","klassMetadata","INTERFACE","isNumber","isChar","isCharSequence","CharSequence","ordinal","initValue","MIN_HIGH_SURROGATE","MAX_LOW_SURROGATE","fillArrayVal","NoSuchElementException","IntRange","checkIndexOverflow","iterator","hasNext","single","j","prefix","postfix","limit","truncated","to","step","EMPTY","minimumValue","maximumValue","destination","optimizeReadOnlyList","TransformingSequence","CharIterator","IntIterator","LongIterator","getProgressionLastElement","endInclusive","NotImplementedError","nextByte","nextChar","nextShort","nextInt","nextLong","nextDouble","nextBoolean","CharProgressionIterator","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","cause","message","Exception","RuntimeException","ArrayList","fromIndex","toIndex","middle","needle","binarySearchRange","diff","toArray","copyToArrayImpl","collection","push","collectionsSort","comparator","copyToArray","startIndex","endIndex","source","destinationOffset","rangeSize","arrayBufferIsView","subrange","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","elements","_stableSortingIsSupported","comparison","getStableSortingIsSupported","mergeSort","median","leftIndex","rightIndex","leftValue","rightValue","checkIsMutable","modified","_index","times","hasPrevious","newValue","oldValue","from","iter","entry","modCount","splice","concat","pop","arrayCopy","internalMap","equality","InternalHashCodeMap","initialCapacity","loadFactor","createJsMap","keys","BaseOutput","BufferedOutput","initialResult","ClassCastException","NEGATIVE_INFINITY","bits","POSITIVE_INFINITY","isInfinite","hi26","INV_2_26","low27","INV_2_53","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","old","newEntry","build","outputStream","write","messageString","flush","console","cur","jsClass","PrimitiveKClassImpl","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","kClass","toUpperCase","uppercase","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","isWhitespaceImpl","char","digitToIntImpl","ignoreCase","JsMath","n1","n2","thisChar","otherChar","uppercaseChar","toLowerCase","isWhitespace","regionMatchesImpl","thisOffset","otherOffset","ExceptionTraceBuilder","_suppressed","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","dstIndex","stringCsq","indent","qualifier","shortInfo","stack","stackStart","suppressed","suppressedIndent","commonFrames","lastBreak","preLastBreak","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","ArithmeticException","contains","isVarargs","pairs","putAll","filterInPlace","predicate","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","block","SequenceScope","sequence","throwOnFailure","FlatteningSequence","itemIterator","nextItemIterator","safe","getOrThrow","acc","removed","interceptor","CombinedContext","baseKey","operation","initial","newLeft","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","doubleFromParts","nextDown","steps","remainder","vr","seed","nativeClz32","boundsErrorMessage","takeUpperBits","seed1","seed2","thisUpper","otherUpper","newIndent","lines","isBlank","collectionSizeOrDefault","checkRadix","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","digit","NumberFormatException","subSequence","range","chars","regionMatches","indexOfAny","charArrayOf","currentStartIndex","requireNonNegativeLimit","DelimitedRangesSequence","currentIndex","strings","findAnyOf","asList","delimiters","currentOffset","delimiter","isLimited","splitToSequence","nextSearchIndex","nextState","nextItem","match","that","reverseOrder","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","captureStackTrace","instance","pair","naturalOrder","output","delegate","NullPointerException","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","toIntOrNull","numberFormatError","suffix","error","stackTraceToString","createCoroutineUnintercepted","replaceIndent","missingDelimiterValue","rangesDelimitedBy","isNode","NodeJsOutput","BufferedOutputToConsoleLog","Comparator","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}